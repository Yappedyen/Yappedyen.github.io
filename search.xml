<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>ThreadsDispatch</title>
      <link href="/2023/06/27/threadsdispatch/"/>
      <url>/2023/06/27/threadsdispatch/</url>
      
        <content type="html"><![CDATA[<h4 id="1、作业调度"><a href="#1、作业调度" class="headerlink" title="1、作业调度"></a>1、作业调度</h4><p>作业调度又称为高级调度，频度较低。其主要工作是将<strong>位于外存</strong>后备<a href="https://so.csdn.net/so/search?q=%E9%98%9F%E5%88%97&amp;spm=1001.2101.3001.7020">队列</a>中的某个（或某几个）作业<strong>调入内存</strong>，排在<strong>就绪队列</strong>上。注意了，这个时候仅仅是将作业调入<a href="https://so.csdn.net/so/search?q=%E5%86%85%E5%AD%98&amp;spm=1001.2101.3001.7020">内存</a>，并为作业<strong>创建进程、分配资源</strong>，此时<strong>进程处于就绪态</strong>，并<strong>没有执行</strong>。</p><h4 id="2、进程调度"><a href="#2、进程调度" class="headerlink" title="2、进程调度"></a>2、进程调度</h4><p>进程调度又称为低级调度，是最基本的、频度最高的调度方式。其主要任务是从<strong>就绪队列中选取</strong>一个（或几个）进程，并<strong>分配处理机</strong>的过程，这时候才可以理解为“<strong>执行</strong>”。</p><h4 id="3、区别"><a href="#3、区别" class="headerlink" title="3、区别"></a>3、区别</h4><p>作业调度和进程调度最主要的区别在于，前者是为作业<strong>建立进程</strong>的过程，是将作业由<strong>外存调入内存</strong>的过程；而后者整个过程并没有跑出内存的范围，是将<strong>就绪态</strong>的进程变为<strong>运行态</strong>的过程。</p><p>一般来说，作业进入系统到最后完成，可能经历三级调度：高级调度、中级调度和低级调度。</p><ol><li><p>高级调度（作业调度）<br>按一定的原则从外存上处于后备队列的作业中挑选一个（或多个）作业，给他们分配内存等必要资源，并建立相应的进程(建立PCB),以使它（们）获得竟争处理机的权利。<br>高级调度是辅存（外存）与内存之间的调度。每个作业只调入一次，调出一次。作业调入时会建立相应的PCB,作业调出时才撤销PCB。高级调度主要是指调入的问题，因为只有调入的时机需要操作系统来确定，但调出的时机必然是作业运行结束才调出。</p></li><li><p>中级调度（内存调度）<br>为了使内存中的内存不至于太多，有时需要把某些进程从内存中调到外存。在内存使用情况紧张时，将一些暂时不能运行的进程从内存中对换到外存中等待。当内存有足够的空闲空间时，再将合适的进程重新换入内存。</p></li><li><p>低级调度（进程调度）<br>主要任务是按照某种方法和策略从就绪队列中选取一个进程，将处理机分配给它。进程调度是操作系统中最基本的一种调度，在一般的操作系统中都必须配置进程调度。进程调度的频率很高，一般几十毫秒一次。</p></li></ol><p>一个作业到达时首先被放进后备队列。</p><p>作业调度按一定的算法从后备队列中选择到达的资源能得到满足的作业装入内存，使作业有机会去占用处理器执行。</p><p>所谓的有机会，是因为此后还需要进程调度程序来进行调度，决定哪个进程优先获得CPU，什么时候获得CPU，分配多少CPU时间片，能不能抢占等等，也就是说，调度程序才是大脑，CPU只是一个执行部件而已。</p><p>于是，作业调度选中了一个作业且把它装入内存时，就会为该作业创建一个进程，若有多个作业被装入内存，则内存中同时存在多个进程，这些进程的初始状态为就绪状态，放在就绪队列中，然后，由进程调度程序根据自己的调度算法来选择当前可占用处理器的进程，进程运行中会出现各种状态，有以下些状态会引起调度程序的重新调度决策：</p><p>1.在创建一个新进程时之后，需要决定运行父进程还是子进程</p><p>2.在一个进程运行结束让出CPU使用权的时候，需要重新调度一个进程给CPU</p><p>3.当一个进程阻塞在I/O信号或者信号量或其他上面时，必须选择另外一个进程运行。</p><p>4.在一个I/O中断发生时，某些被阻塞的等待该I/O的程序可能已经进入就绪态，需要重新决策。</p><p>调度算法分为抢占式和非抢占式算法两类，这里区分一下：</p><p><strong>非抢占式</strong>：意味着调度程序调度某进程运行，分配时间片，直到时间片完或者该进程自己由于某些原因阻塞才回打断其执行，否则调度程序不能因为优先级等原因强行调度另一个进程来抢占原有进程的CPU资源。</p><p><strong>抢占式</strong>：意味着调度程序虽然调度了某个进程运行，但是此后调度程序随时可以根据其算法让另一个符合优先执行的进程强制剥夺其CPU资源。</p><p>如此，作业调度与进程调度相互配合实现多道作业的并行执行。</p><p><strong>一个批处理系统中，有两个作业进程。有一个作业序列，到达时间和估计服务时间如下。系统采用最高响应比优先的作业调度算法，作业进程的调度采用短作业优先的抢占式调度算法。请列出各作业的执行情况表。</strong></p><p><img src="/images/v2-99b8a5900fd54e781a26bae536a0fd3b_1440w.jpg"></p><p>那么为什么要制定作业调度算法呢？为什么要搞一个后备队列呢？一个作业到来后直接把它扔到就绪队列中不就好了？实际上我们不这样做的原因是就绪队列的空间可能是有限的。比如题目说的有两个作业进程，说明就绪队列的容量是2，一个作业运行，一个作业就绪。由于不是每个作业都能迅速达到就绪态，所以就需要作业调度来选择进入系统（就绪态）的作业。</p><p>解如下：</p><p>10:00 作业A到达，由于就绪队列空，作业调度进系统，进程调度执行</p><p>10:10 作业B到达，就绪队列未满，作业调度进系统，由于B此时是最短作业，所以进程调度A到就绪态，调度B执行</p><p>作业A已运行10分钟，剩余25分钟</p><p>10:15 作业C到达，响应比为1，等待作业调度进系统</p><p>作业B继续执行，已运行5分钟，剩余25分钟</p><p>作业A剩余25分钟，位于就绪队列</p><p>10:20 作业D到达，响应比为1，等待作业调度进系统</p><p>作业C等待5分钟，响应比R=1+5/45 = 1.11</p><p>作业B继续执行，已运行10分钟，剩余20分钟</p><p>作业A剩余25分钟，位于就绪队列</p><p>10:30 作业E到达，响应比为1，等待作业调度进系统</p><p>作业D等待10分钟，响应比R=1+10/20 = 1.5</p><p>作业C等待15分钟，响应比R=1+15/45 = 1.3</p><p>作业B继续执行，已运行20分钟，剩余10分钟</p><p>作业A剩余25分钟，位于就绪队列</p><p>10:40 作业E等待10分钟，响应比R=1+10/30 = 1.3</p><p>作业D等待20分钟，响应比R=1+20/20 = 2.0</p><p>作业C等待25分钟，响应比R=1+25/45 = 1.6</p><p>作业D具有最高响应比，D被作业调度进系统，由于是最短作业，进程调度D执行</p><p>作业B运行结束</p><p>作业A剩余25分钟，位于就绪队列</p><p>11:00 作业E等待30分钟，响应比R=1+30/30 = 2.0</p><p>作业C等待45分钟，响应比R=1+45/45 = 2.0</p><p>两者响应比相同，由于C先到达，所以作业调度C进系统</p><p>作业D运行20分钟，运行结束</p><p>作业A剩余25分钟，服务时间比C小，进程调度A执行</p><p>11:25 作业E等待55分钟，响应比R=1+55/30 = 2.8，作业调度进系统</p><p>作业C剩余45分钟，位于就绪队列</p><p>作业A运行25分钟，运行结束</p><p>因为C服务时间比E长，所以进程调度E执行</p><p>11:55 作业C剩余45分钟，位于就绪队列</p><p>作业E运行30分钟，运行结束</p><p>12:40 作业C运行结束</p><p>各作业运行时间段为：</p><p>A 10:00-10:10 11:00-11:25</p><p>B 10:10-10:40</p><p>C 11:55-12:40</p><p>D 10:40-11:00</p><p>E 11:25-11:55</p><p><em><strong>题目：</strong></em><br>有一个<strong>两道</strong>批处理系统，它只有<strong>一个CPU</strong>（一次只能处理一个进程），在作业调度算法采用<strong>短作业优先调度</strong>、进程调度算法采用<strong>抢占式优先级调度</strong>。假设有四个作业J1、J2、J3、J4，其运行情况如下表所示，采用“优先数越小、优先级越高”的原则，计算平均周转时间。</p><p><img src="/images/20201011213914639.png" alt="在这里插入图片描述"></p><p><em><strong>解析：</strong></em><br>在做这种题的时候最好画一个就绪队列，或者脑海中想象一个就绪队列，以免思维混乱，初始情况下就绪队列为空：</p><p><img src="/images/20201011221443154.png" alt="在这里插入图片描述"></p><p>还要注意一点的是，“单CPU两道批处理系统”的意思是，一次最多允许两道作业存在，并且一次只能处理一道作业。</p><p>① 首先8:00的时候作业J1到达（注意这里的“到达”不是指到达就绪队列，而是表明“J1这个任务来了，我们即将处理它”，很浅层的意思，不要多想），这个时候只有J1，那么毫无疑问直接调入内存，由于是两道批处理，我们假设这里的内存叫内存1，进入就绪队列，然后开始执行，也就是分配CPU；<br>此时的就绪队列如下（空），因为J1刚进入就绪队列就被分配了CPU，转为运行态：</p><p><img src="/images/20201011221520487.png" alt="在这里插入图片描述"></p><p>② 8:20的时候，J2到达，此时内存还有个位置空闲，显然将J2调入内存，我们叫内存2，进入就绪队列，那调入内存后要不要分配CPU呢？这就得看我们的进程调度算法了，使用抢占式优先级调度，J2的优先数要小于J1，因此优先级大，此时J1被迫暂停执行，重新回归就绪队列，而J2从就绪队列出去，分配CPU，进入运行态，而此时J1还剩下20min时间；<br>此时的就绪队列如下：</p><p><img src="/images/20201011221529345.png" alt="在这里插入图片描述"></p><p>③ 8:30的时候，J3到达，但是内存此时已经没有位置了，即一道给了J1，另一道给了J2，因此J3只能在外存的<strong>后备队列</strong>里等着，进不了就绪队列；<br>此时的就绪队列没变：</p><p><img src="/images/20201011221539232.png" alt="在这里插入图片描述"></p><p>④ 8:50，J2执行完毕，这样“<strong>内存2</strong>”就空出来了，此时J4正好也到达了，那到底是将J3还是J4调入内存就绪队列中呢？看我们的作业调度算法，短作业优先，J4需要的的时间要比J3短，因此J4先调入内存2；<br>此时的就绪队列如下：</p><p><img src="/images/20201011221548379.png" alt="在这里插入图片描述"></p><p>⑤ 现在就绪队列里有J1、J4，谁先执行呢？比较优先级的大小！J1的优先级大，因此J1先执行。注意：此时两道内存仍然还有作业，因此J3还是要在外存中等着；<br>此时的就绪队列如下：</p><p><img src="/images/20201011221606599.png" alt="在这里插入图片描述"></p><p>⑥ 9:10的时候，J1执行完毕了，内存1就空出来了，这个时候J3就可以调入内存1了，即进入就绪队列；<br>此时的就绪队列如下：</p><p><img src="/images/20201011221617138.png" alt="在这里插入图片描述"></p><p>⑦ 同理，J3优先级高，先占用CPU开始执行，到10:00执行完毕，此时J4分配CPU开始执行20min，到10:20执行完毕。至此，全部作业都完成了。<br>此时的就绪队列自然也清空了：</p><p><img src="/images/20201011221625817.png" alt="在这里插入图片描述"></p><p>好了，以上就是整个过程的全部详解，只看文字略显枯燥，我们附上整个过程的Gantt图：</p><p><img src="/images/20201011224028492.png" alt="在这里插入图片描述"></p><p>答案：</p><p>周转时间 = 完成时间 - 到达时间 = 等待时间 + 运行时间<br>J1的周转时间 = J1的等待时间 + J1的运行时间 = 30 + 40 = 70min；<br>J2的周转时间 = 0 + 30 = 30min；<br>J3的周转时间 = 40 + 50 = 90min；<br>J4的周转时间 = 70 + 20 = 90min.</p><p>最终的平均周转时间 = (70 + 30 + 90 + 90) / 4 = 70min.</p><p>作业和作业步<br>作业 (job)<br>作业是把命令、程序和数据按照预先确定的次序结合在一起，并提交给系统的一个组织单位。<br>或者：作业是用户交给系统的具有独立功能的任务。<br>作业：程序和数据 + 作业说明书<br>在批处理系统中，是以作业为基本单位从外存调入内存<br>的。<br>作业步 (job step)<br>一个典型的作业可分成三个作业步：<br>1.“编译”作业步；<br>2.“连结装配”作业步；<br>3.“运行”作业步。</p><p>作业控制块 JCB<br>在多道批处理系统中通常有上百个作业，为了管理和调度作业，系统为每个作业设置了一个作业控制块（JCB），它记录该作业的有关信息。不同系统的 JCB的组成内容有所区别。</p><p>JCB 是作业在系统中存在的唯一标志。作业进入系统时由系统为每个作业建立一个 JCB；当作业退出系统时，则它的 JCB 也一起被撤消。</p><p>作业运行的三个阶段和三种状态<br>收容阶段<br>当用户完成作业的提交，作业存在于外存中，系统建立JCB。在它还未被调度去执行前，该作业处于后备状态。</p><p>运行阶段<br>作业被调度进入内存，并以进程的形式存在，其状态是执行状态。处于执行状态的作业可以有多个。</p><p>处于执行状态的作业并不意味着一定在 CPU 上运行，是否运行依赖于进程控制。</p><p>完成阶段<br>当作业已经完成其指定的功能，便进入停止状态，系统回收已分配资源。</p><p>作业调度的主要任务<br>接纳多少作业<br>即多道程序的“道”。<br>太多则可能会影响系统的服务质量（如周转时间太长），太少又将导致系统资源利用率和吞吐量的下降。<br>根据系统的规模和运行速度来确定，同时要求 I/O 型进程与 CPU 型进程中和调度。<br>接纳哪些作业<br>取决于采用何种调度算法（先来先服务、短作业优先等）</p><h1 id="作业调度算法"><a href="#作业调度算法" class="headerlink" title="作业调度算法"></a>作业调度算法</h1><h2 id="1-先来先服务（FCFS-First-Come-First-Serve）"><a href="#1-先来先服务（FCFS-First-Come-First-Serve）" class="headerlink" title="1.先来先服务（FCFS, First Come First Serve）"></a>1.先来先服务（FCFS, First Come First Serve）</h2><p><strong>先来先服务</strong>是最简单的调度算法，按先后顺序进行调度。一般采用非剥夺的调度方式。</p><p>定义：<br>　　按照作业提交或进程变为就绪状态的先后次序，分派CPU；</p><p>　　当前作业或进程占用CPU，直到执行完或阻塞，才出让CPU（非抢占方式）。</p><p>　　在作业或进程唤醒后（如I/O完成），并不立即恢复执行，通常等到当前作业或进程出让CPU。</p><p>适用场景：<br>　　比较有利于长作业，而不利于短作业。因为长作业会长时间占据处理机。</p><p>　　有利于CPU繁忙的作业，而不利于I/O繁忙的作业。</p><p>FCFS 调度算法的平均作业周转时间与作业提交的顺序有关。</p><p>FCFS 调度算法的特点：</p><p>简单，但效率不高。<br>有利于 CPU 繁忙型作业。<br>不利于 I/O 繁忙型作业。<br>现在操作系统中，已很少用该算法作为主要调度策略，尤其是在分时系- 统和实时系统中。但它常被结合在其它调度策略中使用。</p><h2 id="2．短作业优先法（SJF-Shortest-Job-First）"><a href="#2．短作业优先法（SJF-Shortest-Job-First）" class="headerlink" title="2．短作业优先法（SJF, Shortest Job First）"></a>2．短作业优先法（SJF, Shortest Job First）</h2><p>短作业优先又称为“短进程优先”SPN(Shortest Process Next)；这是对FCFS算法的改进，其目标是减少平均周转时间。</p><h3 id="定义："><a href="#定义：" class="headerlink" title="定义："></a>定义：</h3><p>　　对预计执行时间短的作业（进程）优先分派处理机。通常后来的短作业不抢先正在执行的作业。</p><p>SJF的特点：<br>　　(1) 优点：</p><p>　　比FCFS改善平均周转时间和平均带权周转时间，缩短作业的等待时间；</p><p>　　提高系统的吞吐量；</p><p>　　(2) 缺点：</p><p>　　对长作业非常不利，可能长时间得不到执行；</p><p>　　未能依据作业的紧迫程度来划分执行的优先级；</p><p>　　难以准确估计作业（进程）的执行时间，从而影响调度性能。</p><p>SJF的变型：<br>　　“最短剩余时间优先”SRT(Shortest Remaining Time)（允许比当前进程剩余时间更短的进程来抢占）</p><p>　　“最高响应比优先”HRRN(Highest Response Ratio Next)（响应比R = (等待时间 + 要求执行时间) / 要求执行时间，是FCFS和SJF的折衷）</p><p>短作业优先调度算法的优缺点</p><p>优点</p><ul><li>能有效降低作业的平均等待时间。</li><li>能有效缩短进程的平均周转时间。</li><li>提高了吞吐量。</li></ul><p>缺点</p><ul><li>对长作业不利。</li><li>没有考虑作业的紧迫程度。</li><li>作业执行时间、剩余时间仅为估计。</li></ul><p>SJF 算法虽然是优化的，但在 CPU 调度中很难实现。</p><h2 id="3-优先级调度算法（Priority-Scheduling）"><a href="#3-优先级调度算法（Priority-Scheduling）" class="headerlink" title="3.优先级调度算法（Priority Scheduling）"></a>3.优先级调度算法（Priority Scheduling）</h2><p>对于 FCFS，等待时间是优先级。对于 SJF，作业的长短是优先级。</p><p>优先级调度算法(Priority-Scheduling Algorithm, PSA)以作业的紧迫程度为优先级。</p><p>系统选择优先级最高的几个作业装入内存。</p><p>优先级调度算法也用于进程调度，系统在可运行的进程中选择优先级最高者使其投入运行。</p><p>优先级的类型</p><p>静态优先级<br>动态优先级</p><p>优先级算法是多级队列算法的改进，平衡各进程对响应时间的要求。适用于作业调度和进程调度，可分成抢先式和非抢先式。</p><p><strong>静态优先级</strong>：<br>优先权在创建进程时确定，且在进程的整个运行期间保持不变。一般用整数表示，小表示优先级高。</p><p>确定原则：</p><ul><li>进程类型（系统进程 &gt; 用户进程）</li><li>进程对资源的需求（要求少的有较高的优先权）</li><li>用户要求（紧急程度和付费情况）</li></ul><p>优点：简单，开销小。<br>缺点：公平性差（对低优先权进程）　　</p><p>作业调度中的静态优先级大多按以下原则确定：</p><p>　　由用户自己根据作业的紧急程度输入一个适当的优先级。</p><p>　　由系统或操作员根据作业类型指定优先级。</p><p>　　系统根据作业要求资源情况确定优先级。</p><p>　　进程的静态优先级的确定原则：</p><p>　　按进程的类型给予不同的优先级。</p><p>　　将作业的情态优先级作为它所属进程的优先级。</p><p><strong>动态优先级</strong>：<br>动态优先级在进程的存在过程中不断发生变化。</p><p>动态优先级的变化取决于：</p><ul><li>进程的等待时间</li><li>进程的运行时间</li><li>进程使用资源的情况</li></ul><p>动态优先权确定方法的资源利用率高，公平性好，但开销较大，实现较为复杂。</p><p>高响应比优先算法 (HRRN)采用动态优先权。</p><p>进程的动态优先级一般根据以下原则确定：</p><p>　　根据进程占用有CPU时间的长短来决定。</p><p>　　根据就绪进程等待CPU的时间长短来决定。</p><h2 id="4-最高响应比优先法-HRN，Highest-Response-ratio-Next"><a href="#4-最高响应比优先法-HRN，Highest-Response-ratio-Next" class="headerlink" title="4.最高响应比优先法(HRN，Highest Response_ratio Next)"></a>4.最高响应比优先法(HRN，Highest Response_ratio Next)</h2><p>FCFS 只考虑了作业的等待时间，忽略了运行时间。SJF 只考虑了作业的运行时间，忽略了等待时间。</p><p>高响应比优先调度算法(Highest Response Ratio Next,HRRN) 既考虑了作业的等待时间，也考虑了作业的运行时间，是一种动态优先级调度算法。</p><p>最高响应比优先法是对FCFS方式和SJF方式的一种综合平衡。FCFS方式只考虑每个作业的等待时间而未考虑执行时间的长短，而SJF方式只考虑执行时间而未考虑等待时间的长短。因此，这两种调度算法在某些极端情况下会带来某些不便。HRN调度策略同时考虑每个作业的等待时间长短和估计需要的执行时间长短，从中选出响应比最高的作业投入执行。</p><p>响应比R定义如下： R =(W+T)/T = 1+W/T</p><p>其中T为该作业估计需要的执行时间，W为作业在后备状态队列中的等待时间。每当要进行作业调度时，系统计算每个作业的响应比，选择其中R最大者投入执行。这样，即使是长作业，随着它等待时间的增加，W / T也就随着增加，也就有机会获得调度执行。这种算法是介于FCFS和SJF之间的一种折中算法。由于长作业也有机会投入运行，在同一时间内处理的作业数显然要少于SJF法，从而采用HRN方式时其吞吐量将小于采用SJF 法时的吞吐量。另外，由于每次调度前要计算响应比，系统开销也要相应增加。</p><p><img src="/images/20161128110206891.png" alt="公式"></p><p>周转时间：从提交到完成的时间间隔。</p><p>响应时间：在交互式系统中，从提交请求到产生首次响应的时间，而不是到产生输出结果所需的时间。</p><p>如等待时间相同，则要求服务时间越短其优先权越高→SJF。<br>如要求服务时间相同，优先权决定于等待时间→FCFS。<br>对长作业，若等待时间足够长，优先权也高，也能获得CPU。</p><h1 id="一、作业的基本知识"><a href="#一、作业的基本知识" class="headerlink" title="一、作业的基本知识"></a>一、作业的基本知识</h1><h2 id="1-作业和作业步"><a href="#1-作业和作业步" class="headerlink" title="1.作业和作业步"></a>1.作业和作业步</h2><p>（1）作业：作业是一个比程序更为广泛的概念，包含通常的程序和数据，还有一份作业说明书。系统根据该说明书来对程序的运行进行控制。 （2）作业步：在作业运行期间，每个作业都必须经过若干个相对独立，又相互关联的顺序加工步骤才得到结果，其中的每一个加工步骤称为一个作业步。</p><h2 id="2-作业运行的三个阶段"><a href="#2-作业运行的三个阶段" class="headerlink" title="2.作业运行的三个阶段"></a>2.作业运行的三个阶段</h2><p>（1）收容阶段。操作员把用户提交的作业通过某种输入方式输入到硬盘上，再为改作业建立JCB(作业控制块)，并把作业放到后备队列中。此时作业的状态称为后备状态。 </p><p>（2）运行阶段。当作业被作业调度选中后，便为它分配必要的资源和建立进程，并将它放入就绪队列。一个作业从第一次进入就绪队列开始，直到它运行结束前，在此期间都处于运行状态。 </p><p>（3）完成阶段。当作业运行完成，或发生异常情况而提前结束时，作业便进入完成阶段，相应的作业状态为“完成状态”。</p><h1 id="二、先来先服务（FCFS）调度算法"><a href="#二、先来先服务（FCFS）调度算法" class="headerlink" title="二、先来先服务（FCFS）调度算法"></a>二、先来先服务（FCFS）调度算法</h1><h2 id="1-算法思想"><a href="#1-算法思想" class="headerlink" title="1.算法思想"></a>1.算法思想</h2><p>顾名思义，系统按照作业的先后到达顺序来进行调度。即优先考虑在系统中等待时间最长的作业，而不考虑该作业所需要执行的时间。</p><h2 id="2-算法评价"><a href="#2-算法评价" class="headerlink" title="2.算法评价"></a>2.算法评价</h2><p>可以明显感觉到缺点，就是如果有一个非常短的作业，如果这个短作业之前如果有一个非常长的作业的话，那么这个短作业不得不要等很长的时间。 在该算法上可以进行和其他算法进行结合，比如优先级，可以设置好几个队列，每个队列之间的优先级不同，按照优先级选择队列，每个队列里的作业按照先来先服务的调度算法选择作业。</p><h1 id="三、短作业优先（SJF）调度算法"><a href="#三、短作业优先（SJF）调度算法" class="headerlink" title="三、短作业优先（SJF）调度算法"></a>三、短作业优先（SJF）调度算法</h1><h2 id="1-算法思想-1"><a href="#1-算法思想-1" class="headerlink" title="1.算法思想"></a>1.算法思想</h2><p>在先来先服务的调度算法中，我们提到，一个短作业为了等待前面的长作业完成，不得不要等待很长的时间，对于短作业来说，肯定显得不太公平。 短作业优先调度算法，顾名思义，以作业的长短来当作一个作业的优先级，作业越短（作业的长短是以作业所要求的运行时间来衡量的），优先级越高，就尽量要被越早的执行完成。</p><h2 id="2-算法评价-1"><a href="#2-算法评价-1" class="headerlink" title="2.算法评价"></a>2.算法评价</h2><p>短作业算法弥补了先来先服务算法的缺点——短作业等待时间可能过长。但是，仍有明显的缺点： </p><p>（1）必须预知作业大概的运行时间。一般都要预估偏长，因为如果预估运行时间短的话，可能作业还没有执行完就被终止了。 </p><p>（2）对长作业来说，可能会产生饥饿现象。 </p><p>（3）采用SJF调度算法时，无法实现人机交互。 </p><p>（4）该调度算法没有考虑作业的紧迫度，所以紧急作业可能得不到及时处理。</p><h1 id="四、优先级调度算法（PSA）"><a href="#四、优先级调度算法（PSA）" class="headerlink" title="四、优先级调度算法（PSA）"></a>四、优先级调度算法（PSA）</h1><p>对于先来先服务算法，作业的等待时间就是这个作业的优先级，等待时间越长，优先级越高。对于短作业优先调度算法来说，作业的长短就是作业的优先级，作业越短，优先级越高。</p><h2 id="1-算法思想-2"><a href="#1-算法思想-2" class="headerlink" title="1.算法思想"></a>1.算法思想</h2><p>由外部赋予作业优先级，至于根据什么来判断一个作业的优先级的高低，看情况了，比如，如果想要在短作业优先调度算法的基础上保证紧迫作业能够被优先完成的话，那么可以在作业长短的基础上再加上紧迫这一个优先级，可以将紧迫作业的优先级设置为最高优先级，那么紧迫作业就会被优先运行。 优先级调度算法是一个比较笼统的概念，至于根据什么判断作业的优先级，可以看情况。比如接下来讨论的高响应比就属于优先级调度算法，而高响应比优先调度算法中是同时根据作业的等待时间和作业的运行时间来判定一个作业的优先级的。</p><h2 id="2-算法评价-2"><a href="#2-算法评价-2" class="headerlink" title="2.算法评价"></a>2.算法评价</h2><p>该调度算法比较常见，而且比较灵活，可以选择多个因素来作为优先级的评判标准，可以有多个优先级，各个优先级之间又有高低之分，比如上面的假设中，作业的长短和作业的紧迫程度都可以是作业的优先级影响因素，而紧迫作业的优先级要比短作业的优先级高。</p><h1 id="五、高响应比优先调度算法（HRRN）"><a href="#五、高响应比优先调度算法（HRRN）" class="headerlink" title="五、高响应比优先调度算法（HRRN）"></a>五、高响应比优先调度算法（HRRN）</h1><p>在前面说的算法中，先来先服务调度算法仅仅以作业的等待时间作为优先级因素，而忽视了作业的运行时间。短作业优先算法仅仅以作业的运行时间作为优先级因素，而忽视了作业的等待时间。高响应比优先调度算法则是既考虑了作业的等待时间，又考虑了作业的运行时间。因此即照顾了短作业，而又不会造成长作业的饥饿现象。 在这里有一个动态优先级的概念，即优先级是会动态变化的。由于高响应比优先调度算法的优先级是根据作业的长短和作业的等待时间来断定的，所以一个作业的优先级肯定会根据时间而变换。该优先级的变化规律为： </p><p>优先权 = （等待时间+要求服务时间）/ 要求服务时间 </p><p>由于等待时间与要求服务时间的和是系统对该作业的响应时间，所以： </p><p>优先权 = 响应时间 / 要求服务时间 </p><p>由上式可以看出： </p><p>（1）如果作业的等待时间相同，那么作业要求服务时间越短，那么该作业的优先级就越高，类似于短作业优先调度算法，有利于短作业。 </p><p>（2）当要求的服务时间相同时，作业的等待时间越长，那么作业的优先级越高，此时类似于先来先服务调度算法。 </p><p>（3）对于长作业来说，随着时间的增长，长作业的优先级会变高，当等待时间足够长时，也会获得处理及，因此避免了短作业优先调度算法的长作业可能出现饥饿现象的缺点。</p>]]></content>
      
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>deadlock</title>
      <link href="/2023/06/27/deadlock/"/>
      <url>/2023/06/27/deadlock/</url>
      
        <content type="html"><![CDATA[<h1 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h1><h2 id="什么是死锁？"><a href="#什么是死锁？" class="headerlink" title="什么是死锁？"></a>什么是死锁？</h2><p>所谓死锁，是指多个进程在运行过程中因争夺资源而造成的一种僵局，当进程处于这种僵持状态时，若无外力作用，它们都将无法再向前推进。 因此我们举个例子来描述，如果此时有一个线程A，按照先锁a再获得锁b的的顺序获得锁，而在此同时又有另外一个线程B，按照先锁b再锁a的顺序获得锁。如下图所示：</p><p><img src="https://img-blog.csdn.net/20180922173936964?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hkMTIzNzA=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70"></p><h2 id="产生死锁的原因？"><a href="#产生死锁的原因？" class="headerlink" title="产生死锁的原因？"></a>产生死锁的原因？</h2><p>可归结为如下两点：</p><p>a. 竞争资源</p><p>系统中的资源可以分为两类：<br>可剥夺资源，是指某进程在获得这类资源后，该资源可以再被其他进程或系统剥夺，CPU和主存均属于可剥夺性资源；<br>另一类资源是不可剥夺资源，当系统把这类资源分配给某进程后，再不能强行收回，只能在进程用完后自行释放，如磁带机、打印机等。<br>产生死锁中的竞争资源之一指的是竞争不可剥夺资源（例如：系统中只有一台打印机，可供进程P1使用，假定P1已占用了打印机，若P2继续要求打印机打印将阻塞）<br>产生死锁中的竞争资源另外一种资源指的是竞争临时资源（临时资源包括硬件中断、信号、消息、缓冲区内的消息等），通常消息通信顺序进行不当，则会产生死锁<br>b. 进程间推进顺序非法</p><p>若P1保持了资源R1,P2保持了资源R2，系统处于不安全状态，因为这两个进程再向前推进，便可能发生死锁<br>例如，当P1运行到P1：Request（R2）时，将因R2已被P2占用而阻塞；当P2运行到P2：Request（R1）时，也将因R1已被P1占用而阻塞，于是发生进程死锁</p><h2 id="死锁产生的4个必要条件？"><a href="#死锁产生的4个必要条件？" class="headerlink" title="死锁产生的4个必要条件？"></a>死锁产生的4个必要条件？</h2><p>产生死锁的必要条件：</p><ol><li><p>互斥条件：进程要求对所分配的资源进行排它性控制，即在一段时间内某资源仅为一进程所占用。</p></li><li><p>请求和保持条件：当进程因请求资源而阻塞时，对已获得的资源保持不放。</p></li><li><p>不剥夺条件：进程已获得的资源在未使用完之前，不能剥夺，只能在使用完时由自己释放。</p></li><li><p>环路等待条件：在发生死锁时，必然存在一个进程–资源的环形链。</p></li></ol><h2 id="解决死锁的基本方法"><a href="#解决死锁的基本方法" class="headerlink" title="解决死锁的基本方法"></a>解决死锁的基本方法</h2><h3 id="预防死锁："><a href="#预防死锁：" class="headerlink" title="预防死锁："></a>预防死锁：</h3><ul><li><p>资源一次性分配：一次性分配所有资源，这样就不会再有请求了：（破坏请求条件）</p></li><li><p>只要有一个资源得不到分配，也不给这个进程分配其他的资源：（破坏请保持条件）</p></li><li><p>可剥夺资源：即当某进程获得了部分资源，但得不到其它资源，则释放已占有的资源（破坏不可剥夺条件）</p></li><li><p>资源有序分配法：系统给每类资源赋予一个编号，每一个进程按编号递增的顺序请求资源，释放则相反（破坏环路等待条件）</p></li></ul><p>1、以确定的顺序获得锁</p><p>如果必须获取多个锁，那么在设计的时候需要充分考虑不同线程之前获得锁的顺序。按照上面的例子，两个线程获得锁的时序图如下：</p><p><img src="https://img-blog.csdn.net/20180922174807514?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hkMTIzNzA=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70"></p><p>&nbsp;如果此时把获得锁的时序改成：</p><p><img src="https://img-blog.csdn.net/20180922174829303?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hkMTIzNzA=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70"></p><p>那么死锁就永远不会发生。 针对两个特定的锁，开发者可以尝试按照锁对象的hashCode值大小的顺序，分别获得两个锁，这样锁总是会以特定的顺序获得锁，那么死锁也不会发生。问题变得更加复杂一些，如果此时有多个线程，都在竞争不同的锁，简单按照锁对象的hashCode进行排序（单纯按照hashCode顺序排序会出现“环路等待”），可能就无法满足要求了，这个时候开发者可以使用银行家算法，所有的锁都按照特定的顺序获取，同样可以防止死锁的发生，该算法在这里就不再赘述了，有兴趣的可以自行了解一下。</p><p>2、超时放弃</p><p>当使用synchronized关键词提供的内置锁时，只要线程没有获得锁，那么就会永远等待下去，然而Lock接口提供了boolean tryLock(long time, TimeUnit unit) throws InterruptedException方法，该方法可以按照固定时长等待锁，因此线程可以在获取锁超时以后，主动释放之前已经获得的所有的锁。通过这种方式，也可以很有效地避免死锁。 还是按照之前的例子，时序图如下：</p><p><img src="https://img-blog.csdn.net/20180922174924551?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hkMTIzNzA=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70"></p><h3 id="避免死锁"><a href="#避免死锁" class="headerlink" title="避免死锁:"></a>避免死锁:</h3><p>预防死锁的几种策略，会严重地损害系统性能。因此在避免死锁时，要施加较弱的限制，从而获得 较满意的系统性能。由于在避免死锁的策略中，允许进程动态地申请资源。因而，系统在进行资源分配之前预先计算资源分配的安全性。若此次分配不会导致系统进入不安全的状态，则将资源分配给进程；否则，进程等待。其中最具有代表性的避免死锁算法是银行家算法。<br>银行家算法：首先需要定义状态和安全状态的概念。系统的状态是当前给进程分配的资源情况。因此，状态包含两个向量Resource（系统中每种资源的总量）和Available（未分配给进程的每种资源的总量）及两个矩阵Claim（表示进程对资源的需求）和Allocation（表示当前分配给进程的资源）。安全状态是指至少有一个资源分配序列不会导致死锁。当进程请求一组资源时，假设同意该请求，从而改变了系统的状态，然后确定其结果是否还处于安全状态。如果是，同意这个请求；如果不是，阻塞该进程知道同意该请求后系统状态仍然是安全的。</p><h3 id="检测死锁"><a href="#检测死锁" class="headerlink" title="检测死锁"></a>检测死锁</h3><p>先检测：这种方法并不须事先采取任何限制性措施，也不必检查系统是否已经进入不安全区，此方法允许系统在运行过程中发生死锁。但可通过系统所设置的检测机构，及时地检测出死锁的发生，并精确地确定与死锁有关的进程和资源。检测方法包括<strong>定时检测</strong>、<strong>效率低时检测</strong>、<strong>进程等待时检测</strong>等。</p><p>然后解除死锁：采取适当措施，从系统中将已发生的死锁清除掉。<br>这是与检测死锁相配套的一种措施。当检测到系统中已发生死锁时，须将进程从死锁状态中解脱出来。常用的实施方法是撤销或挂起一些进程，以便回收一些资源，再将这些资源分配给已处于阻塞状态的进程，使之转为就绪状态，以继续运行。死锁的检测和解除措施，有可能使系统获得较好的资源利用率和吞吐量，但在实现上难度也最大。</p><ol><li>首先为每个进程和每个资源指定一个唯一的号码；</li><li>然后建立资源分配表和进程等待表。</li></ol><h3 id="解除死锁"><a href="#解除死锁" class="headerlink" title="解除死锁:"></a>解除死锁:</h3><p>如果我们在死锁检查时发现了死锁情况，那么就要努力消除死锁，使系统从死锁状态中恢复过来。消除死锁的几种方式：</p><p>最简单、最常用的方法就是进行系统的重新启动，不过这种方法代价很大，它意味着在这之前所有的进程已经完成的计算工作都将付之东流，包括参与死锁的那些进程，以及未参与死锁的进程；</p><p>撤消进程，剥夺资源。终止参与死锁的进程，收回它们占有的资源，从而解除死锁。这时又分两种情况：一次性撤消参与死锁的全部进程，剥夺全部资源；或者逐步撤消参与死锁的进程，逐步收回死锁进程占有的资源。一般来说，选择逐步撤消的进程时要按照一定的原则进行，目的是撤消那些代价最小的进程，比如按进程的优先级确定进程的代价；考虑进程运行时的代价和与此进程相关的外部作业的代价等因素；</p><p>进程回退策略，即让参与死锁的进程回退到没有发生死锁前某一点处，并由此点处继续执行，以求再次执行时不再发生死锁。虽然这是个较理想的办法，但是操作起来系统开销极大，要有堆栈这样的机构记录进程的每一步变化，以便今后的回退，有时这是无法做到的。</p><p>当发现有进程死锁后，便应立即把它从死锁状态中解脱出来，常采用的方法有：</p><ul><li><p>剥夺资源：从其它进程剥夺足够数量的资源给死锁进程，以解除死锁状态；</p></li><li><p>撤消进程：可以直接撤消死锁进程或撤消代价最小的进程，直至有足够的资源可用，死锁状态.消除为止；所谓代价是指优先级、运行代价、进程的重要性和价值等。</p></li></ul><h3 id="死锁检测"><a href="#死锁检测" class="headerlink" title="死锁检测"></a>死锁检测</h3><p>1、Jstack命令</p><p>jstack是java虚拟机自带的一种堆栈跟踪工具。jstack用于打印出给定的java进程ID或core file或远程调试服务的Java堆栈信息。 Jstack工具可以用于生成java虚拟机当前时刻的线程快照。线程快照是当前java虚拟机内每一条线程正在执行的方法堆栈的集合，生成线程快照的主要目的是定位线程出现长时间停顿的原因，如线程间死锁、死循环、请求外部资源导致的长时间等待等。 线程出现停顿的时候通过jstack来查看各个线程的调用堆栈，就可以知道没有响应的线程到底在后台做什么事情，或者等待什么资源。</p><p>2、JConsole工具</p><p>Jconsole是JDK自带的监控工具，在JDK/bin目录下可以找到。它用于连接正在运行的本地或者远程的JVM，对运行在Java应用程序的资源消耗和性能进行监控，并画出大量的图表，提供强大的可视化界面。而且本身占用的服务器内存很小，甚至可以说几乎不消耗。</p>]]></content>
      
      
      
        <tags>
            
            <tag> lock </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SortAlgorithm</title>
      <link href="/2023/06/27/sortalgorithm/"/>
      <url>/2023/06/27/sortalgorithm/</url>
      
        <content type="html"><![CDATA[<h1 id="十大排序算法"><a href="#十大排序算法" class="headerlink" title="十大排序算法"></a>十大排序算法</h1><p>排序算法可以分为内部排序和外部排序，内部排序是数据记录在内存中进行排序，而外部排序是因排序的数据很大，一次不能容纳全部的排序记录，在排序过程中需要访问外存。</p><p>常见的内部排序算法有十种：冒泡排序、选择排序、插入排序、希尔排序、堆排序、快速排序、归并排序、基数排序、计数排序、桶排序。</p><p>前面三种是简单排序，之后四种是在前面基础上进行优化，最后三种不是基于比较的排序，因此时间复杂度突破了nlogn的限制，但是算法本身对数据有一定的要求。</p><p><img src="/images/sort.png" alt="sort"></p><p><img src="/images/%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F%E6%AF%94%E8%BE%83.png" alt="十大排序比较"></p><p>平方阶 (O(n2)) 排序 各类简单排序：直接插入、直接选择和冒泡排序。</p><p>线性对数阶 (O(nlog2n)) 排序 快速排序、堆排序和归并排序；</p><p>O(n1+§)) 排序，§ 是介于 0 和 1 之间的常数。 希尔排序</p><p>线性阶 (O(n)) 排序 基数排序，此外还有桶、箱排序。</p><p>关于稳定性</p><p>稳定的排序算法：冒泡排序、插入排序、归并排序和基数排序。</p><p>不是稳定的排序算法：选择排序、快速排序、希尔排序、堆排序。</p><p>名词解释：</p><p>n：数据规模<br>k：”桶”的个数<br>In-place：占用常数内存，不占用额外内存<br>Out-place：占用额外内存<br>稳定性：排序后 2 个相等键值的顺序和排序之前它们的顺序相同</p><h2 id="1、冒泡排序"><a href="#1、冒泡排序" class="headerlink" title="1、冒泡排序"></a>1、冒泡排序</h2><p>主要思想：依次对两个数比较大小，较大的数冒起来，较小的数压下来。它遍历所有的数据，每次对相邻元素进行两两比较，如果顺序和预先规定的顺序不一致，则进行位置交换；这样一次遍历会将最大或最小的数据上浮到顶端，之后再重复同样的操作，直到所有的数据有序。</p><p>形象理解：一队新兵N个人整齐站成一列，教官想让他们按照身高排好队，看起来更协调，于是从前走到后走一趟，每次遇到相邻的两个人身高不协调时，就让两人互换位置。当走完一趟时，个子最高的人就被排到了最后。教官回到前排后发现队伍仍然不协调，于是又按照原样走了一趟。这样循环走了N-1趟之后，教官终于满意了。（注意：每次走一趟时，之前排到后面的高个子就不参与这次排序了；有时候可能还没走完N-1趟，教官就发现队伍已经协调了，于是排序结束。）</p><p>特点：简单易懂，排序稳定，但速度慢。</p><h3 id="1-算法步骤"><a href="#1-算法步骤" class="headerlink" title="1. 算法步骤"></a>1. 算法步骤</h3><p>比较相邻的元素。如果第一个比第二个大，就交换他们两个。</p><p>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。</p><p>针对所有的元素重复以上的步骤，除了最后一个。</p><p>持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。</p><h3 id="2-动图演示"><a href="#2-动图演示" class="headerlink" title="2. 动图演示"></a>2. 动图演示</h3><p><img src="https://www.runoob.com/wp-content/uploads/2019/03/bubbleSort.gif" alt="img"></p><h3 id="3-什么时候最快"><a href="#3-什么时候最快" class="headerlink" title="3. 什么时候最快"></a>3. 什么时候最快</h3><p>当输入的数据已经是正序时（都已经是正序了，我还要你冒泡排序有何用啊）。</p><h3 id="4-什么时候最慢"><a href="#4-什么时候最慢" class="headerlink" title="4. 什么时候最慢"></a>4. 什么时候最慢</h3><p>当输入的数据是反序时（写一个 for 循环反序输出数据不就行了，干嘛要用你冒泡排序呢，我是闲的吗）。</p><h3 id="5-C-语言实现"><a href="#5-C-语言实现" class="headerlink" title="5. C++ 语言实现"></a>5. C++ 语言实现</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void bubble_sort(T arr[], int len) {    int i, j;    for (i = 0; i &lt; len - 1; i++)        for (j = 0; j &lt; len - 1 - i; j++)            if (arr[j] &gt; arr[j + 1])                swap(arr[j], arr[j + 1]);}//冒泡优化void BubbleSort1(SquList* L){    int i, j;    // falg标记，flag为false,说明已经做过比较，没有数据交换，已经有序，不需要再继续后面的循环    bool flag = true;    for (i = 1; i &lt; L-&gt;length &amp;&amp; flag; i++)    {        flag = false;        for (j = L-&gt;length - 1; j &gt;= i; j--)        {            if (L-&gt;r[j] &gt; L-&gt;r[j + 1])            {                swap(L, j, j + 1);                flag = true;            }        }    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="2、选择排序"><a href="#2、选择排序" class="headerlink" title="2、选择排序"></a>2、选择排序</h2><p>主要思想：针对冒泡排序，有一个地方可以优化，即在跑一趟的过程中，没必要两两交换，可以先记下最小值，跑完一趟后直接将最小值换到前面。</p><p>先在数据中找出最大或最小的元素，放到序列的起始；然后再从余下的数据中继续寻找最大或最小的元素，依次放到排序序列中，直到所有数据样本排序完成。</p><p>特点：比冒泡更快一些，但代价是跳跃性交换，排序不稳定。</p><h3 id="1-算法步骤-1"><a href="#1-算法步骤-1" class="headerlink" title="1. 算法步骤"></a>1. 算法步骤</h3><p>首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置。</p><p>再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。</p><p>重复第二步，直到所有元素均排序完毕。</p><h3 id="2-动图演示-1"><a href="#2-动图演示-1" class="headerlink" title="2. 动图演示"></a>2. 动图演示</h3><p><img src="https://www.runoob.com/wp-content/uploads/2019/03/selectionSort.gif" alt="img"></p><h3 id="3-C"><a href="#3-C" class="headerlink" title="3.C++"></a>3.C++</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">template&lt;typename T&gt; //整數或浮點數皆可使用，若要使用物件（class）時必須設定大於（&gt;）的運算子功能void selection_sort(std::vector&lt;T&gt;&amp; arr) {    for (int i = 0; i &lt; arr.size() - 1; i++) {        int min = i;        for (int j = i + 1; j &lt; arr.size(); j++)            if (arr[j] &lt; arr[min])                min = j;        std::swap(arr[i], arr[min]);    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="3、插入排序"><a href="#3、插入排序" class="headerlink" title="3、插入排序"></a>3、插入排序</h2><p>它通过构建有序序列，对于未排序的数据序列，在已排序序列中从后向前扫描，找到相应的位置并插入，类似打扑克牌时的码牌。插入排序有一种优化的算法，可以进行拆半插入。</p><p>特点：当数据规模较小或者数据基本有序时，效率较高。</p><h3 id="1-算法步骤-2"><a href="#1-算法步骤-2" class="headerlink" title="1. 算法步骤"></a>1. 算法步骤</h3><p>将第一待排序序列第一个元素看做一个有序序列，把第二个元素到最后一个元素当成是未排序序列。</p><p>从头到尾依次扫描未排序序列，将扫描到的每个元素插入有序序列的适当位置。（如果待插入的元素与有序序列中的某个元素相等，则将待插入元素插入到相等元素的后面。）</p><h3 id="2-动图演示-2"><a href="#2-动图演示-2" class="headerlink" title="2. 动图演示"></a>2. 动图演示</h3><p><img src="https://www.runoob.com/wp-content/uploads/2019/03/insertionSort.gif" alt="img"></p><h3 id="3-C-1"><a href="#3-C-1" class="headerlink" title="3.C++"></a>3.C++</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void insertion_sort(int arr[],int len){    for(int i=1;i&lt;len;i++){        int key=arr[i];        int j=i-1;        while((j&gt;=0) &amp;&amp; (key&lt;arr[j])){            arr[j+1]=arr[j];            j--;        }        arr[j+1]=key;    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="4、希尔排序"><a href="#4、希尔排序" class="headerlink" title="4、希尔排序"></a>4、希尔排序</h2><p>希尔排序，也称递减增量排序算法，是插入排序的一种更高效的改进版本。但希尔排序是非稳定排序算法。</p><p>希尔排序是基于插入排序的以下两点性质而提出改进方法的：</p><ul><li>插入排序在对几乎已经排好序的数据操作时，效率高，即可以达到线性排序的效率；</li><li>但插入排序一般来说是低效的，因为插入排序每次只能将数据移动一位；</li></ul><p>希尔排序的基本思想是：先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，待整个序列中的记录”基本有序”时，再对全体记录进行依次直接插入排序。</p><p>特点：针对插入排序的改进，当数据规模较大或无序时也比较高效。精妙之处在于，可以同时构造出两个特殊的有利条件（数据量小，基本有序），一个有利条件弱时，另外一个有利条件就强。（刚开始时虽然每组有序度低，但其数据量小；随着每轮的增量逐渐压缩，虽然各组数据量逐渐变大，但其有序度逐渐增加。）</p><h3 id="1-算法步骤-3"><a href="#1-算法步骤-3" class="headerlink" title="1. 算法步骤"></a>1. 算法步骤</h3><p>选择一个增量序列 t1，t2，……，tk，其中 ti &gt; tj, tk = 1；</p><p>按增量序列个数 k，对序列进行 k 趟排序；</p><p>每趟排序，根据对应的增量 ti，将待排序列分割成若干长度为 m 的子序列，分别对各子表进行直接插入排序。仅增量因子为 1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。</p><h3 id="2-动图演示-3"><a href="#2-动图演示-3" class="headerlink" title="2. 动图演示"></a>2. 动图演示</h3><p><img src="https://www.runoob.com/wp-content/uploads/2019/03/Sorting_shellsort_anim.gif" alt="img"></p><h3 id="3-C-2"><a href="#3-C-2" class="headerlink" title="3.C++"></a>3.C++</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">template&lt;typename T&gt;void shell_sort(T array[], int length) {  int h = 1;  while (h &lt; length / 3) {    h = 3 * h + 1;  }  while (h &gt;= 1) {    for (int i = h; i &lt; length; i++) {      for (int j = i; j &gt;= h &amp;&amp; array[j] &lt; array[j - h]; j -= h) {        std::swap(array[j], array[j - h]);      }    }    h = h / 3;  }}void shellSortCore(vector&lt;int&gt;&amp; nums, int gap, int i) {    int inserted = nums[i];    int j;    // 插入的时候按组进行插入    for (j = i - gap; j &gt;= 0 &amp;&amp; inserted &lt; nums[j]; j -= gap) {        nums[j + gap] = nums[j];    }    nums[j + gap] = inserted;}void shellSort(vector&lt;int&gt;&amp; nums) {    int len = nums.size();    //进行分组，最开始的时候，gap为数组长度一半    for (int gap = len / 2; gap &gt; 0; gap /= 2) {        //对各个分组进行插入分组        for (int i = gap; i &lt; len; ++i) {            //将nums[i]插入到所在分组正确的位置上            shellSortCore(nums,gap,i);        }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://pic1.zhimg.com/80/v2-6bfd7452333abc0d8288ee11a4fbfe80_1440w.jpg" alt="img"></p><h2 id="5-归并排序"><a href="#5-归并排序" class="headerlink" title="5.归并排序"></a>5.归并排序</h2><p>归并排序（Merge sort）是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。</p><p>作为一种典型的分而治之思想的算法应用，归并排序的实现由两种方法：</p><ul><li>自上而下的递归（所有递归的方法都可以用迭代重写，所以就有了第 2 种方法）；</li><li>自下而上的迭代；</li></ul><p>归并排序，顾名思义就是合并两个有序数组。常见的归并排序有两种，递归法（自上而下的合并）和非递归法（自底向上的合并），都需要新开一个大小为n的数组来中转。递归法比较简单，就是中间切一刀，左右分别递归排序，最后合并两个有序数组。非递归法就是先分别对相邻的两个元素合并排序，第二趟时候分别对相邻的四个元素合并排序（此时前两个元素和后两个元素已有序），第三趟时候对相邻的八个元素合并排序，依次类推直至有序数组长度超过数组总长度。两者相较，递归的归并排序代码更简洁，代价是时间和空间复杂度上都会更大（因为有递归的logn）。下面的代码是非递归方法，后续对比也按照这个版本。</p><p>主要思想：类似两个有序链表的合并，每次两两合并相邻的两个有序序列，直至整个序列有序。</p><p>和选择排序一样，归并排序的性能不受输入数据的影响，但表现比选择排序好的多，因为始终都是 O(nlogn) 的时间复杂度。代价是需要额外的内存空间。</p><h3 id="1-算法步骤-4"><a href="#1-算法步骤-4" class="headerlink" title="1. 算法步骤"></a>1. 算法步骤</h3><ol><li>申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列；</li><li>设定两个指针，最初位置分别为两个已经排序序列的起始位置；</li><li>比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置；</li><li>重复步骤 3 直到某一指针达到序列尾；</li><li>将另一序列剩下的所有元素直接复制到合并序列尾。</li></ol><h3 id="2-动图演示-4"><a href="#2-动图演示-4" class="headerlink" title="2. 动图演示"></a>2. 动图演示</h3><p><img src="https://www.runoob.com/wp-content/uploads/2019/03/mergeSort.gif" alt="img"></p><h3 id="3-C-3"><a href="#3-C-3" class="headerlink" title="3.C++"></a>3.C++</h3><p><strong>迭代版：</strong></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">template&lt;typename T&gt; // 整數或浮點數皆可使用,若要使用物件(class)時必須設定"小於"(&lt;)的運算子功能void merge_sort(T arr[], int len) {  T *a = arr;  T *b = new T[len];  for (int seg = 1; seg &lt; len; seg += seg) {    for (int start = 0; start &lt; len; start += seg + seg) {      int low = start, mid = min(start + seg, len), high = min(start + seg + seg, len);      int k = low;      int start1 = low, end1 = mid;      int start2 = mid, end2 = high;      while (start1 &lt; end1 &amp;&amp; start2 &lt; end2)        b[k++] = a[start1] &lt; a[start2] ? a[start1++] : a[start2++];      while (start1 &lt; end1)        b[k++] = a[start1++];      while (start2 &lt; end2)        b[k++] = a[start2++];    }    T *temp = a;    a = b;    b = temp;  }  if (a != arr) {    for (int i = 0; i &lt; len; i++)      b[i] = a[i];    b = a;  }  delete[] b;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>递归版：</strong></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void Merge(vector&lt;int&gt; &amp;Array, int front, int mid, int end) {  // preconditions:  // Array[front...mid] is sorted  // Array[mid+1 ... end] is sorted  // Copy Array[front ... mid] to LeftSubArray  // Copy Array[mid+1 ... end] to RightSubArray  vector&lt;int&gt; LeftSubArray(Array.begin() + front, Array.begin() + mid + 1);  vector&lt;int&gt; RightSubArray(Array.begin() + mid + 1, Array.begin() + end + 1);  int idxLeft = 0, idxRight = 0;  LeftSubArray.insert(LeftSubArray.end(), numeric_limits&lt;int&gt;::max());  RightSubArray.insert(RightSubArray.end(), numeric_limits&lt;int&gt;::max());  // Pick min of LeftSubArray[idxLeft] and RightSubArray[idxRight], and put into Array[i]  for (int i = front; i &lt;= end; i++) {    if (LeftSubArray[idxLeft] &lt; RightSubArray[idxRight]) {      Array[i] = LeftSubArray[idxLeft];      idxLeft++;    } else {      Array[i] = RightSubArray[idxRight];      idxRight++;    }  }}void MergeSort(vector&lt;int&gt; &amp;Array, int front, int end) {  if (front &gt;= end)    return;  int mid = (front + end) / 2;  MergeSort(Array, front, mid);  MergeSort(Array, mid + 1, end);  Merge(Array, front, mid, end);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://www.runoob.com/wp-content/uploads/2019/05/1557906108-5066-20161218163120151-452283750.png" alt="img"></p><h2 id="6-快速排序"><a href="#6-快速排序" class="headerlink" title="6.快速排序"></a>6.快速排序</h2><p>快速排序使用分治法（Divide and conquer）策略来把一个串行（list）分为两个子串行（sub-lists）。</p><p>快速排序又是一种分而治之思想在排序算法上的典型应用。本质上来看，快速排序应该算是在冒泡排序基础上的递归分治法。</p><p>快速排序的名字起的是简单粗暴，因为一听到这个名字你就知道它存在的意义，就是快，而且效率高！它是处理大数据最快的排序算法之一了。虽然 Worst Case 的时间复杂度达到了 O(n²)，但是人家就是优秀，在大多数情况下都比平均时间复杂度为 O(n logn) 的排序算法表现要更好，</p><p>主要思想：分治思想。选一基准元素，依次将剩余元素中小于该基准元素的值放置其左侧，大于等于该基准元素的值放置其右侧；然后，取基准元素的前半部分和后半部分分别进行同样的处理；以此类推，直至各子序列剩余一个元素时，即排序完成。</p><p>注意：对于小规模数据（n&lt;100），快排由于用了递归，其效率可能还不如插排。因此通常可以定义一个阈值，当递归的数据量很小时停止递归，直接调用插排。</p><p><em>快速排序的最坏运行情况是 O(n²)，比如说顺序数列的快排。但它的平摊期望时间是 O(nlogn)，且 O(nlogn) 记号中隐含的常数因子很小，比复杂度稳定等于 O(nlogn) 的归并排序要小很多。所以，对绝大多数顺序性较弱的随机数列而言，快速排序总是优于归并排序。</em></p><h3 id="1-算法步骤-5"><a href="#1-算法步骤-5" class="headerlink" title="1. 算法步骤"></a>1. 算法步骤</h3><ol><li>从数列中挑出一个元素，称为 “基准”（pivot）;</li><li>重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；</li><li>递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序；</li></ol><h3 id="2-动图演示-5"><a href="#2-动图演示-5" class="headerlink" title="2. 动图演示"></a>2. 动图演示</h3><p><img src="https://www.runoob.com/wp-content/uploads/2019/03/quickSort.gif" alt="img"></p><h3 id="3-C-4"><a href="#3-C-4" class="headerlink" title="3.C++"></a>3.C++</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">//严蔚敏《数据结构》标准分割函数 Paritition1(int A[], int low, int high) {  int pivot = A[low];  while (low &lt; high) {   while (low &lt; high &amp;&amp; A[high] &gt;= pivot) {    --high;   }   A[low] = A[high];   while (low &lt; high &amp;&amp; A[low] &lt;= pivot) {    ++low;   }   A[high] = A[low];  }  A[low] = pivot;  return low; } void QuickSort(int A[], int low, int high) //快排母函数 {  if (low &lt; high) {   int pivot = Paritition1(A, low, high);   QuickSort(A, low, pivot - 1);   QuickSort(A, pivot + 1, high);  } }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>迭代法</strong></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">// 参考：http://www.dutor.net/index.php/2011/04/recursive-iterative-quick-sort/struct Range {  int start, end;  Range(int s = 0, int e = 0) {    start = s, end = e;  }};template &lt;typename T&gt; // 整數或浮點數皆可使用,若要使用物件(class)時必須設定"小於"(&lt;)、"大於"(&gt;)、"不小於"(&gt;=)的運算子功能void quick_sort(T arr[], const int len) {  if (len &lt;= 0)    return; // 避免len等於負值時宣告堆疊陣列當機  // r[]模擬堆疊,p為數量,r[p++]為push,r[--p]為pop且取得元素  Range r[len];  int p = 0;  r[p++] = Range(0, len - 1);  while (p) {    Range range = r[--p];    if (range.start &gt;= range.end)      continue;    T mid = arr[range.end];    int left = range.start, right = range.end - 1;    while (left &lt; right) {      while (arr[left] &lt; mid &amp;&amp; left &lt; right) left++;      while (arr[right] &gt;= mid &amp;&amp; left &lt; right) right--;      std::swap(arr[left], arr[right]);    }    if (arr[left] &gt;= arr[range.end])      std::swap(arr[left], arr[range.end]);    else      left++;    r[p++] = Range(range.start, left - 1);    r[p++] = Range(left + 1, range.end);  }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>递归法</strong></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">template &lt;typename T&gt;void quick_sort_recursive(T arr[], int start, int end) {  if (start &gt;= end)    return;  T mid = arr[end];  int left = start, right = end - 1;  while (left &lt; right) { //在整个范围内搜寻比枢纽元值小或大的元素，然后将左侧元素与右侧元素交换    while (arr[left] &lt; mid &amp;&amp; left &lt; right) //试图在左侧找到一个比枢纽元更大的元素      left++;    while (arr[right] &gt;= mid &amp;&amp; left &lt; right) //试图在右侧找到一个比枢纽元更小的元素      right--;    std::swap(arr[left], arr[right]); //交换元素  }  if (arr[left] &gt;= arr[end])    std::swap(arr[left], arr[end]);  else    left++;  quick_sort_recursive(arr, start, left - 1);  quick_sort_recursive(arr, left + 1, end);}template &lt;typename T&gt; //整數或浮點數皆可使用,若要使用物件(class)時必須設定"小於"(&lt;)、"大於"(&gt;)、"不小於"(&gt;=)的運算子功能void quick_sort(T arr[], int len) {  quick_sort_recursive(arr, 0, len - 1);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="7-堆排序"><a href="#7-堆排序" class="headerlink" title="7.堆排序"></a>7.堆排序</h2><p>堆排序（Heapsort）是指利用堆这种数据结构所设计的一种排序算法。堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。堆排序可以说是一种利用堆的概念来排序的选择排序。分为两种方法：</p><ol><li>大顶堆：每个节点的值都大于或等于其子节点的值，在堆排序算法中用于升序排列；</li><li>小顶堆：每个节点的值都小于或等于其子节点的值，在堆排序算法中用于降序排列；</li></ol><p>堆排序的平均时间复杂度为 Ο(nlogn)。</p><p>主要思想：将待排数组构建成一个最大堆，将堆顶最大元素换到后面，然后堆容量减1；类似进行N-1次操作即可。</p><h3 id="1-算法步骤-6"><a href="#1-算法步骤-6" class="headerlink" title="1. 算法步骤"></a>1. 算法步骤</h3><ol><li>创建一个堆 H[0……n-1]；</li><li>把堆首（最大值）和堆尾互换；</li><li>把堆的尺寸缩小 1，并调用 shift_down(0)，目的是把新的数组顶端数据调整到相应位置；</li><li>重复步骤 2，直到堆的尺寸为 1。</li></ol><h3 id="2-动图演示-6"><a href="#2-动图演示-6" class="headerlink" title="2. 动图演示"></a>2. 动图演示</h3><p><img src="https://www.runoob.com/wp-content/uploads/2019/03/heapSort.gif" alt="img"></p><p><img src="https://www.runoob.com/wp-content/uploads/2019/03/Sorting_heapsort_anim.gif" alt="img"></p><h3 id="3-C-5"><a href="#3-C-5" class="headerlink" title="3.C++"></a>3.C++</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void max_heapify(int arr[], int start, int end) {  // 建立父節點指標和子節點指標  int dad = start;  int son = dad * 2 + 1;  while (son &lt;= end) { // 若子節點指標在範圍內才做比較    if (son + 1 &lt;= end &amp;&amp; arr[son] &lt; arr[son + 1]) // 先比較兩個子節點大小，選擇最大的      son++;    if (arr[dad] &gt; arr[son]) // 如果父節點大於子節點代表調整完畢，直接跳出函數      return;    else { // 否則交換父子內容再繼續子節點和孫節點比較      swap(arr[dad], arr[son]);      dad = son;      son = dad * 2 + 1;    }  }}void heap_sort(int arr[], int len) {  // 初始化，i從最後一個父節點開始調整  for (int i = len / 2 - 1; i &gt;= 0; i--)    max_heapify(arr, i, len - 1);  // 先將第一個元素和已经排好的元素前一位做交換，再從新調整(刚调整的元素之前的元素)，直到排序完畢  for (int i = len - 1; i &gt; 0; i--) {    swap(arr[0], arr[i]);    max_heapify(arr, 0, i - 1);  }}void heapify(vector&lt;int&gt;&amp; nums, int n, int i)//对有一定顺序的堆，//当前第i个结点取根左右的最大值（这个操作称heapfiy）{int l = i * 2 + 1, r = i * 2 + 2;int max = i;if (l&lt;n &amp;&amp; nums[l]&gt;nums[max])max = l;if (r&lt;n &amp;&amp; nums[r]&gt;nums[max])max = r;if (max != i){swap(nums[max], nums[i]);heapify(nums, n, max);}}void heapify_build(vector&lt;int&gt;&amp; nums, int n)//建立大根堆，从树的倒数第二层第一个结点开始，//对每个结点进行heapify操作，然后向上走{int temp = (n - 2) / 2;for (int i = temp; i &gt;= 0; i--)heapify(nums, n, i);for (int i = 0; i &lt; nums.size(); i++)cout &lt;&lt; nums[i] &lt;&lt; " ";cout &lt;&lt; endl;}void heapify_sort(vector&lt;int&gt;&amp; nums, int n)//建立大根堆之后，每次交换最后一个结点和根节点（最大值），//对交换后的根节点继续进行heapify（此时堆的最后一位是最大值，因此不用管他，n变为n-1）{heapify_build(nums, n);for (int i = 0; i &lt; n; i++){swap(nums.front(), nums[n - i - 1]);heapify(nums, n - i - 1, 0);}}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="8-计数排序"><a href="#8-计数排序" class="headerlink" title="8.计数排序"></a>8.计数排序</h2><p>计数排序的核心在于将输入的数据值转化为键存储在额外开辟的数组空间中。作为一种线性时间复杂度的排序，计数排序要求输入的数据必须是有确定范围的整数。计数排序主要适用场景是元素值比较集中，特别是集中在一个小区间里面。</p><p>计数排序的特征</p><p>当输入的元素是 n 个 0 到 k 之间的整数时，它的运行时间是 Θ(n + k)。计数排序不是比较排序，排序的速度快于任何比较排序算法。</p><p>由于用来计数的数组C的长度取决于待排序数组中数据的范围（等于待排序数组的最大值与最小值的差加上1），这使得计数排序对于数据范围很大的数组，需要大量时间和内存。例如：计数排序是用来排序0到100之间的数字的最好的算法，但是它不适合按字母顺序排序人名。但是，计数排序可以用在基数排序中的算法来排序数据范围很大的数组。</p><p>通俗地理解，例如有 10 个年龄不同的人，统计出有 8 个人的年龄比 A 小，那 A 的年龄就排在第 9 位,用这个方法可以得到其他每个人的位置,也就排好了序。当然，年龄有重复时需要特殊处理（保证稳定性），这就是为什么最后要反向填充目标数组，以及将每个数字的统计减去 1 的原因。</p><h3 id="1-算法的步骤"><a href="#1-算法的步骤" class="headerlink" title="1.算法的步骤"></a>1.算法的步骤</h3><ul><li>（1）找出待排序的数组中最大和最小的元素</li><li>（2）统计数组中每个值为 i 的元素出现的次数，存入数组C的第 i 项</li><li>（3）对所有的计数累加（从C中的第一个元素开始，每一项和前一项相加）</li><li>（4）反向填充目标数组：将每个元素 i 放在新数组的第C(i)项，每放一个元素就将C(i)减去1</li></ul><h3 id="2-动图演示-7"><a href="#2-动图演示-7" class="headerlink" title="2. 动图演示"></a>2. 动图演示</h3><p><img src="https://www.runoob.com/wp-content/uploads/2019/03/countingSort.gif" alt="img"></p><h3 id="3-C-6"><a href="#3-C-6" class="headerlink" title="3.C++"></a>3.C++</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">//计数排序。应用场景：对公司几万个员工的年龄进行排序void count_sort(int a[], int N){    if(a==NULL || N&lt;=1) return;    const int largest = 99;  //假设数值范围是0~99    int bucket[largest+1]; //申请100个桶，并清零。桶用来存储各个数值出现次数    for(int i=0; i&lt;=largest; i++) //注意这里是 &lt;= ，容易出错        bucket[i] = 0;    //遍历数组，桶记录各值出现次数    for(int i=0; i&lt;N; i++){        if(a[i]&lt;0 || a[i]&gt;largest){            printf("Value is out of range!");            exit(-1);        }        bucket[a[i]] += 1;    }    //遍历各个桶，根据桶的记录值，对原数组进行排序    int index = 0; //原数组的下标    for(int k=0; k&lt;=largest; k++){ //k为桶的下标        int num = bucket[k]; //数值为k的个数        for(int i=0; i&lt;num; i++){            a[index] = k;            index++;        }    }    return;}#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;// 计数排序void CountSort(vector&lt;int&gt;&amp; vecRaw, vector&lt;int&gt;&amp; vecObj){// 确保待排序容器非空if (vecRaw.size() == 0)return;// 使用 vecRaw 的最大值 + 1 作为计数容器 countVec 的大小int vecCountLength = (*max_element(begin(vecRaw), end(vecRaw))) + 1;vector&lt;int&gt; vecCount(vecCountLength, 0);// 统计每个键值出现的次数for (int i = 0; i &lt; vecRaw.size(); i++)vecCount[vecRaw[i]]++;// 后面的键值出现的位置为前面所有键值出现的次数之和for (int i = 1; i &lt; vecCountLength; i++)vecCount[i] += vecCount[i - 1];// 将键值放到目标位置for (int i = vecRaw.size(); i &gt; 0; i--) // 此处逆序是为了保持相同键值的稳定性vecObj[--vecCount[vecRaw[i - 1]]] = vecRaw[i - 1];}int main(){vector&lt;int&gt; vecRaw = { 0,5,7,9,6,3,4,5,2,8,6,9,2,1 };vector&lt;int&gt; vecObj(vecRaw.size(), 0);CountSort(vecRaw, vecObj);for (int i = 0; i &lt; vecObj.size(); ++i)cout &lt;&lt; vecObj[i] &lt;&lt; " ";    cout &lt;&lt; endl;return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="9-桶排序"><a href="#9-桶排序" class="headerlink" title="9.桶排序"></a>9.桶排序</h2><p>桶排序是计数排序的升级版。它利用了函数的映射关系，高效与否的关键就在于这个映射函数的确定。为了使桶排序更加高效，我们需要做到这两点：</p><ol><li>在额外空间充足的情况下，尽量增大桶的数量</li><li>使用的映射函数能够将输入的 N 个数据均匀的分配到 K 个桶中</li></ol><p>同时，对于桶中元素的排序，选择何种比较排序算法对于性能的影响至关重要。</p><p>桶排序两大步骤：第一步是将值域划分成几个区间，然后将待排数组中各元素映射到这几个区间上（从区间这个大视角来看，这几个区间是有序的）；第二步是针对各个区间内部元素，选择一个喜欢的算法进行排序。经过两步之后，整个数组就有序了。</p><p>桶排序是对计数排序的改进，计数排序申请的额外空间跨度从最小元素值到最大元素值，若待排序集合中元素不是依次递增的，则必然有空间浪费情况。桶排序则是弱化了这种浪费情况，将最小值到最大值之间的每一个位置申请空间，更新为最小值到最大值之间每一个固定区域申请空间，尽量减少了元素值大小不连续情况下的空间浪费情况。另外，从分桶的思想来看，快排也是一种分桶方法，即用一个pivot将值域切割成两个桶，左右分别递归。只不过快排是用一个pivot来切割值域，而桶排序则是直接将值域划分成几个区间。</p><p>桶排序的主要适用场景是，各元素值分布比较均匀，这样分桶时候就可以比较均匀，尽量避免把大部分元素都分到少数几个桶中。</p><h5 id="桶排序过程中存在两个关键环节："><a href="#桶排序过程中存在两个关键环节：" class="headerlink" title="桶排序过程中存在两个关键环节："></a>桶排序过程中存在两个关键环节：</h5><ul><li>元素值域的划分，也就是元素到桶的映射规则。映射规则需要根据待排序集合的元素分布特性进行选择，若规则设计的过于模糊、宽泛，则可能导致待排序集合中所有元素全部映射到一个桶上，则桶排序向比较性质排序算法演变。若映射规则设计的过于具体、严苛，则可能导致待排序集合中每一个元素值映射到一个桶上，则桶排序向计数排序方式演化。</li><li>排序算法的选择，从待排序集合中元素映射到各个桶上的过程，并不存在元素的比较和交换操作，在对各个桶中元素进行排序时，可以自主选择合适的排序算法，桶排序算法的复杂度和稳定性，都根据选择的排序算法不同而不同。</li></ul><h3 id="1-什么时候最快"><a href="#1-什么时候最快" class="headerlink" title="1. 什么时候最快"></a>1. 什么时候最快</h3><p>当输入的数据可以均匀的分配到每一个桶中。</p><h3 id="2-什么时候最慢"><a href="#2-什么时候最慢" class="headerlink" title="2. 什么时候最慢"></a>2. 什么时候最慢</h3><p>当输入的数据被分配到了同一个桶中。</p><h3 id="3-算法过程"><a href="#3-算法过程" class="headerlink" title="3.算法过程"></a>3.算法过程</h3><ol><li>根据待排序集合中最大元素和最小元素的差值范围和映射规则，确定申请的桶个数；</li><li>遍历待排序集合，将每一个元素移动到对应的桶中；</li><li>对每一个桶中元素进行排序，并移动到已排序集合中。</li></ol><p>步骤 3 中提到的已排序集合，和步骤 1、2 中的待排序集合是同一个集合。与计数排序不同，桶排序的步骤 2 完成之后，所有元素都处于桶中，并且对桶中元素排序后，移动元素过程中不再依赖原始集合，所以可以将桶中元素移动回原始集合即可。</p><h3 id="4-示意图"><a href="#4-示意图" class="headerlink" title="4. 示意图"></a>4. 示意图</h3><p>元素分布在桶中：</p><p><img src="https://www.runoob.com/wp-content/uploads/2019/03/Bucket_sort_1.svg_.png" alt="img"></p><h3 id="5-C"><a href="#5-C" class="headerlink" title="5.C++"></a>5.C++</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;iterator&gt;#include&lt;iostream&gt;#include&lt;vector&gt;using namespace std;const int BUCKET_NUM = 10;struct ListNode{        explicit ListNode(int i=0):mData(i),mNext(NULL){}        ListNode* mNext;        int mData;};ListNode* insert(ListNode* head,int val){        ListNode dummyNode;        ListNode *newNode = new ListNode(val);        ListNode *pre,*curr;        dummyNode.mNext = head;        pre = &amp;dummyNode;        curr = head;        while(NULL!=curr &amp;&amp; curr-&gt;mData&lt;=val){                pre = curr;                curr = curr-&gt;mNext;        }        newNode-&gt;mNext = curr;        pre-&gt;mNext = newNode;        return dummyNode.mNext;}ListNode* Merge(ListNode *head1,ListNode *head2){        ListNode dummyNode;        ListNode *dummy = &amp;dummyNode;        while(NULL!=head1 &amp;&amp; NULL!=head2){                if(head1-&gt;mData &lt;= head2-&gt;mData){                        dummy-&gt;mNext = head1;                        head1 = head1-&gt;mNext;                }else{                        dummy-&gt;mNext = head2;                        head2 = head2-&gt;mNext;                }                dummy = dummy-&gt;mNext;        }        if(NULL!=head1) dummy-&gt;mNext = head1;        if(NULL!=head2) dummy-&gt;mNext = head2;        return dummyNode.mNext;}void BucketSort(int n,int arr[]){        vector&lt;ListNode*&gt; buckets(BUCKET_NUM,(ListNode*)(0));        for(int i=0;i&lt;n;++i){                int index = arr[i]/BUCKET_NUM;                ListNode *head = buckets.at(index);                buckets.at(index) = insert(head,arr[i]);        }        ListNode *head = buckets.at(0);        for(int i=1;i&lt;BUCKET_NUM;++i){                head = Merge(head,buckets.at(i));        }        for(int i=0;i&lt;n;++i){                arr[i] = head-&gt;mData;                head = head-&gt;mNext;        }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="10-基数排序"><a href="#10-基数排序" class="headerlink" title="10.基数排序"></a>10.基数排序</h2><p>基数排序是一种非比较型整数排序算法，其原理是将整数按位数切割成不同的数字，然后按每个位数分别比较。由于整数也可以表达字符串（比如名字或日期）和特定格式的浮点数，所以基数排序也不是只能使用于整数。它首先将所有待比较数值，统一为同样的数位长度，数位较短的数前面补零。然后，从最低位开始，依次进行一次排序。这样从最低位排序一直到最高位排序完成以后，数列就变成一个有序序列。</p><p>主要思想：基数排序是按照低位先排序，然后收集；再按照高位排序，然后再收集；依次类推，直到最高位。</p><p>基排序的主要适用场景是待排元素是非负整数，且位数相差不大。此外，整数也可以用字符串等表达，所以也可以用于字符串的排序。</p><h3 id="1-基数排序-vs-计数排序-vs-桶排序"><a href="#1-基数排序-vs-计数排序-vs-桶排序" class="headerlink" title="1. 基数排序 vs 计数排序 vs 桶排序"></a>1. 基数排序 vs 计数排序 vs 桶排序</h3><p>基数排序有两种方法：</p><p>这三种排序算法都利用了桶的概念，但对桶的使用方法上有明显差异：</p><ul><li>基数排序：根据键值的每位数字来分配桶；</li><li>计数排序：每个桶只存储单一键值；</li><li>桶排序：每个桶存储一定范围的数值；</li></ul><h3 id="2-LSD-基数排序动图演示"><a href="#2-LSD-基数排序动图演示" class="headerlink" title="2. LSD 基数排序动图演示"></a>2. LSD 基数排序动图演示</h3><p><img src="https://www.runoob.com/wp-content/uploads/2019/03/radixSort.gif" alt="img"></p><h3 id="3-C-7"><a href="#3-C-7" class="headerlink" title="3.C++"></a>3.C++</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int maxbit(int data[], int n) //辅助函数，求数据的最大位数{    int maxData = data[0];              ///&lt; 最大数    /// 先求出最大数，再求其位数，这样有原先依次每个数判断其位数，稍微优化点。    for (int i = 1; i &lt; n; ++i)    {        if (maxData &lt; data[i])            maxData = data[i];    }    int d = 1;    int p = 10;    while (maxData &gt;= p)    {        //p *= 10; // Maybe overflow        maxData /= 10;        ++d;    }    return d;/*    int d = 1; //保存最大的位数    int p = 10;    for(int i = 0; i &lt; n; ++i)    {        while(data[i] &gt;= p)        {            p *= 10;            ++d;        }    }    return d;*/}void radixsort(int data[], int n) //基数排序{    int d = maxbit(data, n);    int *tmp = new int[n];    int *count = new int[10]; //计数器    int i, j, k;    int radix = 1;    for(i = 1; i &lt;= d; i++) //进行d次排序    {        for(j = 0; j &lt; 10; j++)            count[j] = 0; //每次分配前清空计数器        for(j = 0; j &lt; n; j++)        {            k = (data[j] / radix) % 10; //统计每个桶中的记录数            count[k]++;        }        for(j = 1; j &lt; 10; j++)            count[j] = count[j - 1] + count[j]; //将tmp中的位置依次分配给每个桶        for(j = n - 1; j &gt;= 0; j--) //将所有桶中记录依次收集到tmp中        {            k = (data[j] / radix) % 10;            tmp[count[k] - 1] = data[j];            count[k]--;        }        for(j = 0; j &lt; n; j++) //将临时数组的内容复制到data中            data[j] = tmp[j];        radix = radix * 10;    }    delete []tmp;    delete []count;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ProcessedAndThreads</title>
      <link href="/2023/06/27/processedandthreads/"/>
      <url>/2023/06/27/processedandthreads/</url>
      
        <content type="html"><![CDATA[<h1 id="现代操作系统是如何做到进程之间隔离的"><a href="#现代操作系统是如何做到进程之间隔离的" class="headerlink" title="现代操作系统是如何做到进程之间隔离的?"></a>现代操作系统是如何做到进程之间隔离的?</h1><p>作者：北极<br>链接：<a href="https://www.zhihu.com/question/536968552/answer/2657728501">https://www.zhihu.com/question/536968552/answer/2657728501</a><br>来源：知乎<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。  </p><p>主要的工作是操作系统与MMU合作完成的。</p><p>MMU也就是页表（评论里有人说这里描述不对，准确的说，MMU是操作页表的东西），可以控制哪些内存能被用户态访问，哪些内存能在内核态被访问，以及一个虚拟地址对应的物理地址是哪里。一般来说，<strong>内核态可以访问用户态的内存，但反过来不行</strong>。</p><p>主流的操作系统都会划分出固定的内存区域，来区分内核态和用户态，同时，通过MMU页表来禁止用户态的代码直接访问内核区域的内存。</p><p>比如32位Windows里，00000000 ~ 7FFFFFFF是用户内存区，80000000 ~ FFFFFFFF是内核内存区（2G用户，2G内核），用户态代码不能访问内核态代码，但内核态代码可以访问用户态代码。Linux一般是3G用户，1G内核。</p><p>到了64位环境下，一般是00000000 00000000 ~ 00007FFF FFFFFFFF是用户态，FFFF8000 00000000 ~ FFFFFFFF FFFFFFFF是内核态。</p><p>通过设置MMU页表属性，把相关的地址范围都隔离开，这样用户态代码就无法访问内核内存区了。</p><p>不同的进程可以拥有不同的页表，并且页表在内核态（或则通过权限设置，只能让内核访问），这样就可以防止用户态恶意代码修改页表。</p><p>通过上面的操作，因为用户态进程每次访问内存，都要通过页表，<strong>操作系统只要控制页表</strong>，把不同进程的虚拟地址映射到不同的物理地址上，<strong>就可以实现进程间的内存隔离了</strong>。同时，用户代码不能访问页表，所以用户进程也就不能修改内存映射了。</p><p><strong>换页的过程是在内核完成的</strong>，内核是知道哪些内存被换出，哪些内存被换入的，这个操作不是在用户态完成的，所以用户态进程是看不到换入换出的内容的。</p><p><strong>进程是资源分配的最小单位，线程是CPU调度的最小单位</strong></p><p>进程是并发执行的程序在执行过程中分配和管理资源的基本单位。线程是进程的一个执行单元，是比进程还要小的独立运行的基本单位。一个程序至少有一个进程，一个进程至少有一个线程</p><p><strong>进程</strong>：</p><p>进程是资源（CPU、内存等）分配的基本单位，它是程序执行时的一个实例。程序运行时系统就会创建一个进程，并为它分配资源，然后把该进程放入进程就绪队列，进程调度器选中它的时候就会为它分配CPU时间，程序开始真正运行。</p><p><strong>线程</strong>：</p><p>线程是程序执行时的最小单位，它是进程的一个执行流，是CPU调度和分派的基本单位，一个进程可以由很多个线程组成，线程间共享进程的所有资源，每个线程有自己的栈和局部变量。线程由CPU独立调度执行，在多CPU环境下就允许多个线程同时运行。同样多线程也可以实现并发操作，每个请求分配一个线程来处理。</p><p>与进程不同的是同类的多个线程共享进程的<strong>堆</strong>和<strong>方法区</strong>资源，但每个线程有自己的<strong>程序计数器</strong>、<strong>寄存器</strong>、<strong>虚拟机栈</strong>和<strong>本地方法栈</strong>，所以系统在产生一个线程，或是在各个线程之间作切换工作时，负担要比进程小得多，也正因为如此，线程也被称为轻量级进程。</p><p><strong>二者的区别</strong>：</p><p>1、进程是资源分配的最小单位，线程是程序执行的最小单位</p><p>2、进程有自己的独立地址空间，每启动一个进程，系统就会为它分配地址空间，建立数据表来维护代码段、堆栈段和数据段，这种操作非常昂贵。而线程是共享进程中的数据的，使用相同的地址空间，因此CPU切换一个线程的花费远比进程要小很多，同时创建一个线程的开销也比进程要小很多。</p><p>3、线程之间的通信更方便，同一进程下的线程共享全局变量、静态变量等数据，而进程之间的通信需要以通信的方式（IPC)进行。不过如何处理好同步与互斥是编写多线程程序的难点。</p><p>4、多进程程序更健壮，多线程程序只要有一个线程死掉，整个进程也死掉了，而一个进程死掉并不会对另外一个进程造成影响，因为进程有自己独立的地址空间。</p><p>线程挂了，是否会影响进程？</p><p>1.进程（主线程）创建了多个线程，多个子线程均拥有自己独立的栈空间（存储函数参数、局部变量等），但是多个子线程和主线程共享堆、全局变量等非栈内存。</p><p>2.如果子线程的崩溃是由于自己的一亩三分地引起的，那就不会对主线程和其他子线程产生影响，但是如果子线程的崩溃是因为对共享区域造成了破坏，那么大家就一起崩溃了。</p><h4 id="二、进程与线程的资源："><a href="#二、进程与线程的资源：" class="headerlink" title="二、进程与线程的资源："></a>二、进程与线程的资源：</h4><h6 id="1、堆与栈"><a href="#1、堆与栈" class="headerlink" title="1、堆与栈"></a>1、堆与栈</h6><p>堆：　是大家共有的空间，分全局堆和局部堆。全局堆就是所有没有分配的空间，局部堆就是用户分配的空间。堆在操作系统对进程初始化的时候分配，运行过程中也可以向系统要额外的堆，但是记得用完了要还给操作系统，要不然就是内存泄漏。<br>栈：是各线程独有的，保存其运行状态和局部自动变量的。栈在线程开始的时候初始化，每个线程的栈互相独立，因此，栈是　thread safe的。操作系统在切换线程的时候会自动的切换栈，就是切换　ＳＳ／ＥＳＰ寄存器。栈空间不需要在高级语言里面显式的分配和释放。</p><h6 id="2、其他"><a href="#2、其他" class="headerlink" title="2、其他"></a>2、其他</h6><p>线程共享的环境包括：进程代码段、进程的公有数据(利用这些共享的数据，线程很容易的实现相互之间的通讯)、进程打开的文件描述符、信号的处理器、进程的当前目录和进程用户ID与进程组ID。<br>进程拥有这许多共性的同时，还拥有自己的个性。有了这些个性，线程才能实现并发性。这些个性包括：<br>1.线程ID<br>每个线程都有自己的线程ID，这个ID在本进程中是唯一的。进程用此来标<br>识线程。<br>2.寄存器组的值<br>由于线程间是并发运行的，每个线程有自己不同的运行线索，当从一个线<br>程切换到另一个线程上时，必须将原有的线程的寄存器集合的状态保存，以便<br>将来该线程在被重新切换到时能得以恢复。<br>3.线程的堆栈<br>堆栈是保证线程独立运行所必须的。<br>线程函数可以调用函数，而被调用函数中又是可以层层嵌套的，所以线程<br>必须拥有自己的函数堆栈，使得函数调用可以正常执行，不受其他线程的影<br>响。<br>4.错误返回码<br>由于同一个进程中有很多个线程在同时运行，可能某个线程进行系统调用<br>后设置了errno值，而在该线程还没有处理这个错误，另外一个线程就在此时<br>被调度器投入运行，这样错误值就有可能被修改。<br>所以，不同的线程应该拥有自己的错误返回码变量。<br>5.线程的信号屏蔽码<br>由于每个线程所感兴趣的信号不同，所以线程的信号屏蔽码应该由线程自<br>己管理。但所有的线程都共享同样的信号处理器。<br>6.线程的优先级<br>由于线程需要像进程那样能够被调度，那么就必须要有可供调度使用的参<br>数，这个参数就是线程的优先级。</p><p><strong>进程与线程的区别总结</strong><br>线程具有许多传统进程所具有的特征，故又称为轻型进程(Light—Weight Process)或进程元；而把传统的进程称为重型进程(Heavy—Weight Process)，它相当于只有一个线程的任务。在引入了线程的操作系统中，通常一个进程都有若干个线程，至少包含一个线程。</p><p>根本区别：进程是操作系统资源分配的基本单位，而线程是处理器任务调度和执行的基本单位</p><p>资源开销：每个进程都有独立的代码和数据空间（程序上下文），程序之间的切换会有较大的开销；线程可以看做轻量级的进程，同一类线程共享代码和数据空间，每个线程都有自己独立的运行栈和程序计数器（PC），线程之间切换的开销小。</p><p>包含关系：如果一个进程内有多个线程，则执行过程不是一条线的，而是多条线（线程）共同完成的；线程是进程的一部分，所以线程也被称为轻权进程或者轻量级进程。</p><p>内存分配：同一进程的线程共享本进程的地址空间和资源，而进程之间的地址空间和资源是相互独立的</p><p>影响关系：一个进程崩溃后，在保护模式下不会对其他进程产生影响，但是一个线程崩溃整个进程都死掉。所以多进程要比多线程健壮。</p><p>执行过程：每个独立的进程有程序运行的入口、顺序执行序列和程序出口。但是线程不能独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制，两者均可并发执行</p><p>做个简单的比喻：进程=火车，线程=车厢</p><ul><li>线程在进程下行进（单纯的车厢无法运行）</li><li>一个进程可以包含多个线程（一辆火车可以有多个车厢）</li><li>不同进程间数据很难共享（一辆火车上的乘客很难换到另外一辆火车，比如站点换乘）</li><li>同一进程下不同线程间数据很易共享（A车厢换到B车厢很容易）</li><li>进程要比线程消耗更多的计算机资源（采用多列火车相比多个车厢更耗资源）</li><li>进程间不会相互影响，一个线程挂掉将导致整个进程挂掉（一列火车不会影响到另外一列火车，但是如果一列火车上中间的一节车厢着火了，将影响到所有车厢）</li><li>进程可以拓展到多机，进程最多适合多核（不同火车可以开在多个轨道上，同一火车的车厢不能在行进的不同的轨道上）</li><li>进程使用的内存地址可以上锁，即一个线程使用某些共享内存时，其他线程必须等它结束，才能使用这一块内存。（比如火车上的洗手间）－”互斥锁”</li><li>进程使用的内存地址可以限定使用量（比如火车上的餐厅，最多只允许多少人进入，如果满了需要在门口等，等有人出来了才能进去）－“信号量”</li></ul><h6 id="3、进程与线程的同步"><a href="#3、进程与线程的同步" class="headerlink" title="3、进程与线程的同步"></a>3、进程与线程的同步</h6><p>进程：无名管道、有名管道、信号、共享内存、消息队列、信号量、Socket<br>进程：互斥量、读写锁、自旋锁、信号量、条件变量</p><h1 id="为什么进程切换比线程切换耗费资源？"><a href="#为什么进程切换比线程切换耗费资源？" class="headerlink" title="为什么进程切换比线程切换耗费资源？"></a>为什么进程切换比线程切换耗费资源？</h1><p>每个进程都有对应的页表，进程切换的时候需要切换页表，为了加快虚拟地址的地址转换效率，所以引入了TLB来缓存对应的虚拟地址和物理地址的映射。</p><p>切换页表这个操作本身是不太耗费时间的，切换之后，TLB就失效了，所以在进行地址转化的时候需要重新去查找页表，这就造成了程序运行的效率低下。</p><p>同一个进程的线程之间是共用一个页表的，所以线程之间的切换是不需要切换页表的。</p><p><strong>进程切换分两步：</strong></p><p><strong>1.切换页目录以使用新的地址空间</strong></p><p><strong>2.切换内核栈和硬件上下文</strong></p><p>对于linux来说，线程和进程的最大区别就在于<a href="https://so.csdn.net/so/search?q=%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4&amp;spm=1001.2101.3001.7020">地址空间</a>，对于线程切换，第1步是不需要做的，第2是进程和线程切换都要做的。</p><p><strong>切换的性能消耗：</strong></p><p>1、线程上下文切换和进程上下问切换一个最主要的区别是线程的切换<a href="https://so.csdn.net/so/search?q=%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98&amp;spm=1001.2101.3001.7020">虚拟内存</a>空间依然是相同的，但是进程切换是不同的。这两种上下文切换的处理都是通过操作系统内核来完成的。内核的这种切换过程伴随的最显著的性能损耗是将寄存器中的内容切换出。</p><p>2、另外一个隐藏的损耗是上下文的切换会扰乱处理器的缓存机制。简单的说，一旦去切换上下文，处理器中所有已经缓存的内存地址一瞬间都作废了。还有一个显著的区别是当你改变虚拟内存空间的时候，处理的页表缓冲（processor’s Translation Lookaside Buffer (TLB)）或者相当的神马东西会被全部刷新，这将导致内存的访问在一段时间内相当的低效。但是在线程的切换中，不会出现这个问题。</p><p><strong>程序计数器为什么是私有的?</strong><br>程序计数器主要有下面两个作用：</p><p>字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制，如：顺序执行、选择、循环、异常处理。<br>在多线程的情况下，程序计数器用于记录当前线程执行的位置，从而当线程被切换回来的时候能够知道该线程上次运行到哪儿了。<br>需要注意的是，如果执行的是 native 方法，那么程序计数器记录的是 undefined 地址，只有执行的是 Java 代码时程序计数器记录的才是下一条指令的地址。</p><p>所以，程序计数器私有主要是为了线程切换后能恢复到正确的执行位置。</p><p>一、进程与线程的基础区别：<br>1、进程是资源分配的最小单位，线程是程序执行的最小单位（资源调度的最小单位）<br>2、进程有自己的独立地址空间，每启动一个进程，系统就会为它分配地址空间，建立数据表来维护代码段、堆栈段和数据段，这种操作非常昂贵。<br>而线程是共享进程中的数据的，使用相同的地址空间，因此CPU切换一个线程的花费远比进程要小很多，同时创建一个线程的开销也比进程要小很多。<br>3、线程之间的通信更方便，同一进程下的线程共享全局变量、静态变量等数据，而进程之间的通信需要以通信的方式（IPC)进行。不过如何处理好同步与互斥是编写多线程程序的难点。<br>4、但是多进程程序更健壮，多线程程序只要有一个线程死掉，整个进程也死掉了，而一个进程死掉并不会对另外一个进程造成影响，因为进程有自己独立的地址空间。</p><h1 id="二、线程与进程："><a href="#二、线程与进程：" class="headerlink" title="二、线程与进程："></a>二、线程与进程：</h1><p>进程：指在系统中正在运行的一个应用程序；程序一旦运行就是进程；或者更专业化来说：进程是指程序执行时的一个实例，即它是程序已经执行到课中程度的数据结构的汇集。从内核的观点看，进程的目的就是担当分配系统资源（CPU时间、内存等）的基本单位。<br>线程：系统分配处理器时间资源的基本单元，或者说进程之内独立执行的一个单元执行流。进程——资源分配的最小单位，线程——程序执行的最小单位。</p><h2 id="线程进程的区别体现在4个方面：（高级）"><a href="#线程进程的区别体现在4个方面：（高级）" class="headerlink" title="线程进程的区别体现在4个方面：（高级）"></a><strong>线程进程的区别体现在4个方面：（高级）</strong></h2><p>1、因为进程拥有独立的堆栈空间和数据段，所以每当启动一个新的进程必须分配给它独立的地址空间，建立众多的数据表来维护它的代码段、堆栈段和数据段，这对于多进程来说十分“奢侈”，系统开销比较大，而线程不一样，线程拥有独立的栈空间，但是共享数据段，它们彼此之间使用相同的地址空间，共享大部分数据，比进程更节俭，开销比较小，切换速度也比进程快，效率高，但是正由于进程之间独立的特点，使得进程安全性比较高，也因为进程有独立的地址空间，一个进程崩溃后，在保护模式下不会对其它进程产生影响，而线程只是一个进程中的不同执行路径。一个线程死掉就等于整个进程死掉。<br>2、体现在通信机制上面，正因为进程之间互不干扰，相互独立，进程的通信机制相对很复杂，譬如管道，信号，消息队列，共享内存，信号量，套接字等通信机制，而线程由于共享数据段所以通信机制很方便。<br>3、体现在CPU系统上面，线程使得CPU系统更加有效，因为操作系统会保证当线程数不大于CPU数目时，不同的线程运行于不同的CPU上。<br>4、体现在程序结构上，举一个简明易懂的列子：当我们使用进程的时候，我们不自主的使用if else嵌套来判断pid，使得程序结构繁琐，但是当我们使用线程的时候，基本上可以甩掉它，当然程序内部执行功能单元需要使用的时候还是要使用，所以线程对程序结构的改善有很大帮助。</p><h2 id="什么情况下使用进程个线程："><a href="#什么情况下使用进程个线程：" class="headerlink" title="什么情况下使用进程个线程："></a><strong>什么情况下使用进程个线程：</strong></h2><p>1、需要频繁创建销毁的优先使用线程；因为对进程来说创建和销毁一个进程代价是很大的<br>2、线程的切换速度快，所以在需要大量计算，切换频繁时用线程，还有耗时的操作使用线程可提高应用程序的响应<br>3、因为对CPU系统的效率使用上线程更占优，所以可能要发展到多机分布的用进程，多核分布用线程<br>4、并行操作时使用线程，如C/S架构的服务器端并发线程响应用户的请求<br>5、需要更稳定安全时，适合选择进程；需要速度时，选择线程更好<br>        因为我的项目中需要对数据段的数据共享，可以被多个程序所修改，所以使用线程来完成此操作，无需加入复杂的通信机制，使用进程需要添加复杂的通信机制实现数据段的共享，增加了我的代码的繁琐，而且使用线程开销小，项目运行的速度快，效率高。<br>       如果只用进程的话，虽然安全性高，但是对代码的简洁性不好，程序结构繁琐，开销比较大，还需要加入复杂的通信机制，会使得我的项目代码量大大增加，切换速度会变的很慢，执行效率降低不少。。。</p><p><strong>进程和线程的关系：</strong><br>1、一个线程只能属于一个进程，而一个进程可以有多个线程，但至少有一个线程。线程是操作系统可识别的最小执行和调度单位。<br>2、资源分配给进程，同一进程的所有线程共享该进程的所有资源。 同一进程中的多个线程共享代码段(代码和常量)，数据段(全局变量和静态变量)，扩展段(堆存储)。但是每个线程拥有自己的栈段，栈段又叫运行时段，用来存放所有局部变量和临时变量。<br>3、处理机分给线程，即真正在处理机上运行的是线程。<br>4、线程在执行过程中，需要协作同步。不同进程的线程间要利用消息通信的办法实现同步。</p><h1 id="三、-多线程"><a href="#三、-多线程" class="headerlink" title="三、 &nbsp;多线程"></a><strong>三、 &nbsp;多线程</strong></h1><h2 id="多线程一般用在哪些地方？"><a href="#多线程一般用在哪些地方？" class="headerlink" title="多线程一般用在哪些地方？"></a>多线程一般用在哪些地方？</h2><p>1、java多线程一般多用于高并发的地方，如订单状态的修改，可以通过多线程，固定时间执行修改订单状态，还有就是支付方面一般都会用到多线程。</p><p>2、最典型的如：<br>用户注册完成送大礼包/积分之类，且积分等也是另一个系统并比较耗时；且这类任务即使失败也不是特别重要的。<br>后台线程：比如定期执行一些特殊任务，如定期更新配置文件，任务调度（如quartz），一些监控用于定期信息采集等。<br>3、最典型的应用比如tomcat，tomcat内部采用的就是多线程，上百个客户端访问同一个web应用，tomcat接入后都是把后续的处理扔给一个新的线程来处理，这个新的线程最后调用到我们的servlet程序，比如doGet或者doPost方法。</p><p>如果不采用多线程机制，上百个人同时访问一个web应用的时候，tomcat就得排队串行处理了，那样客户端根本是无法忍受那种访问速度的。<br>还有就是需要异步处理的时候，需要使用多线程。比如task a和task b要并行处理，单个线程只能串行处理，先做完task a然后再做task b。如果想要多个task同时执行的话，就必须为每个task分配一个线程，然后通过java虚拟机的线程调度，来同时执行多个任务。比如你的CPU是多核心的话，就可以让一个CPU执行一个线程。如果只有一个CPU的话，底层是按照分时复用的原则，各个线程按照时间片来获得CPU资源。<br>4、特别耗时的操作，如备份数据库，可以开个线程执行备份，然后执行返回，前台不断向后台询问线程执行状态<br>5、一个业务逻辑有很多次的循环，每次循环之间没有影响，比如验证1万条url路径是否存在，正常情况要循环1万次，逐个去验证每一条URL，这样效率会很低，假设验证一条需要1分钟，总共就需要1万分钟，有点恐怖。这时可以用多线程，将1万条URL分成50等份，开50个线程，没个线程只需验证200条，这样所有的线程执行完是远小于1万分钟的。<br>6、需要知道一个任务的执行进度，比如我们常看到的进度条，实现方式可以是在任务中加入一个整型属性变量(这样不同方法可以共享)，任务执行一定程度就给变量值加1，另外开一个线程按时间间隔不断去访问这个变量，并反馈给用户。<br>总之使用多线程就是为了充分利用cpu的资源，提高程序执行效率，当你发现一个业务逻辑执行效率特别低，耗时特别长，就可以考虑使用多线程。不过CPU执行哪个线程的时间和顺序是不确定的，即使设置了线程的优先级，因此使用多线程。</p><p><strong>多线程的优点？</strong><br>1、使用线程可以把占据时间长的程序中的任务放到后台去处理<br>2、用户界面可以更加吸引人，这样比如用户点击了一个按钮去触发某些事件的处理，可以弹出一个进度条来显示处理的进度<br>3、程序的运行速度可能加快<br>4、在一些等待的任务实现上如用户输入、文件读写和网络收发数据等，线程就比较有用了。在这种情况下可以释放一些珍贵的资源如内存占用等等。<br>5、多个线程交替执行，减少或避免因程序阻塞或意外情况造成的响应过慢现象，降低了用户等待的概率。</p><p><strong>多线程的缺点？</strong><br>1、如果有大量的线程,会影响性能,因为操作系统需要在它们之间切换。<br>2、更多的线程需要更多的内存空间。<br>3、程可能会给程序带来更多“bug”，因此要小心使用<br>4、程的中止需要考虑其对程序运行的影响。<br>5、通常块模型数据是在多个线程间共享的，需要防止线程死锁情况的发生</p>]]></content>
      
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SmartPointer</title>
      <link href="/2023/06/27/smartpointer/"/>
      <url>/2023/06/27/smartpointer/</url>
      
        <content type="html"><![CDATA[<h1 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针"></a>智能指针</h1><h1 id="1-裸指针有哪些不好的地方？"><a href="#1-裸指针有哪些不好的地方？" class="headerlink" title="1.裸指针有哪些不好的地方？"></a>1.裸指针有哪些不好的地方？</h1><ol><li>忘记释放资源，导致资源泄漏(常发生内存泄漏);</li><li>同一资源释放多次，导致释放野指针(程序崩溃);</li><li>明明程序代码在后面写了释放资源的代码，但由于程序的逻辑，从中间return回去，导致释放资源的代码并未执行；</li><li>代码运行过程中发生异常，随着异常栈展开，导致释放资源的代码未执行；</li></ol><h1 id="2-智能指针原理："><a href="#2-智能指针原理：" class="headerlink" title="2.智能指针原理："></a>2.智能指针原理：</h1><p>智能指针是利用栈上的对象出作用域自动析构的特征来做到资源的自动释放，把资源释放的代码放到这个对象的析构函数中；用户可以不关注资源如何释放，无论程序逻辑如何运行，正常执行或者异常执行，资源在到期的情况下，一定会释放；</p><p>面试题：可以把智能指针放到堆上吗？<strong>智能指针一般定义在栈上</strong>(利用<strong>栈中对象出作用域自动析构</strong>特点)</p><p>CSMartPtr *p = new CSMartPtr(new int);</p><p>这里还是需要手动delete p，如果发生异常了，那么就会内存泄漏所以上面的写法错误，不要把智能指针放到堆上；</p><h1 id="3-不带引用计数的智能指针："><a href="#3-不带引用计数的智能指针：" class="headerlink" title="3.&nbsp;不带引用计数的智能指针："></a>3.&nbsp;不带引用计数的智能指针：</h1><p>auto_ptr,scoped_ptr,unique_ptr</p><h2 id="1-auto-ptr"><a href="#1-auto-ptr" class="headerlink" title="1.auto_ptr :"></a>1.auto_ptr :</h2><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">/*这里是auto_ptr的拷贝构造函数，    _Right.release()函数中，把_Right的_Myptr    赋为nullptr，也就是换成当前auto_ptr持有资源地址    */</span>    <span class="token function">auto_ptr</span><span class="token punctuation">(</span>auto_ptr<span class="token operator">&amp;</span> _Right<span class="token punctuation">)</span> <span class="token keyword">noexcept</span>        <span class="token operator">:</span> <span class="token function">_Myptr</span><span class="token punctuation">(</span>_Right<span class="token punctuation">.</span><span class="token function">release</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>    <span class="token comment">// construct by assuming pointer from _Right auto_ptr</span>        <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>观察auto_ptr的拷贝构造函数我们知道，只有最后一个auto_ptr智能指针持有资源，原来的auto_ptr都被赋nullptr了；看下面代码：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">auto_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token function">ptr1</span> <span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">int</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>auto_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token function">ptr2</span><span class="token punctuation">(</span>ptr1<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>结果是:ptr2指向ptr1之前的动态分配的资源，ptr1此时为nullptr，如果再访问ptr1就是访问空指针，很危险； 即auto_ptr永远让最后一个智能指针管理资源，前面的指针都置空; 所以不推荐使用auto_ptr,容器中也不要使用，因为容器经常需要拷贝赋值，那么一个容器有效，另一个容器就成全是空指针了；</p><p>【总结】：auto_ptr智能指针不带引用计数，那么它处理浅拷贝的问题，是直接把前面的auto_ptr都置为nullptr，只让最后一个auto_ptr持有资源。</p><h2 id="2-scoped-ptr"><a href="#2-scoped-ptr" class="headerlink" title="2.scoped_ptr:"></a>2.scoped_ptr:</h2><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">private</span><span class="token operator">:</span>    T <span class="token operator">*</span> px<span class="token punctuation">;</span>    <span class="token comment">/*    私有化拷贝构造函数和赋值函数，这样scoped_ptr的智能指针    对象就不支持这两种操作，从根本上杜绝浅拷贝的发生    */</span>    <span class="token function">scoped_ptr</span><span class="token punctuation">(</span>scoped_ptr <span class="token keyword">const</span> <span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    scoped_ptr <span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span>scoped_ptr <span class="token keyword">const</span> <span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>观察scoped_ptr的源码我们发现，它将拷贝构造函数和拷贝赋值运算符进行私有化了，那么外部就不能调用了，从根本上杜绝了智能指针浅拷贝的发生，即scoped_ptr不能在容器中使用，如果容器相互拷贝和赋值，那么就会出现调用私有的scoped_ptr的拷贝构造函数和拷贝赋值运算符，就会出现编译错误。</p><h2 id="3-unique-ptr"><a href="#3-unique-ptr" class="headerlink" title="3.unique_ptr:"></a>3.unique_ptr:</h2><p>独占式智能指针只推荐使用unique_ptr,不要使用auto_ptr和scoped_ptr了；</p><h3 id="unique-ptr基本用法"><a href="#unique-ptr基本用法" class="headerlink" title="unique_ptr基本用法"></a>unique_ptr基本用法</h3><p>unique_ptr是C++11提供的用于防止内存泄漏的智能指针中的一种实现，独享被管理对象指针所有权的智能指针。unique_ptr对象包装一个原始指针，并负责其生命周期。当该对象被销毁时，会在其析构函数中删除关联的原始指针。</p><p>unique_ptr对象始终是关联的原始指针的唯一所有者，实现了独享所有权的语义。一个非空的unique_ptr总是拥有它所指向的资源。<strong>转移一个unique_ptr将会把所有权也从源指针转移给目标指针(源指针被置空)<strong>。</strong>拷贝一个unique_ptr将不被允许</strong>，因为如果你拷贝一个unique_ptr，那么拷贝结束后，这两个unique_ptr都会指向相同的资源，它们都认为自己拥有这块资源(所以都会企图释放)。因此unique_ptr是一个仅能移动的类型。当指针析构时，它所拥有的资源也被销毁。默认情况下，资源的析构是伴随着调用unique_ptr内部的原始指针的delete操作的。</p><p>unique_ptr具有-&gt;和*运算符重载符，因此它可以像普通指针一样使用。</p><h3 id="初始化方式"><a href="#初始化方式" class="headerlink" title="初始化方式"></a>初始化方式</h3><h5 id="unique-ptr有如下几种初始化方式："><a href="#unique-ptr有如下几种初始化方式：" class="headerlink" title="unique_ptr有如下几种初始化方式："></a>unique_ptr有如下几种初始化方式：</h5><ol><li><p>裸指针直接初始化，但不能通过隐式转换来构造，因为unique_ptr构造函数被声明为explicit；</p></li><li><p>允许移动构造，但不允许拷贝构造，因为unique_ptr是个只移动类型；</p></li><li><p>通过make_unique构造，但这是C++14才支持的语法。需要注意的是：make_unique不支持添加删除器，或者初始化列表。</p></li></ol><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;memory&gt;</span></span><span class="token keyword">class</span> <span class="token class-name">Frame</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  std<span class="token double-colon punctuation">::</span>unique_ptr<span class="token operator">&lt;</span>Frame<span class="token operator">&gt;</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token function">Frame</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 裸指针直接初始化</span>  std<span class="token double-colon punctuation">::</span>unique_ptr<span class="token operator">&lt;</span>Frame<span class="token operator">&gt;</span> f1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">Frame</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// Error，explicit禁止隐式初始化</span>  std<span class="token double-colon punctuation">::</span>unique_ptr<span class="token operator">&lt;</span>Frame<span class="token operator">&gt;</span> <span class="token function">f2</span><span class="token punctuation">(</span>f<span class="token punctuation">)</span><span class="token punctuation">;</span>             <span class="token comment">// Error，禁止拷贝构造函数</span>  std<span class="token double-colon punctuation">::</span>unique_ptr<span class="token operator">&lt;</span>Frame<span class="token operator">&gt;</span> f3 <span class="token operator">=</span> f<span class="token punctuation">;</span>            <span class="token comment">// Error，禁止拷贝构造函数</span>  f1 <span class="token operator">=</span> f<span class="token punctuation">;</span>                                   <span class="token comment">// Error，禁止copy赋值运算符重载</span>  std<span class="token double-colon punctuation">::</span>unique_ptr<span class="token operator">&lt;</span>Frame<span class="token operator">&gt;</span> <span class="token function">f4</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token function">move</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token function">Frame</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 移动构造函数</span>  std<span class="token double-colon punctuation">::</span>unique_ptr<span class="token operator">&lt;</span>Frame<span class="token operator">&gt;</span> f5 <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token function">move</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token function">Frame</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// Error，explicit禁止隐式初始化</span>  std<span class="token double-colon punctuation">::</span>unique_ptr<span class="token operator">&lt;</span>Frame<span class="token operator">&gt;</span> <span class="token function">f6</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token function">move</span><span class="token punctuation">(</span>f4<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token comment">// 移动构造函数</span>  std<span class="token double-colon punctuation">::</span>unique_ptr<span class="token operator">&lt;</span>Frame<span class="token operator">&gt;</span> f7 <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token function">move</span><span class="token punctuation">(</span>f6<span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token comment">// move赋值运算符重载</span>   <span class="token comment">// 需要格外关注，unique_ptr创建数组对象的方法。</span>  std<span class="token double-colon punctuation">::</span>unique_ptr<span class="token operator">&lt;</span>Frame<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">&gt;</span> <span class="token function">f8</span><span class="token punctuation">(</span><span class="token keyword">new</span> Frame<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment">// 指向数组</span>  <span class="token keyword">auto</span> f9 <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token generic-function"><span class="token function">make_unique</span><span class="token generic class-name"><span class="token operator">&lt;</span>Frame<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// std::make_unique来创建，C++14后支持</span>  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>了解了这些，运用刚了解的这些特性，试试下面的代码：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;memory&gt;</span></span><span class="token keyword">class</span> <span class="token class-name">Frame</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">fun</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>unique_ptr<span class="token operator">&lt;</span>Frame<span class="token operator">&gt;</span> f<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>std<span class="token double-colon punctuation">::</span>unique_ptr<span class="token operator">&lt;</span>Frame<span class="token operator">&gt;</span> <span class="token function">getfun</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">return</span> std<span class="token double-colon punctuation">::</span><span class="token generic-function"><span class="token function">unique_ptr</span><span class="token generic class-name"><span class="token operator">&lt;</span>Frame<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token function">Frame</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment">// 右值，被移动构造</span>                                                    <span class="token comment">// 就算不是右值，也会被编译器RVO优化掉</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  std<span class="token double-colon punctuation">::</span>unique_ptr<span class="token operator">&lt;</span>Frame<span class="token operator">&gt;</span> <span class="token function">f1</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token function">Frame</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  Frame<span class="token operator">*</span> f2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">Frame</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">fun</span><span class="token punctuation">(</span>f1<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token comment">// Error，禁止拷贝构造函数</span>  <span class="token function">fun</span><span class="token punctuation">(</span>f2<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token comment">// Error，explit禁止隐式转换</span>  <span class="token function">fun</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token function">move</span><span class="token punctuation">(</span>f1<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token comment">// 移动构造函数</span>  std<span class="token double-colon punctuation">::</span>unique_ptr<span class="token operator">&lt;</span>Frame<span class="token operator">&gt;</span> f3 <span class="token operator">=</span> <span class="token function">getfun</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment">// 移动构造函数</span>  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="删除器"><a href="#删除器" class="headerlink" title="删除器"></a>删除器</h3><p>根据unique_ptr的模板类型来看：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">_Tp</span><span class="token punctuation">,</span> <span class="token keyword">typename</span> <span class="token class-name">_Dp</span> <span class="token operator">=</span> default_delete<span class="token operator">&lt;</span>_Tp<span class="token operator">&gt;</span> <span class="token operator">&gt;</span><span class="token keyword">class</span> <span class="token class-name">unique_ptr</span> <span class="token punctuation">{</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>模板参数上，前者为unique_ptr需要关联的原始指针的类型，后者为删除器，默认值为default_delete。也就是说，删除器是unique_ptr类型的组成部分，可以是普通函数指针或lambda表达式。注意，当指定删除器时需要同时指定其类型，即_Dp不可省略，可通过decltype获得。</p><p>删除器的作用就是规定：当unique_ptr对象被销毁时，在其析构函数中释放关联的原始指针的方式。一般情况下，都是通过delete进行释放操作。也就是说，一般情况下，不需要进行指定，使用默认的即可。例如：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;memory&gt;</span></span><span class="token keyword">class</span> <span class="token class-name">Frame</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">myDeleter</span><span class="token punctuation">(</span>Frame<span class="token operator">*</span> p<span class="token punctuation">)</span><span class="token punctuation">{</span>  std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"invoke deleter(Frame*)"</span><span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>  <span class="token keyword">delete</span> p<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  std<span class="token double-colon punctuation">::</span>unique_ptr<span class="token operator">&lt;</span>Frame<span class="token punctuation">,</span> <span class="token keyword">decltype</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>myDeleter<span class="token punctuation">)</span><span class="token operator">&gt;</span> <span class="token function">f1</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token function">Frame</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> myDeleter<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">auto</span> del <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span>Frame<span class="token operator">*</span> p<span class="token punctuation">)</span> <span class="token punctuation">{</span>    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"invoke deleter([](Frame *))"</span><span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>    <span class="token keyword">delete</span> p<span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">;</span>  std<span class="token double-colon punctuation">::</span>unique_ptr<span class="token operator">&lt;</span>Frame<span class="token punctuation">,</span> <span class="token keyword">decltype</span><span class="token punctuation">(</span>del<span class="token punctuation">)</span><span class="token operator">&gt;</span> <span class="token function">f2</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token function">Frame</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> del<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>使用默认的删除器时，unique_ptr对象和原始指针的大小是一样的。当自定义删除器时，如果删除器是函数指针，则unique_ptr对象的大小为8字节。对于函数对象的删除器，unique_ptr对象的大小依赖于存储状态的多少，无状态的函数对象(如不捕获变量的lambda表达式)，其大小为4字节。</p><h3 id="常用操作"><a href="#常用操作" class="headerlink" title="常用操作"></a>常用操作</h3><ul><li><p>u.get()：返回unique_ptr中保存的裸指针；</p></li><li><p>u.reset(…)：重置unique_ptr；</p></li><li><p>u.release()：放弃对指针的控制权，返回裸指针，并将unique_ptr自身置空。需要注意，此函数放弃了控制权但不会释放内存，如果不获取返回值，就丢失了指针，造成内存泄露；</p></li><li><p>u.swap(…)：交换两个unique_ptr所指向的对象。</p></li></ul><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;memory&gt;</span></span><span class="token keyword">class</span> <span class="token class-name">Frame</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  std<span class="token double-colon punctuation">::</span>unique_ptr<span class="token operator">&lt;</span>Frame<span class="token operator">&gt;</span> <span class="token function">f1</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token function">Frame</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  Frame<span class="token operator">*</span> f <span class="token operator">=</span> f1<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  std<span class="token double-colon punctuation">::</span>unique_ptr<span class="token operator">&lt;</span>Frame<span class="token operator">&gt;</span> f2<span class="token punctuation">;</span>  f2<span class="token punctuation">.</span><span class="token function">reset</span><span class="token punctuation">(</span>f1<span class="token punctuation">.</span><span class="token function">release</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  f2<span class="token punctuation">.</span><span class="token function">swap</span><span class="token punctuation">(</span>f1<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>额外需要注意的是：<strong>尽管unique_ptr禁止了拷贝构造和拷贝赋值，但是，nullptr是可以用来赋值的</strong>：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">u <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>       <span class="token comment">//释放u所指向的对象，将u置为空</span>u<span class="token punctuation">.</span><span class="token function">reset</span><span class="token punctuation">(</span><span class="token keyword">nullptr</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// u置为空</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><p>与auto_ptr相比unique_ptr有如下特点：</p><ol><li><p>unique_ptr是一个独享所有权的智能指针，无法进行复制构造、copy赋值操作，只能进行移动操作。无法使两个unique_ptr指向同一个对象；</p></li><li><p>unique_ptr智能指向一个对象，如果当它指向其他对象时，之前所指向的对象会被摧毁；</p></li><li><p>unique_ptr对象会在它们自身被销毁时使用删除器自动删除它们管理的对象；</p></li><li><p>unique_ptr支持创建数组对象方法。</p></li></ol><h3 id="unique-ptr源码剖析"><a href="#unique-ptr源码剖析" class="headerlink" title="unique_ptr源码剖析"></a>unique_ptr源码剖析</h3><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 指向单个类型对象</span><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">_Tp</span><span class="token punctuation">,</span> <span class="token keyword">typename</span> <span class="token class-name">_Dp</span> <span class="token operator">=</span> default_delete<span class="token operator">&lt;</span>_Tp<span class="token operator">&gt;</span> <span class="token operator">&gt;</span><span class="token keyword">class</span> <span class="token class-name">unique_ptr</span><span class="token punctuation">{</span>    <span class="token comment">// 指针类</span>    <span class="token keyword">class</span> <span class="token class-name">_Pointer</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">typedef</span> std<span class="token double-colon punctuation">::</span>tuple<span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">_Pointer</span><span class="token double-colon punctuation">::</span>type<span class="token punctuation">,</span> _Dp<span class="token operator">&gt;</span>  __tuple_type<span class="token punctuation">;</span>    __tuple_type _M_t<span class="token punctuation">;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token comment">// 定义类型别名</span>    <span class="token comment">// 指针类</span>    <span class="token keyword">typedef</span> <span class="token keyword">typename</span> <span class="token class-name">_Pointer</span><span class="token double-colon punctuation">::</span>type pointer<span class="token punctuation">;</span>    <span class="token keyword">typedef</span> _Tp element_type<span class="token punctuation">;</span>    <span class="token comment">// 删除器类</span>    <span class="token keyword">typedef</span> _Dp deleter_type<span class="token punctuation">;</span>    <span class="token keyword">constexpr</span> <span class="token function">unique_ptr</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">noexcept</span> <span class="token operator">:</span> <span class="token function">_M_t</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>         <span class="token keyword">static_assert</span><span class="token punctuation">(</span><span class="token operator">!</span>is_pointer<span class="token operator">&lt;</span>deleter_type<span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span>value<span class="token punctuation">,</span>         <span class="token string">"constructed with null function pointer deleter"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">// 裸指针构造函数，explicit阻止隐式构造</span>    <span class="token keyword">explicit</span> <span class="token function">unique_ptr</span><span class="token punctuation">(</span>pointer __p<span class="token punctuation">)</span> <span class="token keyword">noexcept</span> <span class="token operator">:</span> <span class="token function">_M_t</span><span class="token punctuation">(</span>__p<span class="token punctuation">,</span> <span class="token function">deleter_type</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>         <span class="token punctuation">{</span>        <span class="token keyword">static_assert</span><span class="token punctuation">(</span><span class="token operator">!</span>is_pointer<span class="token operator">&lt;</span>deleter_type<span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span>value<span class="token punctuation">,</span>        <span class="token string">"constructed with null function pointer deleter"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">// 右值引用的拷贝构造函数（移动构造函数）</span>    <span class="token function">unique_ptr</span><span class="token punctuation">(</span>unique_ptr<span class="token operator">&amp;&amp;</span> __u<span class="token punctuation">)</span> <span class="token keyword">noexcept</span>                     <span class="token operator">:</span> <span class="token function">_M_t</span><span class="token punctuation">(</span>__u<span class="token punctuation">.</span><span class="token function">release</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> std<span class="token double-colon punctuation">::</span><span class="token generic-function"><span class="token function">forward</span><span class="token generic class-name"><span class="token operator">&lt;</span>deleter_type<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>__u<span class="token punctuation">.</span><span class="token function">get_deleter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">}</span>    <span class="token comment">// 析构函数</span>    <span class="token operator">~</span><span class="token function">unique_ptr</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">noexcept</span>                                    <span class="token punctuation">{</span>      <span class="token keyword">auto</span><span class="token operator">&amp;</span> __ptr <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token generic-function"><span class="token function">get</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token number">0</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>_M_t<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>__ptr <span class="token operator">!=</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span>        <span class="token function">get_deleter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span>__ptr<span class="token punctuation">)</span><span class="token punctuation">;</span>      __ptr <span class="token operator">=</span> <span class="token function">pointer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">// 右值引用的拷贝赋值运算符（move赋值运算符重载）</span>    unique_ptr<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span>unique_ptr<span class="token operator">&amp;&amp;</span> __u<span class="token punctuation">)</span> <span class="token keyword">noexcept</span>          <span class="token punctuation">{</span>      <span class="token function">reset</span><span class="token punctuation">(</span>__u<span class="token punctuation">.</span><span class="token function">release</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token function">get_deleter</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token generic-function"><span class="token function">forward</span><span class="token generic class-name"><span class="token operator">&lt;</span>deleter_type<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>__u<span class="token punctuation">.</span><span class="token function">get_deleter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">return</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">// 解引用</span>    <span class="token keyword">typename</span> <span class="token class-name">add_lvalue_reference</span><span class="token operator">&lt;</span>element_type<span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span>type <span class="token keyword">operator</span><span class="token operator">*</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span>       <span class="token punctuation">{</span>      <span class="token function">_GLIBCXX_DEBUG_ASSERT</span><span class="token punctuation">(</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token function">pointer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">return</span> <span class="token operator">*</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">// 智能指针-&gt;运算符</span>    pointer <span class="token keyword">operator</span><span class="token operator">-&gt;</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token keyword">noexcept</span>                       <span class="token punctuation">{</span>      <span class="token function">_GLIBCXX_DEBUG_ASSERT</span><span class="token punctuation">(</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token function">pointer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">return</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">// 获得裸指针</span>    pointer <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token keyword">noexcept</span>                              <span class="token punctuation">{</span> <span class="token keyword">return</span> std<span class="token double-colon punctuation">::</span><span class="token generic-function"><span class="token function">get</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token number">0</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>_M_t<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>    <span class="token comment">// 获取删除器</span>    deleter_type<span class="token operator">&amp;</span> <span class="token function">get_deleter</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">noexcept</span>                      <span class="token punctuation">{</span> <span class="token keyword">return</span> std<span class="token double-colon punctuation">::</span><span class="token generic-function"><span class="token function">get</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token number">1</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>_M_t<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>    <span class="token comment">// 类型转换函数，用于条件语句，如if(uniptr)之类</span>    <span class="token keyword">explicit</span> <span class="token keyword">operator</span> <span class="token keyword">bool</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token keyword">noexcept</span>                   <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token function">pointer</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token boolean">false</span> <span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>    <span class="token comment">// 释放指针</span>    pointer <span class="token function">release</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">noexcept</span>                                <span class="token punctuation">{</span>      pointer __p <span class="token operator">=</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      std<span class="token double-colon punctuation">::</span><span class="token generic-function"><span class="token function">get</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token number">0</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>_M_t<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token function">pointer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">return</span> __p<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">// 重置指针</span>    <span class="token keyword">void</span> <span class="token function">reset</span><span class="token punctuation">(</span>pointer __p <span class="token operator">=</span> <span class="token function">pointer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">noexcept</span>              <span class="token punctuation">{</span>      <span class="token keyword">using</span> std<span class="token double-colon punctuation">::</span>swap<span class="token punctuation">;</span>      <span class="token function">swap</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token generic-function"><span class="token function">get</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token number">0</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>_M_t<span class="token punctuation">)</span><span class="token punctuation">,</span> __p<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>__p <span class="token operator">!=</span> <span class="token function">pointer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token function">get_deleter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span>__p<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">// 交换指针</span>    <span class="token keyword">void</span> <span class="token function">swap</span><span class="token punctuation">(</span>unique_ptr<span class="token operator">&amp;</span> __u<span class="token punctuation">)</span> <span class="token keyword">noexcept</span>                       <span class="token punctuation">{</span>      <span class="token keyword">using</span> std<span class="token double-colon punctuation">::</span>swap<span class="token punctuation">;</span>      <span class="token function">swap</span><span class="token punctuation">(</span>_M_t<span class="token punctuation">,</span> __u<span class="token punctuation">.</span>_M_t<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">// 禁止拷贝构造函数</span>    <span class="token function">unique_ptr</span><span class="token punctuation">(</span><span class="token keyword">const</span> unique_ptr<span class="token operator">&amp;</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">delete</span><span class="token punctuation">;</span>    <span class="token comment">// 禁止copy赋值运算符重载      </span>    unique_ptr<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">const</span> unique_ptr<span class="token operator">&amp;</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">delete</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment">// 指向数组类型</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">_Tp</span><span class="token punctuation">,</span> <span class="token keyword">typename</span> <span class="token class-name">_Dp</span><span class="token operator">&gt;</span><span class="token keyword">class</span> <span class="token class-name">unique_ptr</span><span class="token operator">&lt;</span>_Tp<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> _Dp<span class="token operator">&gt;</span><span class="token punctuation">{</span>  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>           <span class="token comment">// 与上文代码类似，省略</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token comment">// 数组[]操作符</span>    <span class="token keyword">typename</span> <span class="token class-name">std</span><span class="token double-colon punctuation">::</span>add_lvalue_reference<span class="token operator">&lt;</span>element_type<span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span>type <span class="token keyword">operator</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span>size_t __i<span class="token punctuation">)</span> <span class="token keyword">const</span>     <span class="token punctuation">{</span>      <span class="token function">_GLIBCXX_DEBUG_ASSERT</span><span class="token punctuation">(</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token function">pointer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">return</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">[</span>__i<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol><li><p>unique_ptr的构造函数被声明为explicit，禁止隐式类型转换的行为。可避免将一个普通指针传递给形参为智能指针的函数。假设，如果允许将裸指针传给void foo(std::unique_ptr<t>)函数，则在函数结束后会因形参超出作用域，裸指针将被delete的误操作；</t></p></li><li><p>unique_ptr的拷贝构造和拷贝赋值均被声明为delete。因此无法实施拷贝和赋值操作，但可以移动构造和移动赋值；</p></li><li><p>删除器是unique_ptr类型的一部分。默认为std::default_delete，内部是通过调用delete来实现；</p></li><li><p>unique_ptr可以指向数组，并重载了operator []运算符。</p></li></ol><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><h4 id="工厂函数"><a href="#工厂函数" class="headerlink" title="工厂函数"></a>工厂函数</h4><p>作为工厂函数的返回类型：</p><ol><li><p>工厂函数负责在堆上创建对象，但是调用工厂函数的用户才会真正去使用这个对象，并且要负责这个对象生命周期的管理。所以使用unique_ptr是最好的选择。这正好是std::unique_ptr擅长的地方，因为调用者获得了工厂返回的资源的所有权，当unique_ptr析构时，它会自动销毁所拥有的指针；</p></li><li><p>unique_ptr转为shared_ptr很容易，作为工厂函数本身并不知道用户希望所创建的对象的所有权是专有的还是共享的，返回unique_ptr时调用者可以按照需要做变换。</p></li></ol><h4 id="PImpl机制"><a href="#PImpl机制" class="headerlink" title="PImpl机制"></a>PImpl机制</h4><p>Pimpl，英文pointer to implementation，即指向实现的指针。主要思想是将私有数据和函数放入一个单独的类中，并保存在一个实现文件中，然后在头文件中对这个类进行前向声明并保存一个指向该实现类的指针。</p><p>也就是说，将曾经放在主类中的数据成员放到实现类中去，然后通过指针间接地访问那些数据成员。此时主类中存在只有声明而没有定义的类型，也叫非完整类型。</p><p>Pimpl的优点：</p><ol><li><p>信息隐藏，将具体类的实现封装到另一个类里面，使用者只能看到一个向前的声明和对应的指针。除非使用者去修改对应的实现，否则，它将无法知道具体的实现，也就无法通过一些非法的方式去访问。从一定程度上防止了封装的泄漏；</p></li><li><p>降低耦合，包含该类声明的文件也不会因为类实现的改变而重新编译，节约编译时间。</p></li></ol><p>Pimpl的缺点：</p><ol><li><p>需要手动释放资源，可以使用unique_ptr来解决这个缺点；</p></li><li><p>真正执行的操作，需要中间增加一层指针的间接调用，增加开销；通过间接访问，增加了阅读代码的难度，程序员书写代码也变得复杂。</p></li></ol><p>unique_ptr是将左值引用的拷贝构造函数和拷贝赋值运算符删除了，外部不能调用（等同于私有化），防止智能指针浅拷贝问题的发生；但unique_ptr提供了带右值引用的拷贝构造函数和拷贝赋值运算符，这样临时对象就可以使用了，非常有用；</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 示例1</span>unique_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token function">ptr</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//move将左值强转为右值，那么这里调用unique_ptr的带右值引用的拷贝构造函数</span>unique_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> ptr2 <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token function">move</span><span class="token punctuation">(</span>ptr<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 同上，因为ptr2已经存在，所以调用带右值引用的拷贝赋值运算符</span>ptr2 <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token function">move</span><span class="token punctuation">(</span>ptr<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 示例2</span>unique_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token function">test_uniqueptr</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    unique_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token function">ptr1</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> ptr1<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment">//调用test_uniqueptr函数，在return ptr1代码处，调用右值引用的拷贝构造函数，由ptr1拷贝构造ptr </span>    unique_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> ptr <span class="token operator">=</span> <span class="token function">test_uniqueptr</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>那么unique_ptr与scoped_ptr的区别:他们二个都删除了带左值引用的拷贝构造函数和拷贝赋值运算符，但是unique_ptr定义了带右值引用的拷贝构造函数和拷贝赋值运算符；所以可以显式通过std::move, 就可以通过一个unique_ptr指向另一个uniquet_ptr(资源转移),不是二个指向同一对象；而且unique_ptr也可以①：做为函数的形参，传递给它的实参是一个同类型的unique_ptr经过st::move调用右值引用的拷贝构造函数，将拥有权转移；②：当函数返回一个unique_ptr，因为函数内的uniuqe_ptr即将析构，属于临时对象，所以会调用右值引用的拷贝构造函数，所以拥有权会转移给调用端；（因为在函数内返回的是即将要销毁的对象，属于临时对象，所以调用右值引用的拷贝构造函数；）</p><h3 id="自己实现一个简单的unique-ptr"><a href="#自己实现一个简单的unique-ptr" class="headerlink" title="自己实现一个简单的unique_ptr :"></a>自己实现一个简单的unique_ptr :</h3><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span>  <span class="token class-name">T</span><span class="token operator">&gt;</span><span class="token keyword">class</span> <span class="token class-name">CSmartPtr</span><span class="token punctuation">{</span> <span class="token comment">//</span><span class="token keyword">private</span><span class="token operator">:</span>    T<span class="token operator">*</span> mptr<span class="token punctuation">;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token function">CSmartPtr</span><span class="token punctuation">(</span>T<span class="token operator">*</span> ptr <span class="token operator">=</span> <span class="token keyword">nullptr</span>  <span class="token punctuation">)</span><span class="token operator">:</span><span class="token function">mptr</span><span class="token punctuation">(</span>ptr<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token operator">~</span><span class="token function">CSmartPtr</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">delete</span> mptr<span class="token punctuation">;</span>mptr <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span><span class="token punctuation">}</span>    <span class="token function">CSmartPtr</span><span class="token punctuation">(</span><span class="token keyword">const</span> CSmartPtr<span class="token operator">&amp;</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">delete</span> <span class="token punctuation">;</span>     <span class="token comment">//删除左值引用的拷贝构造函数</span>    CSmartPtr<span class="token operator">&amp;</span> <span class="token keyword">operator</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">const</span> CSmartPtr<span class="token operator">&amp;</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">delete</span> <span class="token punctuation">;</span>    <span class="token comment">//删除左值引用的拷贝赋值运算符</span>    <span class="token comment">//需要定义带右值引用的拷贝构造函数和拷贝赋值运算符</span>    <span class="token function">CSmartPtr</span><span class="token punctuation">(</span>CSmartPtr<span class="token operator">&amp;&amp;</span> rhs<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token keyword">this</span> <span class="token operator">==</span> <span class="token operator">&amp;</span>rhs<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token punctuation">;</span> <span class="token comment">//检测自我赋值</span>        mptr <span class="token operator">=</span> rhs<span class="token punctuation">.</span>mptr<span class="token punctuation">;</span> rhs<span class="token punctuation">.</span>mptr <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">void</span> <span class="token keyword">operator</span> <span class="token operator">=</span><span class="token punctuation">(</span>CSmartPtr<span class="token operator">&amp;&amp;</span> rhs<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token keyword">this</span> <span class="token operator">==</span> <span class="token operator">&amp;</span>rhs<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token punctuation">;</span> <span class="token comment">//检测自我赋值</span>        mptr <span class="token operator">=</span> rhs<span class="token punctuation">.</span>mptr<span class="token punctuation">;</span>rhs<span class="token punctuation">.</span>mptr <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>     T<span class="token operator">&amp;</span> <span class="token keyword">operator</span> <span class="token operator">*</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">return</span> <span class="token operator">*</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span> <span class="token comment">//返回引用，因为要改变指针指定内存上的值</span>    <span class="token keyword">const</span> T<span class="token operator">&amp;</span> <span class="token keyword">operator</span> <span class="token operator">*</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">const</span> <span class="token punctuation">{</span><span class="token keyword">return</span> <span class="token operator">*</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>    T<span class="token operator">*</span> <span class="token keyword">operator</span> <span class="token operator">-&gt;</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">;</span><span class="token punctuation">}</span>     <span class="token keyword">const</span> T<span class="token operator">*</span> <span class="token keyword">operator</span> <span class="token operator">-&gt;</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">const</span> <span class="token punctuation">{</span><span class="token keyword">return</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>    <span class="token comment">//return &amp;(operator *());通常用operator*实现operator-&gt;</span>    T<span class="token operator">*</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">return</span> mptr<span class="token punctuation">;</span><span class="token punctuation">}</span> <span class="token comment">//获得指针指针的底层指针</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面这段代码就是一个简单的智能指针，主要用到了这二点：</p><ol><li><p>智能指针体现在对裸指针进行了一层面向对象的封装，将指针定义为类的成员，在构造函数中初始化资源地址，在析构函数中释放资源；</p></li><li><p>利用栈上的对象出作用域会自动析构这个特点，那么对象生命周期结束后会自动调用析构函数释放资源，从而避免资源泄漏；</p></li></ol><h1 id="4-带引用计数的智能指针-：-shared-ptr和weak-ptr"><a href="#4-带引用计数的智能指针-：-shared-ptr和weak-ptr" class="headerlink" title="4.带引用计数的智能指针 ： shared_ptr和weak_ptr"></a>4.带引用计数的智能指针 ： shared_ptr和weak_ptr</h1><p>带引用计数的智能指针：多个指针可以管理同一个资源：shapred_ptr,weak_ptr;</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当允许多个智能指针指向同一个资源的时候，每一个智能指针都会给资源的引用计数加1，当一个智能指针析构时，同样会使资源的引用计数减1，这样最后一个智能指针把资源的引用计数从1减到0时，就说明该资源可以释放了，由最后一个智能指针的析构函数来处理资源的释放问题，这就是引用计数的概念。这样能够保证在最后一个指向资源的shapred_ptr离开作用域后保证释放资源，而多个shapred_ptr指向同一个资源时候，一个shapred_ptr的析构不会将释放资源，即不会影响其他shared_ptr;通常情况下资源默认删除是delete,也可以自定义删除器来处理如果释放资源；</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;要对资源的引用个数进行计数，那么大家知道，对于整数的++或者- -操作，它并不是线程安全的操作，因此shared_ptr和weak_ptr底层的引用计数已经通过CAS操作，保证了引用计数加减的原子特性，因此shared_ptr和weak_ptr本身就是线程安全的带引用计数的智能指针。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;曾经有一道面试的问题这样问“shared_ptr智能指针的<strong>引用计数在哪里存放</strong>？资源引用计数存放在<strong>堆</strong>内存上。</p><p>它遵循共享所有权的概念，即不同的 shared_ptr 对象可以与相同的指针相关联，并在内部使用引用计数机制来实现这一点。<br><strong>每个 shared_ptr 对象在内部指向两个内存位置：</strong><br>1、指向对象的指针。<br>2、用于控制引用计数数据的指针。</p><p>共享所有权如何在参考计数的帮助下工作：<br>1、当新的 shared_ptr 对象与指针关联时，则在其构造函数中，将与此指针关联的引用计数增加1。<br>2、当任何 shared_ptr 对象超出作用域时，则在其析构函数中，它将关联指针的引用计数减1。如果引用计数变为0，则表示没有其他 shared_ptr 对象与此内存关联，在这种情况下，它使用delete函数删除该内存。</p><h2 id="创建-shared-ptr-对象"><a href="#创建-shared-ptr-对象" class="headerlink" title="创建 shared_ptr 对象"></a>创建 shared_ptr 对象</h2><h3 id="使用原始指针创建-shared-ptr-对象"><a href="#使用原始指针创建-shared-ptr-对象" class="headerlink" title="使用原始指针创建 shared_ptr 对象"></a>使用原始指针创建 shared_ptr 对象</h3><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">std<span class="token double-colon punctuation">::</span>shared_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token function">p1</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>上面这行代码在堆上创建了两块内存：1：存储<code>int</code>。2：用于引用计数的内存，管理附加此内存的 shared_ptr 对象的计数，最初计数将为1。</p><p><strong>检查 shared_ptr 对象的引用计数</strong></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">p1<span class="token punctuation">.</span><span class="token function">use_count</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="创建空的-shared-ptr-对象"><a href="#创建空的-shared-ptr-对象" class="headerlink" title="创建空的 shared_ptr 对象"></a>创建空的 shared_ptr 对象</h3><p>因为带有参数的 shared_ptr 构造函数是 explicit 类型的，所以不能像这样<code>std::shared_ptr&lt;int&gt; p1 = new int();</code>隐式调用它构造函数。创建新的shared_ptr对象的最佳方法是使用<strong>std :: make_shared</strong>：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">std<span class="token double-colon punctuation">::</span>shared_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> p1 <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token generic-function"><span class="token function">make_shared</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>std::make_shared</strong>&nbsp;一次性为<code>int</code>对象和用于引用计数的数据都分配了内存，而<code>new</code>操作符只是为<code>int</code>分配了内存。</p><h2 id="分离关联的原始指针"><a href="#分离关联的原始指针" class="headerlink" title="分离关联的原始指针"></a>分离关联的原始指针</h2><p>要使 shared_ptr 对象取消与相关指针的关联，可以使用<code>reset()</code>函数：</p><p><strong>不带参数的reset()：</strong></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">p1<span class="token punctuation">.</span><span class="token function">reset</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>它将引用计数减少1，如果引用计数变为0，则删除指针。</p><p><strong>带参数的reset()：</strong></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">p1<span class="token punctuation">.</span><span class="token function">reset</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">34</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在这种情况下，它将在内部指向新指针，因此其引用计数将再次变为1。</p><p><strong>使用nullptr重置：</strong></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">p1 <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span> <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="shared-ptr是一个伪指针"><a href="#shared-ptr是一个伪指针" class="headerlink" title="shared_ptr是一个伪指针"></a>shared_ptr是一个伪指针</h2><p>shared_ptr充当普通指针，我们可以将<code>*</code>和<code>-&gt;</code>与 shared_ptr 对象一起使用，也可以像其他 shared_ptr 对象一样进行比较;</p><h2 id="完整示例"><a href="#完整示例" class="headerlink" title="完整示例"></a>完整示例</h2><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span>  <span class="token string">&lt;memory&gt;</span> <span class="token comment">// 需要包含这个头文件</span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment">// 使用 make_shared 创建空对象</span>    std<span class="token double-colon punctuation">::</span>shared_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> p1 <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token generic-function"><span class="token function">make_shared</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">*</span>p1 <span class="token operator">=</span> <span class="token number">78</span><span class="token punctuation">;</span>    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"p1 = "</span> <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span>p1 <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span> <span class="token comment">// 输出78</span>    <span class="token comment">// 打印引用个数：1</span>    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"p1 Reference count = "</span> <span class="token operator">&lt;&lt;</span> p1<span class="token punctuation">.</span><span class="token function">use_count</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>    <span class="token comment">// 第2个 shared_ptr 对象指向同一个指针</span>    std<span class="token double-colon punctuation">::</span>shared_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token function">p2</span><span class="token punctuation">(</span>p1<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 下面两个输出都是：2</span>    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"p2 Reference count = "</span> <span class="token operator">&lt;&lt;</span> p2<span class="token punctuation">.</span><span class="token function">use_count</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"p1 Reference count = "</span> <span class="token operator">&lt;&lt;</span> p1<span class="token punctuation">.</span><span class="token function">use_count</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>    <span class="token comment">// 比较智能指针，p1 等于 p2</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>p1 <span class="token operator">==</span> p2<span class="token punctuation">)</span> <span class="token punctuation">{</span>        std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"p1 and p2 are pointing to same pointer\n"</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    std<span class="token double-colon punctuation">::</span>cout<span class="token operator">&lt;&lt;</span><span class="token string">"Reset p1 "</span><span class="token operator">&lt;&lt;</span>std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>    <span class="token comment">// 无参数调用reset，无关联指针，引用个数为0</span>    p1<span class="token punctuation">.</span><span class="token function">reset</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"p1 Reference Count = "</span> <span class="token operator">&lt;&lt;</span> p1<span class="token punctuation">.</span><span class="token function">use_count</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>    <span class="token comment">// 带参数调用reset，引用个数为1</span>    p1<span class="token punctuation">.</span><span class="token function">reset</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"p1  Reference Count = "</span> <span class="token operator">&lt;&lt;</span> p1<span class="token punctuation">.</span><span class="token function">use_count</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>    <span class="token comment">// 把对象重置为NULL，引用计数为0</span>    p1 <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"p1  Reference Count = "</span> <span class="token operator">&lt;&lt;</span> p1<span class="token punctuation">.</span><span class="token function">use_count</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>p1<span class="token punctuation">)</span> <span class="token punctuation">{</span>        std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"p1 is NULL"</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span> <span class="token comment">// 输出</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="自定义删除器-Deleter"><a href="#自定义删除器-Deleter" class="headerlink" title="自定义删除器 Deleter"></a>自定义删除器 Deleter</h2><p>下面将讨论如何将自定义删除器与 std :: shared_ptr 一起使用。<br>当 shared_ptr 对象超出范围时，将调用其析构函数。在其析构函数中，它将引用计数减1，如果引用计数的新值为0，则删除关联的原始指针。<br>析构函数中删除内部原始指针，默认调用的是delete()函数。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">delete</span> Pointer<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>有些时候在析构函数中，delete函数并不能满足我们的需求，可能还想加其他的处理。</p><h3 id="当-shared-ptr-对象指向数组"><a href="#当-shared-ptr-对象指向数组" class="headerlink" title="当 shared_ptr 对象指向数组"></a>当 shared_ptr 对象指向数组</h3><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 需要添加自定义删除器的使用方式</span>std<span class="token double-colon punctuation">::</span>shared_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token function">p3</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token number">12</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// 仅用于演示自定义删除器</span><span class="token comment">// 指向数组的智能指针可以使用这种形式</span>std<span class="token double-colon punctuation">::</span>shared_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">&gt;</span> <span class="token function">p3</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token number">12</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 正确使用方式</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>像这样申请的数组，应该调用<code>delete []</code>释放内存，而<code>shared_ptr&lt;int&gt;</code>析构函数中默认<code>delete</code>并不能满足需，可以使用<code>shared_ptr&lt;int[]&gt;</code>形式或者添加自定义删除器。</p><h3 id="给shared-ptr添加自定义删除器"><a href="#给shared-ptr添加自定义删除器" class="headerlink" title="给shared_ptr添加自定义删除器"></a>给shared_ptr添加自定义删除器</h3><p>在上面在这种情况下，我们可以将回调函数传递给 shared_ptr 的构造函数，该构造函数将从其析构函数中调用以进行删除，即</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 自定义删除器</span><span class="token keyword">void</span> <span class="token function">deleter</span><span class="token punctuation">(</span>Sample <span class="token operator">*</span> x<span class="token punctuation">)</span><span class="token punctuation">{</span>    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"DELETER FUNCTION CALLED\n"</span><span class="token punctuation">;</span>    <span class="token keyword">delete</span><span class="token punctuation">[</span><span class="token punctuation">]</span> x<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">// 构造函数传递自定义删除器指针</span>std<span class="token double-colon punctuation">::</span>shared_ptr<span class="token operator">&lt;</span>Sample<span class="token operator">&gt;</span> <span class="token function">p3</span><span class="token punctuation">(</span><span class="token keyword">new</span> Sample<span class="token punctuation">[</span><span class="token number">12</span><span class="token punctuation">]</span><span class="token punctuation">,</span> deleter<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>下面看一个完整的示例：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;memory&gt;</span></span><span class="token keyword">struct</span> <span class="token class-name">Sample</span><span class="token punctuation">{</span>    <span class="token function">Sample</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Sample\n"</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token operator">~</span><span class="token function">Sample</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"~Sample\n"</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">deleter</span><span class="token punctuation">(</span>Sample <span class="token operator">*</span> x<span class="token punctuation">)</span><span class="token punctuation">{</span>    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Custom Deleter\n"</span><span class="token punctuation">;</span>    <span class="token keyword">delete</span><span class="token punctuation">[</span><span class="token punctuation">]</span> x<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    std<span class="token double-colon punctuation">::</span>shared_ptr<span class="token operator">&lt;</span>Sample<span class="token operator">&gt;</span> <span class="token function">p3</span><span class="token punctuation">(</span><span class="token keyword">new</span> Sample<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span> deleter<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="使用Lambda-表达式-函数对象作为删除器"><a href="#使用Lambda-表达式-函数对象作为删除器" class="headerlink" title="使用Lambda 表达式 / 函数对象作为删除器"></a>使用Lambda 表达式 / 函数对象作为删除器</h3><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Deleter</span><span class="token punctuation">{</span>    <span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">void</span> <span class="token keyword">operator</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>Sample <span class="token operator">*</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>        std<span class="token double-colon punctuation">::</span>cout<span class="token operator">&lt;&lt;</span><span class="token string">"DELETER FUNCTION CALLED\n"</span><span class="token punctuation">;</span>        <span class="token keyword">delete</span><span class="token punctuation">[</span><span class="token punctuation">]</span> x<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment">// 函数对象作为删除器</span>std<span class="token double-colon punctuation">::</span>shared_ptr<span class="token operator">&lt;</span>Sample<span class="token operator">&gt;</span> <span class="token function">p3</span><span class="token punctuation">(</span><span class="token keyword">new</span> Sample<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token function">Deleter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// Lambda表达式作为删除器</span>std<span class="token double-colon punctuation">::</span>shared_ptr<span class="token operator">&lt;</span>Sample<span class="token operator">&gt;</span> <span class="token function">p4</span><span class="token punctuation">(</span><span class="token keyword">new</span> Sample<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span>Sample <span class="token operator">*</span> x<span class="token punctuation">)</span><span class="token punctuation">{</span>    std<span class="token double-colon punctuation">::</span>cout<span class="token operator">&lt;&lt;</span><span class="token string">"DELETER FUNCTION CALLED\n"</span><span class="token punctuation">;</span>        <span class="token keyword">delete</span><span class="token punctuation">[</span><span class="token punctuation">]</span> x<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="shared-ptr-相对于普通指针的优缺点"><a href="#shared-ptr-相对于普通指针的优缺点" class="headerlink" title="shared_ptr 相对于普通指针的优缺点"></a>shared_ptr 相对于普通指针的优缺点</h2><h3 id="缺少-–-–-和-运算符"><a href="#缺少-–-–-和-运算符" class="headerlink" title="缺少 ++, – – 和 [] 运算符"></a>缺少 ++, – – 和 [] 运算符</h3><p>与普通指针相比，shared_ptr仅提供<code>-&gt;</code>&nbsp;、<code>*</code>和<code>==</code>运算符，没有<code>+</code>、<code>-</code>、<code>++</code>、<code>--</code>、<code>[]</code>等运算符。<br>示例：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;iostream&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;memory&gt;</span></span><span class="token keyword">struct</span> <span class="token class-name">Sample</span> <span class="token punctuation">{</span>    <span class="token keyword">void</span> <span class="token function">dummyFunction</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"dummyFunction"</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    std<span class="token double-colon punctuation">::</span>shared_ptr<span class="token operator">&lt;</span>Sample<span class="token operator">&gt;</span> ptr <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token generic-function"><span class="token function">make_shared</span><span class="token generic class-name"><span class="token operator">&lt;</span>Sample<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">(</span><span class="token operator">*</span>ptr<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">dummyFunction</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 正常</span>    ptr<span class="token operator">-&gt;</span><span class="token function">dummyFunction</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 正常</span>    <span class="token comment">// ptr[0]-&gt;dummyFunction(); // 错误方式</span>    <span class="token comment">// ptr++;  // 错误方式</span>    <span class="token comment">//ptr--;  // 错误方式</span>    std<span class="token double-colon punctuation">::</span>shared_ptr<span class="token operator">&lt;</span>Sample<span class="token operator">&gt;</span> <span class="token function">ptr2</span><span class="token punctuation">(</span>ptr<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>ptr <span class="token operator">==</span> ptr2<span class="token punctuation">)</span> <span class="token comment">// 正常</span>        std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"ptr and ptr2 are equal"</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="NULL检测"><a href="#NULL检测" class="headerlink" title="NULL检测"></a>NULL检测</h3><p>当我们创建 shared_ptr 对象而不分配任何值时，它就是空的；普通指针不分配空间的时候相当于一个野指针，指向垃圾空间，且无法判断指向的是否是有用数据。</p><p><strong>shared_ptr 检测空值方法</strong></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">std<span class="token double-colon punctuation">::</span>shared_ptr<span class="token operator">&lt;</span>Sample<span class="token operator">&gt;</span> ptr3<span class="token punctuation">;</span><span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>ptr3<span class="token punctuation">)</span>    std<span class="token double-colon punctuation">::</span>cout<span class="token operator">&lt;&lt;</span><span class="token string">"Yes, ptr3 is empty"</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span><span class="token keyword">if</span><span class="token punctuation">(</span>ptr3 <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>    std<span class="token double-colon punctuation">::</span>cout<span class="token operator">&lt;&lt;</span><span class="token string">"ptr3 is empty"</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span><span class="token keyword">if</span><span class="token punctuation">(</span>ptr3 <span class="token operator">==</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span>    std<span class="token double-colon punctuation">::</span>cout<span class="token operator">&lt;&lt;</span><span class="token string">"ptr3 is empty"</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="创建-shared-ptr-时注意事项"><a href="#创建-shared-ptr-时注意事项" class="headerlink" title="创建 shared_ptr 时注意事项"></a>创建 shared_ptr 时注意事项</h2><h3 id="不要使用同一个原始指针构造-shared-ptr"><a href="#不要使用同一个原始指针构造-shared-ptr" class="headerlink" title="不要使用同一个原始指针构造 shared_ptr"></a>不要使用同一个原始指针构造 shared_ptr</h3><p>创建多个 shared_ptr 的正常方法是使用一个已存在的shared_ptr 进行创建，而不是使用同一个原始指针进行创建。</p><p>示例：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token operator">*</span>num <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">23</span><span class="token punctuation">)</span><span class="token punctuation">;</span>std<span class="token double-colon punctuation">::</span>shared_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token function">p1</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span><span class="token punctuation">;</span>std<span class="token double-colon punctuation">::</span>shared_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token function">p2</span><span class="token punctuation">(</span>p1<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 正确使用方法</span>std<span class="token double-colon punctuation">::</span>shared_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token function">p3</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 不推荐</span>std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"p1 Reference = "</span> <span class="token operator">&lt;&lt;</span> p1<span class="token punctuation">.</span><span class="token function">use_count</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span> <span class="token comment">// 输出 2</span>std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"p2 Reference = "</span> <span class="token operator">&lt;&lt;</span> p2<span class="token punctuation">.</span><span class="token function">use_count</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span> <span class="token comment">// 输出 2</span>std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"p3 Reference = "</span> <span class="token operator">&lt;&lt;</span> p3<span class="token punctuation">.</span><span class="token function">use_count</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span> <span class="token comment">// 输出 1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>假如使用原始指针<code>num</code>创建了p1，又同样方法创建了p3，当p1超出作用域时会调用<code>delete</code>释放<code>num</code>内存，此时num成了悬空指针，当p3超出作用域再次<code>delete</code>的时候就可能会出错。</p><h3 id="不要用栈中的指针构造-shared-ptr-对象"><a href="#不要用栈中的指针构造-shared-ptr-对象" class="headerlink" title="不要用栈中的指针构造 shared_ptr 对象"></a>不要用栈中的指针构造 shared_ptr 对象</h3><p>shared_ptr 默认的构造函数中使用的是<code>delete</code>来删除关联的指针，所以构造的时候也必须使用<code>new</code>出来的堆空间的指针。</p><p>示例：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;iostream&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;memory&gt;</span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>   <span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">12</span><span class="token punctuation">;</span>   std<span class="token double-colon punctuation">::</span>shared_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token function">ptr</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当 shared_ptr 对象超出作用域调用析构函数<code>delete</code>&nbsp;指针<code>&amp;x</code>时会出错。</p><h3 id="建议使用-make-shared"><a href="#建议使用-make-shared" class="headerlink" title="建议使用 make_shared"></a>建议使用 make_shared</h3><p>为了避免以上两种情形，建议使用<code>make_shared()&lt;&gt;</code>创建 shared_ptr 对象，而不是使用默认构造函数创建。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">std<span class="token double-colon punctuation">::</span>shared_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> ptr_1 <span class="token operator">=</span> <span class="token generic-function"><span class="token function">make_shared</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>std<span class="token double-colon punctuation">::</span>shared_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token function">ptr_2</span> <span class="token punctuation">(</span>ptr_1<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>另外不建议使用<code>get()</code>函数获取 shared_ptr 关联的原始指针，因为如果在 shared_ptr 析构之前手动调用了<code>delete</code>函数，同样会导致类似的错误。</p><h2 id="自己实现一个简单的shared-ptr"><a href="#自己实现一个简单的shared-ptr" class="headerlink" title="自己实现一个简单的shared_ptr:"></a>自己实现一个简单的shared_ptr:</h2><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span>  <span class="token class-name">T</span><span class="token operator">&gt;</span><span class="token keyword">class</span> <span class="token class-name">RefCnt</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token function">RefCnt</span><span class="token punctuation">(</span>T<span class="token operator">*</span> ptr <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token operator">:</span><span class="token function">mptr</span><span class="token punctuation">(</span>ptr<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>ptr<span class="token punctuation">)</span> <span class="token punctuation">{</span>            mcount <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">void</span> <span class="token function">delRefCnd</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token operator">--</span>mcount<span class="token punctuation">;</span><span class="token punctuation">}</span> <span class="token comment">//减少资源的引用计数</span>    <span class="token keyword">void</span> <span class="token function">addRef</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token operator">++</span>mcount<span class="token punctuation">;</span> <span class="token punctuation">}</span> <span class="token comment">//增加资源的引用计数</span><span class="token comment">//自己实现的与shared_ptr相比，没有线程安全特性；因为对mcount不是原子操作；</span><span class="token keyword">private</span><span class="token operator">:</span>    T<span class="token operator">*</span> mptr<span class="token punctuation">;</span>    <span class="token keyword">int</span> mcount<span class="token punctuation">;</span> <span class="token comment">// 改进 为 atomic_int CAS  </span>    <span class="token comment">//库中shared_ptr和weak_ptr都是线程安全的，可以在多线程环境下使用；</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span>  <span class="token class-name">T</span><span class="token operator">&gt;</span><span class="token keyword">class</span> <span class="token class-name">CSmartPtr</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token function">CSmartPtr</span><span class="token punctuation">(</span>T<span class="token operator">*</span> ptr <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token operator">:</span><span class="token function">mptr</span><span class="token punctuation">(</span>ptr<span class="token punctuation">)</span> <span class="token punctuation">{</span>        mpRefCnt <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token generic-function"><span class="token function">RefCnt</span><span class="token generic class-name"><span class="token operator">&lt;</span>T<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>mptr<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token operator">~</span><span class="token function">CSmartPtr</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token number">0</span> <span class="token operator">==</span> mpRefCnt<span class="token operator">-&gt;</span><span class="token function">delRefCnt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">delete</span> mptr<span class="token punctuation">;</span>            mptr <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token function">CSmartPtr</span><span class="token punctuation">(</span><span class="token keyword">const</span> CSmartPtr<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token operator">&amp;</span> src<span class="token punctuation">)</span> <span class="token operator">:</span><span class="token function">mptr</span><span class="token punctuation">(</span>src<span class="token punctuation">.</span>mptr<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">mpRefCnt</span><span class="token punctuation">(</span>src<span class="token punctuation">.</span>mpRefCnt<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>mptr<span class="token punctuation">)</span> <span class="token punctuation">{</span>            mpRefCnt<span class="token operator">-&gt;</span><span class="token function">addRef</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    CSmartPtr<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">const</span> CSmartPtr<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token operator">&amp;</span> src<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span> <span class="token operator">==</span> <span class="token operator">&amp;</span>src<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>mpRefCnt<span class="token operator">-&gt;</span><span class="token function">delRefCnt</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">delete</span> mptr<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        mptr <span class="token operator">=</span> src<span class="token punctuation">.</span>mptr<span class="token punctuation">;</span>        mpRefCnt <span class="token operator">=</span> src<span class="token punctuation">.</span>mpRefCnt<span class="token punctuation">;</span>        mpRefCnt<span class="token operator">-&gt;</span><span class="token function">addRef</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    T<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">*</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token operator">*</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>    T<span class="token operator">*</span> <span class="token keyword">operator</span><span class="token operator">-&gt;</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>    T<span class="token operator">*</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> mptr<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token keyword">private</span><span class="token operator">:</span>    RefCnt<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token operator">*</span> mpRefCnt<span class="token punctuation">;</span> <span class="token comment">//指向该资源引用计数对象的指针</span>    T<span class="token operator">*</span> mptr<span class="token punctuation">;</span> <span class="token comment">//指向资源的指针</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="智能指针的交叉引用-循环引用-问题-："><a href="#智能指针的交叉引用-循环引用-问题-：" class="headerlink" title="智能指针的交叉引用(循环引用)问题 ："></a>智能指针的交叉引用(循环引用)问题 ：</h2><p><strong>shared_ptr:强智能指针</strong>，可以改变资源的引用计数；</p><p><strong>weak_ptr:弱引用指针</strong>，不会改变资源的引用计数，辅助shared_ptr工作的，防止循环引用；</p><p>注意：弱智能指针只是资源的观察者，它是不能直接使用资源的，不会增加引用计数，它没有提供*,-&gt;运算符重载函数;要通过它访问资源必须通过lock方法，得到一个强智能指针，然后就可以使用资源了；</p><p>强指针指针循环引用(交叉引用)是什么问题？什么结果？怎么解决？</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">B</span><span class="token punctuation">;</span> <span class="token comment">//类的前置声明</span><span class="token keyword">class</span> <span class="token class-name">A</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token function">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> cout <span class="token operator">&lt;&lt;</span> <span class="token string">"A()"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token punctuation">}</span>    <span class="token operator">~</span><span class="token function">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> cout <span class="token operator">&lt;&lt;</span> <span class="token string">"~A()"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token punctuation">}</span>    shared_ptr<span class="token operator">&lt;</span>B<span class="token operator">&gt;</span> _ptrb<span class="token punctuation">;</span><span class="token comment">//指向B对象的智能指针</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">B</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token function">B</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> cout <span class="token operator">&lt;&lt;</span> <span class="token string">"B()"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token punctuation">}</span>    <span class="token operator">~</span><span class="token function">B</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> cout <span class="token operator">&lt;&lt;</span> <span class="token string">"~B()"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token punctuation">}</span>    shared_ptr<span class="token operator">&lt;</span>A<span class="token operator">&gt;</span> _ptra<span class="token punctuation">;</span> <span class="token comment">//指向A对象的智能指针</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    shared_ptr<span class="token operator">&lt;</span>A<span class="token operator">&gt;</span> <span class="token function">pa</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token function">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//pa指向A对象，A的引用计数为1</span>    shared_ptr<span class="token operator">&lt;</span>B<span class="token operator">&gt;</span> <span class="token function">pb</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token function">B</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//pb指向B对象，B的引用计数为1</span>    pa<span class="token operator">-&gt;</span>_ptrb <span class="token operator">=</span> pb<span class="token punctuation">;</span> <span class="token comment">//A对象的成员变量ptrb指向B对象，B的引用计数为2</span>    pb<span class="token operator">-&gt;</span>_ptra <span class="token operator">=</span> pa<span class="token punctuation">;</span><span class="token comment">//B对象的成员变量ptra指向A对象，A的引用计数为2</span>         cout <span class="token operator">&lt;&lt;</span> pa<span class="token punctuation">.</span><span class="token function">use_count</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token comment">//A对象的引用计数是2</span>         cout <span class="token operator">&lt;&lt;</span> pb<span class="token punctuation">.</span><span class="token function">use_count</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token comment">//B对象的引用计数是2</span>         <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">//出了main函数作用域后，ptra和ptrb二个局部对象析构，分别给A对象和B对象的引用计数从2减到1，</span><span class="token comment">//此时A对象中的ptrb和B对象中的ptra互相引用了，所以二个new出来的对象无法释放，内存泄漏；</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>怎么解决循环引用问题呢？<strong>定义对象的时候使用强智能指针shared_ptr,使用对象的时候使用弱指针指针weak_ptr;</strong></p><p>弱智能指针weak_ptr区别于强智能指针shared_ptr之处在于：</p><ol><li><p>weak_ptr不会改变资源的引用计数，只是一个观察者的角色，通过观察shared_ptr来判定资源是否存在</p></li><li><p>weak_ptr持有的引用计数，不是资源的引用计数，而是同一个资源的观察者的计数</p></li><li><p>weak_ptr没有提供常用的指针操作，无法直接访问资源，需要先通过lock方法提升为shared_ptr强智能指针，才能访问资源</p></li></ol><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">B</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">A</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token function">A</span><span class="token punctuation">(</span><span class="token keyword">int</span> _a<span class="token punctuation">)</span><span class="token operator">:</span><span class="token function">a</span><span class="token punctuation">(</span>_a<span class="token punctuation">)</span> <span class="token punctuation">{</span> cout <span class="token operator">&lt;&lt;</span> <span class="token string">"A()   a =  "</span><span class="token operator">&lt;&lt;</span>a <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token punctuation">}</span>    <span class="token operator">~</span><span class="token function">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> cout <span class="token operator">&lt;&lt;</span> <span class="token string">"~A()"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token punctuation">}</span>    <span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> cout <span class="token operator">&lt;&lt;</span> <span class="token string">"A的函数"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token punctuation">}</span>    weak_ptr<span class="token operator">&lt;</span>B<span class="token operator">&gt;</span> _ptrb<span class="token punctuation">;</span>    <span class="token keyword">int</span> a<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">B</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token function">B</span><span class="token punctuation">(</span><span class="token keyword">int</span> _b<span class="token punctuation">)</span><span class="token operator">:</span><span class="token function">b</span><span class="token punctuation">(</span>_b<span class="token punctuation">)</span> <span class="token punctuation">{</span> cout <span class="token operator">&lt;&lt;</span> <span class="token string">"B()   b=   "</span><span class="token operator">&lt;&lt;</span>b <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token punctuation">}</span>    <span class="token operator">~</span><span class="token function">B</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> cout <span class="token operator">&lt;&lt;</span> <span class="token string">"~B()"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token punctuation">}</span>    <span class="token comment">//现在b想调用a中的函数呢？</span>    <span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        shared_ptr<span class="token operator">&lt;</span>A<span class="token operator">&gt;</span> sp <span class="token operator">=</span> _ptra<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//weak_ptr通过lock方法发挥一个强指针指针</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>sp<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">//提升成功</span>            sp<span class="token operator">-&gt;</span><span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    weak_ptr<span class="token operator">&lt;</span>A<span class="token operator">&gt;</span> _ptra<span class="token punctuation">;</span>    <span class="token keyword">int</span> b<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    shared_ptr<span class="token operator">&lt;</span>A<span class="token operator">&gt;</span> <span class="token function">pa</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token function">A</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    shared_ptr<span class="token operator">&lt;</span>B<span class="token operator">&gt;</span> <span class="token function">pb</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token function">B</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    pa<span class="token operator">-&gt;</span>_ptrb <span class="token operator">=</span> pb<span class="token punctuation">;</span>    pb<span class="token operator">-&gt;</span>_ptra <span class="token operator">=</span> pa<span class="token punctuation">;</span>    <span class="token comment">//通过pb访问A中的方法</span>    pb<span class="token operator">-&gt;</span><span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span><span class="token string">"用pa访问pb中的b:"</span><span class="token operator">&lt;&lt;</span> pa<span class="token operator">-&gt;</span>_ptrb<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-&gt;</span>b <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"用pb访问pa中的a:"</span><span class="token operator">&lt;&lt;</span>pb<span class="token operator">-&gt;</span>_ptra<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-&gt;</span>a <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> pa<span class="token punctuation">.</span><span class="token function">use_count</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> pb<span class="token punctuation">.</span><span class="token function">use_count</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="多线程访问共享对象的线程安全问题"><a href="#多线程访问共享对象的线程安全问题" class="headerlink" title="多线程访问共享对象的线程安全问题"></a>多线程访问共享对象的线程安全问题</h2><p>shared_ptr和weak_ptr解决了这样一个问题，多线程访问共享对象的线程安全问题，解释如下：线程A和线程B访问一个共享的对象，如果线程A正在析构这个对象的时候，线程B又要调用该共享对象的成员方法，此时可能线程A已经把对象析构完了，线程B再去访问该对象，就会发生不可预期的错误。</p><p>下面这个多线程程序子线程先睡眠，而主线程已经将p所指向资源释放了，那么子线程再访问那个对象的方法很明显就会出现问题；需要在子线程中先判断指针所指向对象是否有效！！</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">//有问题的代码，么有考虑多线程访问共享对象的线程安全问题</span><span class="token keyword">class</span> <span class="token class-name">A</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token function">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> cout <span class="token operator">&lt;&lt;</span> <span class="token string">"A()"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token punctuation">}</span>    <span class="token operator">~</span><span class="token function">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> cout <span class="token operator">&lt;&lt;</span> <span class="token string">"~A()"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token punctuation">}</span>    <span class="token keyword">void</span> <span class="token function">testA</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> cout <span class="token operator">&lt;&lt;</span> <span class="token string">"A::func()"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">void</span>  <span class="token function">handler01</span><span class="token punctuation">(</span>A<span class="token operator">*</span> q<span class="token punctuation">)</span> <span class="token punctuation">{</span>    std<span class="token double-colon punctuation">::</span>this_thread<span class="token double-colon punctuation">::</span><span class="token function">sleep_for</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>chrono<span class="token double-colon punctuation">::</span><span class="token function">seconds</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//睡眠2秒</span>    q<span class="token operator">-&gt;</span><span class="token function">testA</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">//多线程访问共享对象的线程安全问题：</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    A<span class="token operator">*</span> p <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    thread <span class="token function">t1</span><span class="token punctuation">(</span>handler01<span class="token punctuation">,</span> p<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">delete</span> p<span class="token punctuation">;</span>    t1<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>通过智能指针改进： 注意：为了防止循环引用问题，建议在指针定义的时候使用shared_ptr,在使用指针的时候使用weak_ptr;</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">A</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token function">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> cout <span class="token operator">&lt;&lt;</span> <span class="token string">"A()"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token punctuation">}</span>    <span class="token operator">~</span><span class="token function">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> cout <span class="token operator">&lt;&lt;</span> <span class="token string">"~A()"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token punctuation">}</span>    <span class="token keyword">void</span> <span class="token function">testA</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> cout <span class="token operator">&lt;&lt;</span> <span class="token string">"A::func()"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">void</span>  <span class="token function">handler01</span><span class="token punctuation">(</span>weak_ptr<span class="token operator">&lt;</span>A<span class="token operator">&gt;</span> pw <span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">/* 如果想访问智能指针pw所指对象的方法，先通过lock将弱智能指针weak_ptr提升为强智能指针shared_ptr，提升过程中，是通过检测它所观察的强智能指针的引用计数，来判断对象是否存活；sp如果为nullptr,说明对象已经析构，不能访问；sp不为nullptr,那么可以正常访问对象及其方法；*/</span>    shared_ptr<span class="token operator">&lt;</span>A<span class="token operator">&gt;</span> sp <span class="token operator">=</span> pw<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>sp<span class="token punctuation">)</span> <span class="token punctuation">{</span>        sp<span class="token operator">-&gt;</span><span class="token function">testA</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">else</span> <span class="token punctuation">{</span>        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"对象已经析构，不能调用它的方法了"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment">//多线程访问共享对象的线程安全问题：</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">{</span>        shared_ptr<span class="token operator">&lt;</span>A<span class="token operator">&gt;</span> <span class="token function">p</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token function">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        thread <span class="token function">t1</span><span class="token punctuation">(</span>handler01<span class="token punctuation">,</span><span class="token generic-function"><span class="token function">weak_ptr</span><span class="token generic class-name"><span class="token operator">&lt;</span>A<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        t1<span class="token punctuation">.</span><span class="token function">detach</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//分离线程</span>        std<span class="token double-colon punctuation">::</span>this_thread<span class="token double-colon punctuation">::</span><span class="token function">sleep_for</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>chrono<span class="token double-colon punctuation">::</span><span class="token function">seconds</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//主线程阻塞</span>    <span class="token punctuation">}</span> <span class="token comment">//出了作用域后智能指针p自动释放它指向的资源</span>    std<span class="token double-colon punctuation">::</span>this_thread<span class="token double-colon punctuation">::</span><span class="token function">sleep_for</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>chrono<span class="token double-colon punctuation">::</span><span class="token function">seconds</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//主线程阻塞</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>所以通过shared_ptr和weak_ptr可以解决多线程里面访问共享对象的线程安全问题；因为它可以在线程里面通过对象资源的引用计数来检测对象的生存状态；</p><h2 id="自定义删除器："><a href="#自定义删除器：" class="headerlink" title="自定义删除器："></a>自定义删除器：</h2><p>智能指针的删除器deleter : 智能指针默认释放资源的方式是delete,但并不是所有的资源都是申请的堆内存，所有有时候智能指针默认删除器释放资源就不合适了；比如说申请<a href="https://so.csdn.net/so/search?q=%E6%95%B0%E7%BB%84&amp;spm=1001.2101.3001.7020">数组</a>，文件资源，数据库连接，网络连接等；</p><p>我们如果看了智能指针的源码，就会发现，在智能指针的析构函数里面有对一个函数对象的调用：deleter(ptr) :</p><p>默认的deleter如下：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span>  <span class="token class-name">T</span><span class="token operator">&gt;</span><span class="token keyword">class</span> <span class="token class-name">Deleter</span><span class="token punctuation">{</span> <span class="token comment">//智能指针默认的删除器</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">void</span> <span class="token keyword">operator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span>T<span class="token operator">*</span> ptr<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">delete</span>  ptr<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="当unique-ptr和shared-ptr管理动态分配的数组空间时候的区别："><a href="#当unique-ptr和shared-ptr管理动态分配的数组空间时候的区别：" class="headerlink" title="当unique_ptr和shared_ptr管理动态分配的数组空间时候的区别："></a>当unique_ptr和shared_ptr管理动态分配的数组空间时候的区别：</h3><p>unique_ptr提供了一个偏特化版本来指向动态分配的数组空间，这个版本在对象析构时候会自动调用delete [ ] ; 注意这个偏特化版本的unique_ptr不提供*和-&gt;操作符，而是提供操作符[ ] ,用以访问其指向动态分配数组中的某个对象；unique_ptr up(new string[10]);</p><p>而shared_ptr是不支持直接管理动态分配的数组空间，所以用shared_ptr管理动态分配的数组空间，必须提供自定义的删除器；shared_ptr sp(new int [10],[ ] (int *p){delete [ ] p ;});</p><p>sp.release(); //使用我们的自定义删除器lambda表达式释放数组，调用delete [ ]</p><p>而shapred_ptr未定义下标运算符，而且智能指针类型不支持指针算术操作，所以访问数组元素必须使用get获得内置指针，然后用它来访问数组元素；</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">for</span><span class="token punctuation">(</span>size_t i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">!=</span><span class="token number">10</span><span class="token punctuation">;</span><span class="token operator">++</span>i<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token operator">*</span><span class="token punctuation">(</span>sp<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span>i<span class="token punctuation">)</span> <span class="token operator">=</span> i <span class="token punctuation">;</span> <span class="token comment">//shared_ptr通过get获取内置指针然后访问数组元素</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>当unique_ptr管理的是文件资源，数据库连接，网络连接等，默认删除器是delete就不合适了，需要自定义删除器；</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">//下面用模板实现函数对象作为自定义删除器,但这种方式不好；</span><span class="token comment">//定义一个模板类型仅仅使用在智能指针中，却一直出现在源码中；</span><span class="token keyword">template</span>  <span class="token operator">&lt;</span><span class="token keyword">typename</span>  <span class="token class-name">T</span><span class="token operator">&gt;</span><span class="token keyword">class</span> <span class="token class-name">MyFileDeleter</span><span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">void</span> <span class="token keyword">operator</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span>T<span class="token operator">*</span> ptr<span class="token punctuation">)</span> <span class="token keyword">const</span>    <span class="token punctuation">{</span>        cout<span class="token operator">&lt;&lt;</span><span class="token string">"call MyFileDeleter.operator()"</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>        <span class="token function">fclose</span><span class="token punctuation">(</span>ptr<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span>unique_ptr<span class="token operator">&lt;</span>FILE<span class="token punctuation">,</span>MyFileDeleter<span class="token operator">&lt;</span>FILE <span class="token operator">&gt;&gt;</span> <span class="token function">ptr</span><span class="token punctuation">(</span><span class="token function">fopen</span><span class="token punctuation">(</span><span class="token string">"data.txt"</span><span class="token punctuation">,</span><span class="token string">"w"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以使用<strong>function函数对象</strong>和<strong>lambda表达式</strong>来完成：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">unique_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span>function<span class="token operator">&lt;</span><span class="token keyword">void</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&gt;&gt;</span> <span class="token function">ptr</span> <span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">int</span> <span class="token punctuation">[</span><span class="token number">100</span><span class="token punctuation">]</span><span class="token punctuation">,</span>        <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span>p<span class="token punctuation">)</span><span class="token operator">-&gt;</span><span class="token keyword">void</span> <span class="token punctuation">{</span>            cout<span class="token operator">&lt;&lt;</span><span class="token string">"call labmda release new int [100]"</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>            <span class="token keyword">delete</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> p<span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>unique_ptr<span class="token operator">&lt;</span>FILE <span class="token punctuation">,</span>function<span class="token operator">&lt;</span><span class="token keyword">void</span><span class="token punctuation">(</span>FILE<span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&gt;&gt;</span> <span class="token function">ptr2</span><span class="token punctuation">(</span><span class="token function">fopen</span><span class="token punctuation">(</span><span class="token string">"data.txt"</span><span class="token punctuation">,</span><span class="token string">"w"</span><span class="token punctuation">)</span><span class="token punctuation">,</span>        <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span>FILE<span class="token operator">*</span> p<span class="token punctuation">)</span><span class="token operator">-&gt;</span><span class="token keyword">void</span> <span class="token punctuation">{</span>            cout<span class="token operator">&lt;&lt;</span><span class="token string">"call lambda relsease new fopen"</span> <span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>            <span class="token function">fclose</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="效率与灵活性：-编译时绑定删除器和运行时绑定删除器："><a href="#效率与灵活性：-编译时绑定删除器和运行时绑定删除器：" class="headerlink" title="效率与灵活性： 编译时绑定删除器和运行时绑定删除器："></a><strong>效率与灵活性： 编译时绑定删除器和运行时绑定删除器</strong>：</h2><p> shared_ptr和unique_ptr之间明显不同的就是他们管理所保存的指针的策略，shared_ptr是共享式智能指针，unique_ptr是独占式智能指针；另一个差异是它们允许用户重载默认删除器的方式；我们可以很容易重载一个shared_ptr的删除器，只要在创建或者reset指针时传递它一个可调用对象即可；与之相反，删除器的类型是一个unique_ptr对象的类型的一部分。用户必须在定义unique_ptr时以显式模板实参的形式提供删除器的类型，因此，对于unique_ptr的用户来说，提供自己的删除器就更为复杂；</p><p>运行时绑定删除器：</p><p>在一个shared_ptr的生命周期内，可以随时改变删除器的类型；因为删除器类型是变化的，类成员的类型在运行时是不能改变的，所以不能直接保存删除器，只能间接保存删除器，所以调用shared_ptr的删除器会有运行时开销；</p><p>编译时绑定删除器：</p><p>对unique_ptr而言，删除器的类型是类类型的一部分，即unique_ptr有二个模板参数，一个表示它所管理的指针，另一个表示删除器的类型；由于删除器的类型是unique_ptr类型的一部分，因此删除器成员的类型在编译器时是知道的，从而删除器可以直接保存在unique_ptr对象中；编译器就知道执行删除器的代码，实际上删除器调用有可能会编译为内联形式，那么效率更高；</p><p><strong>总结</strong>：</p><p>通过在编译时绑定删除器，unique_ptr的删除器调用效率很高，但删除器不可更改；</p><p>通过在运行时绑定删除器，shared_ptr使用户重载删除器更加方便，但是会有间接调用删除器的运行时开销；</p><h2 id="shared-from-this类和enable-shared-from-this函数；"><a href="#shared-from-this类和enable-shared-from-this函数；" class="headerlink" title="shared_from_this类和enable_shared_from_this函数；"></a>shared_from_this类和enable_shared_from_this函数；</h2><p>先给出两个智能指针的应用场景代码，都是有问题的，仔细思考一下问题的原因。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token comment">// 智能指针测试类</span><span class="token keyword">class</span> <span class="token class-name">A</span><span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token function">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span><span class="token function">mptr</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">)</span>     <span class="token punctuation">{</span>        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"A()"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token operator">~</span><span class="token function">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"~A()"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>        <span class="token keyword">delete</span> mptr<span class="token punctuation">;</span>         mptr <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token keyword">private</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token operator">*</span>mptr<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    A <span class="token operator">*</span>p <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 裸指针指向堆上的对象</span>    shared_ptr<span class="token operator">&lt;</span>A<span class="token operator">&gt;</span> <span class="token function">ptr1</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 用shared_ptr智能指针管理指针p指向的对象</span>    shared_ptr<span class="token operator">&lt;</span>A<span class="token operator">&gt;</span> <span class="token function">ptr2</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 用shared_ptr智能指针管理指针p指向的对象</span>    <span class="token comment">// 下面两次打印都是1</span>    cout <span class="token operator">&lt;&lt;</span> ptr1<span class="token punctuation">.</span><span class="token function">use_count</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>     cout <span class="token operator">&lt;&lt;</span> ptr2<span class="token punctuation">.</span><span class="token function">use_count</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">//输出：因为二个智能指针的引用计数都是1，所以在析构会调用二次构造函数，逻辑错误；</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>成员函数错误的直接通过this返回智能指针:</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token comment">// 智能指针测试类</span><span class="token keyword">class</span> <span class="token class-name">A</span><span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token function">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span><span class="token function">mptr</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">)</span>     <span class="token punctuation">{</span>        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"A()"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token operator">~</span><span class="token function">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"~A()"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>        <span class="token keyword">delete</span> mptr<span class="token punctuation">;</span>         mptr <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>     <span class="token comment">//A类提供了一个成员方法，通过this返回指向自身对象的shared_ptr智能指针。</span>    shared_ptr<span class="token operator">&lt;</span>A<span class="token operator">&gt;</span> <span class="token function">getSharedPtr</span><span class="token punctuation">(</span><span class="token punctuation">)</span>     <span class="token punctuation">{</span> <span class="token comment">/*注意：&lt;不能直接返回this，在多线程环境下，根本无法获知this指针指向的对象的生存状态&gt;《通过shared_ptr和weak_ptr可以解决多线程访问共享对象的线程安全问题》 */</span>        <span class="token keyword">return</span> <span class="token generic-function"><span class="token function">shared_ptr</span><span class="token generic class-name"><span class="token operator">&lt;</span>A<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token punctuation">}</span><span class="token keyword">private</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token operator">*</span>mptr<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    shared_ptr<span class="token operator">&lt;</span>A<span class="token operator">&gt;</span> <span class="token function">ptr1</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token function">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    shared_ptr<span class="token operator">&lt;</span>A<span class="token operator">&gt;</span> ptr2 <span class="token operator">=</span> ptr1<span class="token operator">-&gt;</span><span class="token function">getSharedPtr</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//按原先的想法，上面两个智能指针管理的是同一个A对象资源，但是这里打印都是1</span><span class="token comment">//导致出main函数A对象析构两次，析构逻辑有问题</span>    cout <span class="token operator">&lt;&lt;</span> ptr1<span class="token punctuation">.</span><span class="token function">use_count</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>     cout <span class="token operator">&lt;&lt;</span> ptr2<span class="token punctuation">.</span><span class="token function">use_count</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">//代码同样有错误，A对象被析构了两次，而且看似两个shared_ptr指向了同一个A对象资源，</span><span class="token comment">//但是资源计数并没有记录成2，还是1，不正确。</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如何解决上面的问题呢？我们从底层源码分析：</p><p>shared_ptr原理分析：</p><p>源码上shared_ptr的定义如下：template<class _ty=""> class shared_ptr: public _Ptr_base&lt;_Ty&gt;</class></p><p>shared_ptr是从_Ptr_base继承而来的，作为派生类，shared_ptr本身没有提供任何成员变量，但是它从基类_Ptr_base继承来了如下成员变量（只罗列部分源码）：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">_Ty</span><span class="token operator">&gt;</span><span class="token keyword">class</span> <span class="token class-name">_Ptr_base</span><span class="token punctuation">{</span>    <span class="token comment">// base class for shared_ptr and weak_ptr</span><span class="token keyword">protected</span><span class="token operator">:</span>    <span class="token keyword">void</span> <span class="token function">_Decref</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>    <span class="token comment">// decrement reference count</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>_Rep<span class="token punctuation">)</span>            <span class="token punctuation">{</span>            _Rep<span class="token operator">-&gt;</span><span class="token function">_Decref</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token keyword">void</span> <span class="token function">_Decwref</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>    <span class="token comment">// decrement weak reference count</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>_Rep<span class="token punctuation">)</span>            <span class="token punctuation">{</span>            _Rep<span class="token operator">-&gt;</span><span class="token function">_Decwref</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token keyword">private</span><span class="token operator">:</span>    <span class="token comment">// _Ptr_base的两个成员变量，这里只罗列了_Ptr_base的部分代码</span>    element_type <span class="token operator">*</span> _Ptr<span class="token punctuation">{</span><span class="token keyword">nullptr</span><span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment">// 指向资源的指针</span>    _Ref_count_base <span class="token operator">*</span> _Rep<span class="token punctuation">{</span><span class="token keyword">nullptr</span><span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment">// 指向资源引用计数的指针</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>_Ref_count_base 记录资源引用计数的类是怎么定义的呢，如下（只罗列部分源码）：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">__declspec</span><span class="token punctuation">(</span>novtable<span class="token punctuation">)</span> _Ref_count_base    <span class="token punctuation">{</span>    <span class="token comment">// common code for reference counting</span><span class="token keyword">private</span><span class="token operator">:</span>    <span class="token comment">/* _Uses记录了资源的引用计数，也就是引用资源的shared_ptr    的个数；_Weaks记录了weak_ptr的个数，相当于资源观察者的    个数，都是定义成基于CAS操作的原子类型，增减引用计数时时    线程安全的操作    */</span>    _Atomic_counter_t _Uses<span class="token punctuation">;</span>    _Atomic_counter_t _Weaks<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>也就是说，当我们定义一个shared_ptr&lt; int &gt; ptr(new int)的智能指针对象时，该智能指针对象本身的内存是<strong>8</strong>个字节，如下图所示：</p><p><img src="https://img-blog.csdnimg.cn/026d15692a2744bd80a0e65a6515a8dd.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5omL5Yai55m-5ZCI,size_12,color_FFFFFF,t_70,g_se,x_16"></p><p>那么把智能指针管理的外部资源以及引用计数资源都画出来的话，就是如下图的展示：</p><p><img src="https://img-blog.csdnimg.cn/ef6719ede93246948097505958657520.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5omL5Yai55m-5ZCI,size_20,color_FFFFFF,t_70,g_se,x_16"></p><p>当你做这样的代码操作时：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">shared_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token function">ptr1</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//调用shared_ptr的构造函数</span>shared_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token function">ptr2</span><span class="token punctuation">(</span>ptr1<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//调用shared_ptr的拷贝构造函数</span>cout<span class="token operator">&lt;&lt;</span>ptr1<span class="token punctuation">.</span><span class="token function">use_count</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>cout<span class="token operator">&lt;&lt;</span>ptr2<span class="token punctuation">.</span><span class="token function">use_count</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>这段代码没有任何问题，ptr1和ptr2管理了同一个资源，引用计数打印出来的都是2，出函数作用域依次析构，最终new int资源只释放一次，逻辑正确！这是因为shared_ptr ptr2(ptr1)调用了shared_ptr的拷贝构造函数（源码可以自己查看下），只是做了资源的引用计数的改变，没有额外分配其它资源，如下图所示：</p><p><img src="https://img-blog.csdnimg.cn/ef24e66d2f2f426fb0c49ebaae0f1553.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5omL5Yai55m-5ZCI,size_20,color_FFFFFF,t_70,g_se,x_16"></p><p>但是当你做如下代码操作时（错误代码，一定不要这么使用）</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token operator">*</span>p <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">;</span>shared_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token function">ptr1</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//调用shared_ptr的构造函数，会创建一份引用计数</span>shared_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token function">ptr2</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//调用shared_ptr的构造函数，会创建一份引用计数</span><span class="token comment">//所以这是二组不同的智能指针，有各自的引用计数，都是1，最后资源会错误的释放二次；</span>cout<span class="token operator">&lt;&lt;</span>ptr1<span class="token punctuation">.</span><span class="token function">use_count</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>cout<span class="token operator">&lt;&lt;</span>ptr2<span class="token punctuation">.</span><span class="token function">use_count</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这段代码就有问题了，因为shared_ptr ptr1( p )和shared_ptr ptr2( p )都调用了shared_ptr的构造函数，在它的构造函数中，都重新开辟了引用计数的资源，导致ptr1和ptr2都记录了一次new int的引用计数，都是1，析构的时候它俩都去释放内存资源，导致释放逻辑错误，如下图所示：</p><p><img src="https://img-blog.csdnimg.cn/2ce1765f433644f990f7d85abf2f9c60.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5omL5Yai55m-5ZCI,size_20,color_FFFFFF,t_70,g_se,x_16"></p><p>上面两个代码段，分别是shared_ptr的构造函数和拷贝构造函数做的事情，导致虽然都是指向同一个new int资源，但是对于引用计数对象的管理方式，这两个函数是不一样的，<strong>构造函数是新分配引用计数对象，拷贝构造函数只做引用计数增减</strong>。</p><p>相信说到这里，大家知道最开始的两个代码清单上的代码为什么出错了吧，因为每次调用的都是shared_ptr的构造函数，虽然大家管理的资源都是一样的，_Ptr都是指向同一个堆内存，但是_Rep却指向了不同的引用计数对象，并且都记录引用计数是1，出作用域都去析构，导致问题发生！</p><p>代码1修改正确很简单，就是在产生同一资源的多个shared_ptr的时候，通过拷贝构造函数或者赋值operator=函数进行，不要重新构造，避免产生多个引用计数对象，代码修改如下：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">  A <span class="token operator">*</span>p <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 裸指针指向堆上的对象</span> shared_ptr<span class="token operator">&lt;</span>A<span class="token operator">&gt;</span> <span class="token function">ptr1</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 用shared_ptr智能指针管理指针p指向的对象</span> shared_ptr<span class="token operator">&lt;</span>A<span class="token operator">&gt;</span> <span class="token function">ptr2</span><span class="token punctuation">(</span>ptr1<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 用ptr1拷贝构造ptr2</span><span class="token comment">// 下面两次打印都是2，最终随着ptr1和ptr2析构，资源只释放一次，正确！</span> cout <span class="token operator">&lt;&lt;</span> ptr1<span class="token punctuation">.</span><span class="token function">use_count</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>  cout <span class="token operator">&lt;&lt;</span> ptr2<span class="token punctuation">.</span><span class="token function">use_count</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>代码2修改：注意我们有时候想在类里面提供一些方法，返回当前对象的一个shared_ptr强智能指针，做参数传递使用（多线程编程中经常会用到）。</p><p>首先肯定不能像之前那样写return shared_ptr&lt; A &gt; ( this ) ，这会调用shared_ptr智能指针的构造函数，对this指针指向的对象，又建立了一份引用计数对象，加上main函数中的shared_ptr&lt; A &gt; ptr1(new A());已经对这个A对象建立的引用计数对象，又成了两个引用计数对象，对同一个资源都记录了引用计数，为1，最终两次析构对象释放内存，错误！</p><p>重点：那如果一个类要提供一个函数接口，返回一个指向当前对象的shared_ptr智能指针怎么办？方法就是继承enable_shared_from_this类，然后通过调用从基类继承来的shared_from_this()方法返回指向同一个资源对象的智能指针shared_ptr。这样还是相同的引用计数对象，只是对引用计数增加，而不会创建新的引用计数对象；</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">//智能指针测试类，继承enable_shared_from_this类</span><span class="token keyword">class</span> <span class="token class-name">A</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">enable_shared_from_this</span><span class="token operator">&lt;</span><span class="token class-name">A</span><span class="token operator">&gt;</span></span><span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token function">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">:</span><span class="token function">mptr</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"A()"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token operator">~</span><span class="token function">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"~A()"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>        <span class="token keyword">delete</span> mptr<span class="token punctuation">;</span>        mptr <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token comment">//A类提供了一个成员方法，返回指向自身对象的shared_ptr智能指针</span>    shared_ptr<span class="token operator">&lt;</span>A<span class="token operator">&gt;</span> <span class="token function">getSharedPtr</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span><span class="token comment">//通过调用基类的shared_from_this方法得到一个指向当前对象的智能指针</span>        <span class="token keyword">return</span> <span class="token function">shared_from_this</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token keyword">private</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token operator">*</span>mptr<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>一个类继承enable_shared_from_this会怎么样？看看enable_shared_from_this基类的成员变量有什么，如下：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">_Ty</span><span class="token operator">&gt;</span>    <span class="token keyword">class</span> <span class="token class-name">enable_shared_from_this</span>    <span class="token punctuation">{</span>    <span class="token comment">// provide member functions that create shared_ptr to this</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">using</span> _Esft_type <span class="token operator">=</span> enable_shared_from_this<span class="token punctuation">;</span>    _NODISCARD shared_ptr<span class="token operator">&lt;</span>_Ty<span class="token operator">&gt;</span> <span class="token function">shared_from_this</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>    <span class="token comment">// return shared_ptr</span>        <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token generic-function"><span class="token function">shared_ptr</span><span class="token generic class-name"><span class="token operator">&lt;</span>_Ty<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>_Wptr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token comment">// 成员变量是一个指向资源的弱智能指针</span>    <span class="token keyword">mutable</span> weak_ptr<span class="token operator">&lt;</span>_Ty<span class="token operator">&gt;</span> _Wptr<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>也就是说，如果一个类继承了enable_shared_from_this类，那么它产生的对象就会从基类enable_shared_from_this继承一个成员变量_Wptr，当定义第一个智能指针对象的时候shared_ptr&lt; A &gt; ptr1(new A())，调用shared_ptr的普通构造函数，就会初始化A对象的成员变量_Wptr，作为观察A对象资源的一个弱智能指针观察者（在shared_ptr的构造函数中实现，有兴趣可以自己调试跟踪源码实现）。</p><p>&nbsp;然后代码如下调用shared_ptr&lt; A &gt; ptr2 = ptr1-&gt;getSharedPtr()，getSharedPtr函数内部调用shared_from_this()函数返回指向该对象的智能指针，这个函数怎么实现的呢，看源码：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">shared_ptr<span class="token operator">&lt;</span>_Ty<span class="token operator">&gt;</span> <span class="token function">shared_from_this</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment">// return shared_ptr</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token generic-function"><span class="token function">shared_ptr</span><span class="token generic class-name"><span class="token operator">&lt;</span>_Ty<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>_Wptr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//将当前对象继承自类enable_shared_from_this的弱智能指针提升为强智能指针返回</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>shared_ptr&lt; _Ty &gt;(_Wptr)，说明通过当前A对象的成员变量_Wptr构造一个shared_ptr出来，看看shared_ptr相应的构造函数：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token function">shared_ptr</span><span class="token punctuation">(</span><span class="token keyword">const</span> weak_ptr<span class="token operator">&lt;</span>_Ty2<span class="token operator">&gt;</span><span class="token operator">&amp;</span> _Other<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment">// construct shared_ptr object that owns resource *_Other</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token keyword">this</span><span class="token operator">-&gt;</span><span class="token function">_Construct_from_weak</span><span class="token punctuation">(</span>_Other<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// 从弱智能指针提升一个强智能指针</span>    <span class="token punctuation">{</span>         <span class="token function">_THROW</span><span class="token punctuation">(</span>bad_weak_ptr<span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>接着看上面调用的_Construct_from_weak方法的实现如下：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">_Ty2</span><span class="token operator">&gt;</span><span class="token keyword">bool</span> <span class="token function">_Construct_from_weak</span><span class="token punctuation">(</span><span class="token keyword">const</span> weak_ptr<span class="token operator">&lt;</span>_Ty2<span class="token operator">&gt;</span><span class="token operator">&amp;</span> _Other<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment">// implement shared_ptr's ctor from weak_ptr, and weak_ptr::lock()</span><span class="token comment">//if通过判断资源的引用计数是否还在，判定对象的存活状态，对象存活，提升成功；</span><span class="token comment">//对象析构，提升失败！之前的博客内容讲过这些知识，可以去参考！</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>_Other<span class="token punctuation">.</span>_Rep <span class="token operator">&amp;&amp;</span> _Other<span class="token punctuation">.</span>_Rep<span class="token operator">-&gt;</span><span class="token function">_Incref_nz</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>    _Ptr <span class="token operator">=</span> _Other<span class="token punctuation">.</span>_Ptr<span class="token punctuation">;</span>    _Rep <span class="token operator">=</span> _Other<span class="token punctuation">.</span>_Rep<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>综上所说，所有过程都没有再使用shared_ptr的普通构造函数，没有在产生额外的引用计数对象，不会存在把 一个内存资源，进行多次计数的过程；更关键的是，通过weak_ptr到shared_ptr的提升，还可以在多线程环境中判断对象是否存活或者已经析构释放，在多线程环境中是很安全的；而通过this裸指针进行构造shared_ptr，不仅仅资源会多次释放，而且在多线程环境中也不确定this指向的对象是否还存活。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token comment">// 智能指针测试类，继承enable_shared_from_this类</span><span class="token keyword">class</span> <span class="token class-name">A</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">enable_shared_from_this</span><span class="token operator">&lt;</span><span class="token class-name">A</span><span class="token operator">&gt;</span></span><span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token function">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">:</span><span class="token function">mptr</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"A()"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token operator">~</span><span class="token function">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"~A()"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>        <span class="token keyword">delete</span> mptr<span class="token punctuation">;</span>        mptr <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">// A类提供了一个成员方法，返回指向自身对象的shared_ptr智能指针</span>    shared_ptr<span class="token operator">&lt;</span>A<span class="token operator">&gt;</span> <span class="token function">getSharedPtr</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token comment">/*通过调用基类的shared_from_this方法得到一个指向当前对象的        智能指针*/</span>        <span class="token keyword">return</span> <span class="token function">shared_from_this</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token keyword">private</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token operator">*</span>mptr<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    shared_ptr<span class="token operator">&lt;</span>A<span class="token operator">&gt;</span> <span class="token function">ptr1</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token function">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    shared_ptr<span class="token operator">&lt;</span>A<span class="token operator">&gt;</span> ptr2 <span class="token operator">=</span> ptr1<span class="token operator">-&gt;</span><span class="token function">getSharedPtr</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 引用计数打印为2</span>    cout <span class="token operator">&lt;&lt;</span> ptr1<span class="token punctuation">.</span><span class="token function">use_count</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> ptr2<span class="token punctuation">.</span><span class="token function">use_count</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">//输出：A对象构造一次，引用计数为2，A对象析构一次；</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="make-shared函数make-unique函数："><a href="#make-shared函数make-unique函数：" class="headerlink" title="make_shared函数make_unique函数："></a>make_shared函数make_unique函数：</h2><p><strong>使用new创建shared_ptr</strong>的底层内存分配如下图所示：</p><p><img src="https://img-blog.csdnimg.cn/10f8fff226c6476788edbb350ac8270e.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5omL5Yai55m-5ZCI,size_20,color_FFFFFF,t_70,g_se,x_16"></p><p><strong>使用make_shared函数创建shared_ptr</strong>的底层内存分配如下图所示：</p><p><img src="https://img-blog.csdnimg.cn/7f3822b26f2947358cddf3c01ecb3407.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5omL5Yai55m-5ZCI,size_20,color_FFFFFF,t_70,g_se,x_16"></p><p>从前面的分析我们知道智能指针内部有二个指针，一个指针指向托管的资源，另一个指针指向引用计数；托管的资源和引用计数都是new出来的堆内存；而shared_ptr sp1(new int (10));这种方式创建智能指针是存在缺陷的，因为它包含了二次内存申请，一次是对托管资源的内存申请，一次是存放强-弱引用计数内存的申请；<strong>假设第一次对资源的内存申请成功，第二次对引用计数内存的申请失败了，那么shared_ptr对象创建失败了，那么不会调用shared_ptr的析构函数了，则第一次申请的资源的内存无法释放</strong>，导致<strong>内存泄漏</strong>了；这个风险是存在的；如果换成make_shared去创建智能指针，shared_ptr sp3 = make_shared(10); 情况就不同了； make_shared函数申请一块内存空间同时保存资源和引用计数，这样更加安全却效率更高，但也有缺点，不能自定义删除器了，而且会延迟托管的资源释放；</p><p>make_shared函数的优缺点：</p><p><strong>优点</strong>：内存分配效率高且更安全；原始通过new去创建shared_ptr需要二次内存分配，且有内存泄漏风险，而通过make_shared函数创建智能指针只会进行一次内存分配，效率更高，且不会发生资源泄漏问题； 使用make_shared函数能够避免无意的智能指针初始化错误，比如让二个shared_ptr指向一个new出来的内存，存在二份引用计数，最后会发现错误；</p><p><strong>缺点</strong>： 1. make_shared不能自定义删除器了； 2. 导致托管的资源延迟释放 ：如果是通过new创建shared_ptr分配二块内存， 只要没有强智能指针指向资源了，那么资源内存会直接释放，弱智能指针是指向引用计数的那块内存； 如果是使用make_shared函数只会分配一块内存，保存托管的资源和引用计数， 即便强智能指针没有指向资源了，也不能释放那块内存，因为还有弱智能指针在观察引用计数，那块内存同时包含托管的资源和引用计数，只能同时释放；即即使没有强智能指针指向资源，只要还有弱智能指针，那么那个资源就不会得到释放；</p><p>同时C++14还提供了make_unique来代替new去创建unique_ptr智能指针；自己手写基本版的make</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span>  <span class="token class-name">T</span><span class="token punctuation">,</span><span class="token keyword">typename</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>Ts<span class="token operator">&gt;</span>std<span class="token double-colon punctuation">::</span>unique_ptr<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span> make_unique<span class="token operator">&lt;</span>Ts<span class="token operator">&amp;&amp;</span>  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> params <span class="token operator">&gt;</span><span class="token punctuation">{</span>    <span class="token keyword">return</span>  std<span class="token double-colon punctuation">::</span><span class="token generic-function"><span class="token function">unique_ptr</span><span class="token generic class-name"><span class="token operator">&lt;</span>T<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token function">T</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token generic-function"><span class="token function">forward</span><span class="token generic class-name"><span class="token operator">&lt;</span>Ts<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>params<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TCP_UDP</title>
      <link href="/2023/06/27/tcp-udp/"/>
      <url>/2023/06/27/tcp-udp/</url>
      
        <content type="html"><![CDATA[<h1 id="1-TCP"><a href="#1-TCP" class="headerlink" title="1.TCP"></a>1.TCP</h1><h2 id="1-TCP头部"><a href="#1-TCP头部" class="headerlink" title="1.TCP头部"></a>1.TCP头部</h2><p><strong>TCP头部20字节</strong></p><p><img src="/images/20210308095318405.png" alt="头部"></p><ol><li>源端口号，目的端口号：发送端和接收方的端口号</li><li>序列号：本报文段的数据第一个字节的序号</li><li>确认号：期望收到的对方下一个报文段的第一个数据字节的序号</li><li>首部长度：TCP报文段的数据起始处距离TCP报文段的起始处有多长，以4字节为计算单位</li><li>保留：保留为今后使用，目前置为0</li><li>紧急URG：此位置1，表明紧急指针字段有效，告诉系统此报文段有紧急数据，应尽快传送</li><li>确认ACK：=1时确认号字段有效，在连接建立后所有传达的报文段都必须把 ACK 置1</li><li>推送PSH：当两个应用进程进行交互式的通信时，有时在一端的应用进程希望在键入一个命令后立即就能够收到对方的响应。在这种情况下，TCP 就可以使用推送（push）操作，这时，发送方TCP 把 PSH 置 1，并立即创建一个报文段发送出去，接收方收到 PSH = 1 的报文段，就尽快地（即“推送”向前）交付给接收应用进程，而不再等到整个缓存都填满后再向上交付</li><li>复位RST：用于复位相应的TCP连接</li><li>同步SYN：仅在三次握手建立TCP连接时有效。<br>SYN=1，ACK=0时，表明这是一个连接请求报文段，若对方同意建立连接，则应在相应的报文段中使用SYN=1和ACK=1</li><li>终止FIN：用来释放一个连接，当FIN=1时，表明此报文段发送方的数据已经发送完毕，并要求释放连接</li><li>窗口：指发送本报文段的一方的接受窗口（不是自己的发送窗口）</li><li>校验和：校验和字段检验的范围包括首部和数据两部分，在计算校验和时需要加上 12 字节的伪头部</li><li>紧急指针：仅在 URG = 1 时才有意义，它指出本报文段中的紧急数据的字节数（紧急数据结束后就是普通数据），即指出了紧急数据的末尾在报文中的位置，注意：即使窗口为零时也可发送紧急数据</li></ol><h2 id="2-TCP-如何保证可靠性"><a href="#2-TCP-如何保证可靠性" class="headerlink" title="2.TCP 如何保证可靠性"></a>2.TCP 如何保证可靠性</h2><p>首先，TCP 的连接是基于三次握手，而断开则是四次挥手。确保连接和断开的可靠性。</p><p>其次，TCP 的可靠性，还体现在有状态;TCP 通过校验和、ACK 应答、超时重传来记录哪些数据发送了，哪些数据被接受了，哪些没有被接受，并且保证数据包按序到达，保证数据传输不出差错。<br>再次，TCP 的可靠性，还体现在可控制。通过流量控制（滑动窗口）和拥塞控制来控制发送方发送速率。</p><h3 id="1-校验和"><a href="#1-校验和" class="headerlink" title="1.校验和"></a>1.校验和</h3><p>TCP检验和的计算与UDP一样，在计算时要加上12byte的伪首部，检验和总共计算3部分：TCP首部、TCP数据、TCP伪首部。计算方法为：在发送方将整个报文段分为多个16位的段，然后将所有段进行反码相加，将结果存放在检验和字段中，接收方用相同的方法进行计算，如最终结果为检验字段所有位是全1则正确，否则存在错误。<br><img src="/images/f80567607ab3436f8254d718e140fc9a.png"></p><h3 id="2-确认应答与序列号"><a href="#2-确认应答与序列号" class="headerlink" title="2.确认应答与序列号"></a>2.确认应答与序列号</h3><p>TCP将每个数据包都进行了编号，这就是序列号。<br>序列号的作用：<br>a、保证可靠性（当接收到的数据总少了某个序号的数据时，能马上知道）<br>b、保证数据的按序到达<br>c、提高效率，可实现多次发送，一次确认<br>d、去除重复数据<br>数据传输过程中的确认应答处理、重发控制以及重复控制等功能都可以通过序列号来实现TCP通过确认应答机制实现可靠的数据传输。在TCP的首部中有一个标志位——ACK，此标志位表示确认号是否有效。接收方对于按序到达的数据会进行确认，当标志位ACK=1时确认首部的确认字段有效。进行确认时，确认字段值表示这个值之前的数据都已经按序到达了。而发送方如果收到了已发送的数据的确认报文，则继续传输下一部分数据；而如果等待了一定时间还没有收到确认报文就会启动重传机制。<br>序列号错误示意图<br><img src="/images/174f3cad15e4419cacdfbd6b4fad8d97.png"></p><h3 id="3-超时重传"><a href="#3-超时重传" class="headerlink" title="3.超时重传"></a>3.超时重传</h3><p>当报文发出后在一定的时间内未收到接收方的确认，发送方就会进行重传（通常是在发出报文段后设定一个闹钟，到点了还没有收到应答则进行重传）。<br>一种情况是发送包丢失了，其基本过程如下：</p><p><img src="/images/63610aa310294d5f9360fd653ab4e187.png"></p><p>发送包丢失导致的超时</p><p>另一种情况是ACK 丢失，过程如下：</p><p><img src="/images/250d9da77e0d44d2b411161dce5407ad.png"></p><p>ACK 丢失导致的超时</p><p>当接收方接收到重复的数据时就将其丢掉，重新发送ACK。而要识别出重复的数据，前面提到的序列号就起作用了。</p><p>重传时间的确定：<br>重传时间的确定：报文段发出到收到应答中间有一个报文段的往返时间RTT，显然超时重传时间RTO会略大于这个RTT，TCP会根据网络情况动态的计算RTT，即RTO是不断变化的。在Linux中，超时以500ms为单位进行控制，每次判定超时重发的超时时间都是500ms的整数倍。其规律为：如果重发一次仍得不到应答，就等待2500ms后再进行重传，如果仍然得不到应答就等待4500ms后重传，依次类推，以指数形式递增，重传次数累计到一定次数后，TCP认为网络或对端主机出现异常，就会强行关闭连接。</p><h3 id="4-连接管理"><a href="#4-连接管理" class="headerlink" title="4.连接管理"></a>4.连接管理</h3><p>连接管理机制即TCP建立连接时的三次握手和断开连接时的四次挥手。</p><p><img src="/images/TCP%E7%8A%B6%E6%80%81%E6%9C%BA.png" alt="TCP状态机.png"></p><h3 id="5-流量控制"><a href="#5-流量控制" class="headerlink" title="5.流量控制"></a>5.流量控制</h3><p>接收端处理数据的速度是有限的，如果发送方发送数据的速度过快，导致接收端的缓冲区满，而发送方继续发送，就会造成丢包，继而引起丢包重传等一系列连锁反应。<br>因此TCP支持根据接收端的处理能力，来决定发送端的发送速度，这个机制叫做流量控制。tcp通过滑动窗口来进行流量控制<br>如果主机A是我们的发送方，他在发送数据的时候需要维护一个窗口，接受窗口就是告诉发送方，接收方还有多少的缓存空间，tcp是全双工通信，所以说通信的任何一方都维护着另一方的一个接收窗口<br>接受窗口(表示表示接收方当前可用的缓存空间)<br>主机A通过tcp协议需要向主机B发送一个大文件，主机B需要为这个链接分派一个接收缓存，这个缓存大小我们用receive buffer来表示，发送方发送的数据首先会进入缓存空间，接收方从缓存中读取数据<br>因为发送方不断的写，接收方不断的读，那么一定存在两个位置<br>lastByteRcvd(从网络中到达当前接收缓存的数据流的最后一个字节的编号) 和 LastByteRead(应用程序最后一次缓存中读的位置)</p><p>我们必须保证 lastByteRcvd - LastByteRead = RcvBuffer(当前缓存空间的大小)<br>rwnd(接收窗口) = RevBuffer - 【LastByteRcvd - LastByteRead】<br>接受窗口表示接收方还能有多大的缓存空间<br>因为这些数据是会动态变化的，我们这个接受窗口也是动态变化的，所以我们称这个窗口为滑动窗口那发送方是怎么拿到接收端的滑动窗口大小的数据呢？<br>tcp是全双工通信，这个时候我们的接收方可以再发送一个报文告诉发送方，在tcp报头中，有一个位置是关于窗口大小的，这个位置就是关于流量控制的滑动窗口大小的数据发送方也需要关注两个变量，一个是lastByteSent(最后一次发送的比特位置),一个是LastBytedAcked（最近一次收到的确认包的比特位置）发送方只需要控制这两个的差小于等于接收窗口就可以了。<br>在TCP报文段首部中有一个16位窗口长度，当接收端接收到发送方的数据后，在应答报文ACK中就将自身缓冲区的剩余大小，放入16窗口大小中。这个大小随数据传输情况而变，窗口越大，网络吞吐量越高，而一旦接收方发现自身的缓冲区快满了，就将窗口设置为更小的值通知发送方。如果缓冲区满，就将窗口置为0，发送方收到后就不再发送数据，但是需要定期发送一个窗口探测数据段，使接收端把窗口大小告诉发送端。</p><p>流量控制示意图<br><img src="/images/e11707ef2de046629e7dc31b09e22e77.png"></p><p>注意：窗口大小不受16位窗口大小限制，在TCP首部40字节选项中还包含一个窗口扩大因子M，实际窗口大小是窗口字段的值左移M位。</p><h3 id="6-拥塞控制"><a href="#6-拥塞控制" class="headerlink" title="6.拥塞控制"></a>6.拥塞控制</h3><p>在某段时间，若对网络中某一资源的需求超过了该资源所能提供的可用部分，网络性能就要变坏，这种情况就叫做网络拥塞。</p><p>在计算机网络中数位链路容量（即带宽）、交换结点中的缓存和处理机等，都是网络的资源。</p><p>若出现拥塞而不进行控制，整个网络的吞吐量将随输入负荷的增大而下降。<img src="/images/20190731190238241.png"></p><p>当输入的负载到达一定程度 吞吐量不会增加，即一部分网络资源会丢失掉，网络的吞吐量维持在其所能控制的最大值，转发节点的缓存不够大这造成分组的丢失是拥塞的征兆。</p><p>TCP的四种拥塞控制算法<br>1.慢开始<br>2.拥塞避免<br>3.快重传<br>4.快恢复<br>假定：<br>1.数据是单方向传送，而另一个方向只传送确认<br>2.接收方总是有足够大的缓存空间，因而发送发发送窗口的大小由网络的拥塞程度来决定<br>3.以TCP报文段的个数为讨论问题的单位，而不是以字节为单位</p><p><img src="/images/20190731155254165.png"></p><p>示例如下：<br>传输轮次：发送方给接收方发送数据报文段后，接收方给发送方发回相应的确认报文段，一个传输轮次所经历的时间就是往返时间RTT(RTT并非是恒定的数值），使用传输轮次是为了强调，把拥塞窗口cwnd所允许发送的报文段都连续发送出去，并收到了对已发送的最后一个报文段的确认，拥塞窗口cwnd会随着网络拥塞程度以及所使用的拥塞控制算法动态变化。</p><p>在tcp双方建立逻辑链接关系时， 拥塞窗口cwnd的值被设置为1，还需设置慢开始门限ssthresh,在执行慢开始算法时，发送方每收到一个对新报文段的确认时，就把拥塞窗口cwnd的值加一，然后开始下一轮的传输，当拥塞窗口cwnd增长到慢开始门限值时，就使用拥塞避免算法。</p><p>慢开始：<br>假设当前发送方拥塞窗口cwnd的值为1，而发送窗口swnd等于拥塞窗口cwnd，因此发送方当前只能发送一个数据报文段（拥塞窗口cwnd的值是几，就能发送几个数据报文段），接收方收到该数据报文段后，给发送方回复一个确认报文段，发送方收到该确认报文后，将拥塞窗口的值变为2，<br>发送方此时可以连续发送两个数据报文段，接收方收到该数据报文段后，给发送方一次发回2个确认报文段，发送方收到这两个确认报文后，将拥塞窗口的值加2变为4，发送方此时可连续发送4个报文段，接收方收到4个报文段后，给发送方依次回复4个确认报文，发送方收到确认报文后，将拥塞窗口加4，置为8，发送方此时可以连续发送8个数据报文段，接收方收到该8个数据报文段后，给发送方一次发回8个确认报文段，发送方收到这8个确认报文后，将拥塞窗口的值加8变为16，当前的拥塞窗口cwnd的值已经等于慢开始门限值，之后改用拥塞避免算法。</p><p>拥塞避免：<br>也就是每个传输轮次，拥塞窗口cwnd只能线性加一，而不是像慢开始算法时，每个传输轮次，拥塞窗口cwnd按指数增长。同理，16+1……直至到达24，假设24个报文段在传输过程中丢失4个，接收方只收到20个报文段，给发送方依次回复20个确认报文段，一段时间后，丢失的4个报文段的重传计时器超时了，发送方判断可能出现拥塞，更改cwnd和ssthresh.并重新开始慢开始算法，如图所示：<br><img src="/images/20190731165743903.png"></p><p><img src="/images/20190731165605396.png"></p><p>快速重传：<br>发送方发送1号数据报文段，接收方收到1号报文段后给发送方发回对1号报文段的确认，在1号报文段到达发送方之前，发送方还可以将发送窗口内的2号数据报文段发送出去，接收方收到2号报文段后给发送方发回对2号报文段的确认，在2号报文段到达发送方之前，发送方还可以将发送窗口内的3号数据报文段发送出去，<br>假设该报文丢失，发送方便不会发送针对该报文的确认报文给发送方，发送方还可以将发送窗口内的4号数据报文段发送出去，接收方收到后，发现这不是按序到达的报文段，因此给发送方发送针对2号报文段的重复确认，表明我现在希望收到的是3号报文段，但是我没有收到3号报文段，而收到了未按序到达的报文段，发送方还可以将发送窗口中的5号报文段发送出去,接收方收到后，发现这不是按序到达的报文段，因此给发送方发送针对2号报文段的重复确认，表明我现在希望收到的是3号报文段，但是我没有收到3号报文段，而收到了未按序到达的报文段,，发送方还可以将发送窗口内的最后一个数据段即6号数据报文段发送出去，接收方收到后，发现这不是按序到达的报文段，因此给发送方发送针对2号报文段的重复确认，表明我现在希望收到的是3号报文段，但是我没有收到3号报文段，而收到了未按序到达的报文段，<br>此时，发送方收到了累计3个连续的针对2号报文段的重复确认，立即重传3号报文段，接收方收到后，给发送方发回针对6号报文的确认，表明，序号到6为至的报文都收到了，这样就不会造成发送方对3号报文的超时重传，而是提早收到了重传。</p><p><img src="/images/20190731184314574.png"></p><p><img src="/images/20190731184640178.png"></p><p><img src="/images/20190731184935595.png"></p><p>为了避免由于网络拥堵而采取的对发送方发送速率的限制称为拥塞控制。<br>TCP 通过拥塞窗口实现拥塞避免。<br>每个 TCP 连接的发送方都会去感知网络的拥塞程度，然后去进行拥塞控制，那么 TCP 的发送方是如何感知到当前这个网络存在着拥塞呢，丢包，只要出现了超时就极有可能出现了网络拥堵。那 假设现在出现了网络拥塞，那么 TCP 如何限制传输的速率呢？TCP 的每一端除了维护进行流量控制的滑动窗口外，还会维护一个拥塞窗口（cwnd），拥塞窗口就是对 TCP 发送方的发送速率进行限制的，具体来说的就是 TCP 会控制发送方发送到连接中的但是还没有被接收方确认的数据量。</p><p>那我们改变拥塞窗口的大小，就可以调节发送方发送数据的速率。那么发送的速率是多少呢？首先用 rtt 表示一次通信往返所用的时间，那么速率就等于 cwnd/rtt。一般来说 rtt 都是比较固定的，所以调整 cwnd 的值就可以调整发送速率。那我们应该如何确定当前发送速率是多少才合适呢？那就要依靠 TCP 的拥塞控制算法了。拥塞控制算法的实质就是如何来调整 cwnd 的大小。一说到大小就得有衡量单位，那窗口的衡量单位是 mss 最大的传输单元。那我们知道 TCP 分为 TCP 首部和数据两部分，mss 就是去控制数据字段的大小的，那这个值呢是需要通讯双方进行约定的。比如说一般的值呢是一千四百六十个字节。首先发送方发送数据的原则是什么呢，只要网络不堵，我就尽可能多的去发，网络赌的话，我就减小这个窗口的大小。</p><p>TCP拥塞控制流程:<br>TCP拥塞算法共有4种：慢开始、拥塞避免、快重传、快恢复<br><img src="/images/4366ac4746134be8a9865e0431428512.png"></p><p>慢开始</p><p>慢开始发生在最开始，这个时候不断试探网络是否把握的住，拥塞窗口(cwnd)以n²的增速开始增长，然后到了设置的阈值，我们就采取拥塞避免的算法每次加一的试探网络，当然后面肯定避免不了超时，我们这时候阈值设为当前阈值的一半，我们重新开始慢开始，到达现在的阈值开始拥塞避免。</p><p>拥塞避免</p><p>每个传输轮次，拥塞窗口cwnd只能线性加一，而不是像慢开始算法时，每个传输轮次，拥塞窗口cwnd按指数增长。</p><p>快速重传</p><p>接收器接收到一个不按顺序的数据段，接收器会立马给发送器发送重复确认，如果发送机接收到三个重复确认，它会假定确认件支出的数据段丢失了。这样就不会造成发送方对后面报文出发超时重传，而是提早收到了重传。然后开始快恢复算法。</p><p>快恢复算法</p><p>发送方一旦收到3个重复确认，就知道现在只是丢失了个别的报文段。于是不启动慢开始算法，而执行快恢复算法;<br>1.发送方将慢开始门限ssthresh值和拥塞窗口cwnd值调整为当前窗口的一半；开始执行拥塞避免算法。<br>2.也有的快恢复实现是把快恢复开始时的拥塞窗口cwnd值再增大一些，即等于新的ssthresh + 3。<br>既然发送方收到3个重复的确认，就表明有3个数据报文段已经离开了网络；<br>这3个报文段不再消耗网络资源而是停留在接收方的接收缓存中；<br>可见现在网络中不是堆积了报文段而是减少了3个报文段。因此可以适当把拥塞窗口犷大些。</p><h1 id="如何在不杀掉进程前提，关闭一个-TCP-连接？"><a href="#如何在不杀掉进程前提，关闭一个-TCP-连接？" class="headerlink" title="如何在不杀掉进程前提，关闭一个 TCP 连接？"></a>如何在不杀掉进程前提，关闭一个 TCP 连接？</h1><p>大家在关闭 TCP 连接第一反应都是「杀掉进程」。</p><p>是的，这个是最粗暴的方式，杀掉客户端进程和服务端进程影响的范围会有所不同：</p><ul><li>在客户端杀掉进程的话，就会发送 FIN 报文，来断开这个客户端进程与服务端建立的所有 TCP 连接，这种方式影响范围只有这个客户端进程所建立的连接，而其他客户端或进程不会受影响。</li><li>而在服务端杀掉进程影响就大了，此时所有的 TCP 连接都会被关闭，服务端无法继续提供访问服务。</li></ul><p>所以，关闭进程的方式并不可取，最好的方式要精细到关闭某一条 TCP 连接。</p><p>有的小伙伴可能会说，伪造一个四元组相同的 RST 报文不就行了？</p><p>这个思路很好，但是不要忘了还有个序列号的问题，你伪造的 RST 报文的序列号一定能被对方接受吗？</p><p>如果 RST 报文的序列号不能落在对方的滑动窗口内，这个 RST 报文会被对方丢弃的，就达不到关闭的连接的效果。</p><p>所以，<strong>要伪造一个能关闭 TCP 连接的 RST 报文，必须同时满足「四元组相同」和「序列号正好落在对方的滑动窗口内」这两个条件</strong>。</p><p>直接伪造符合预期的序列号是比较困难，因为如果一个正在传输数据的 TCP 连接，滑动窗口时刻都在变化，因此很难刚好伪造一个刚好落在对方滑动窗口内的序列号的 RST 报文。</p><p>办法还是有的，<strong>我们可以伪造一个四元组相同的 SYN 报文，来拿到“合法”的序列号！</strong></p><p>因为如果处于 establish 状态的服务端，收到四元组相同的 SYN 报文后，<strong>会回复一个 Challenge ACK，这个 ACK 报文里的「确认号」，正好是服务端下一次想要接收的序列号</strong>，说白了，就是可以通过这一步拿到服务端下一次预期接收的序列号。</p><p><strong>然后用这个确认号作为 RST 报文的序列号，发送给服务端，此时服务端会认为这个 RST 报文里的序列号是合法的，于是就会释放连接！</strong></p><p>在 Linux 上有个叫&nbsp;<strong>killcx</strong>&nbsp;的工具，就是基于上面这样的方式实现的，它会主动发送 SYN 包获取 SEQ/ACK 号，然后利用 SEQ/ACK 号伪造两个 RST 报文分别发给客户端和服务端，这样双方的 TCP 连接都会被释放，这种方式活跃和非活跃的 TCP 连接都可以杀掉。</p><p>使用方式也很简单，只需指明客户端的 IP 和端口号。</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">./killcx &lt;IP地址&gt;:&lt;端口号&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>killcx 工具的工作原理，如下图。</p><p><img src="https://pic1.zhimg.com/80/v2-0f6a5dc917ecb1be04c6d5587034fab4_720w.jpg"></p><p>它伪造客户端发送 SYN 报文，服务端收到后就会回复一个携带了正确「序列号和确认号」的 ACK 报文（Challenge ACK），然后就可以利用这个 ACK 报文里面的信息，<strong>伪造两个 RST 报文</strong>：</p><ul><li>用 Challenge ACK 里的<strong>确认号</strong>伪造 RST 报文发送给服务端，服务端收到 RST 报文后就会释放连接。</li><li>用 Challenge ACK 里的<strong>序列号</strong>伪造 RST 报文发送给客户端，客户端收到 RST 也会释放连接。</li></ul><p>正是通过这样的方式，成功将一个 TCP 连接关闭了！</p><p>这里给大家贴一个使用 killcx 工具关闭连接的抓包图，大家多看看序列号和确认号的变化。</p><p><img src="https://pic1.zhimg.com/80/v2-2e3e531bd43ca06aad9058c787d24dbc_720w.jpg"></p><p>所以，以后抓包中，如果莫名奇妙出现一个 SYN 包，有可能对方接下来想要对你发起的 RST 攻击，直接将你的 TCP 连接断开！</p><h1 id="1、当收到RST"><a href="#1、当收到RST" class="headerlink" title="1、当收到RST"></a>1、当收到RST</h1><p>（1） 收到rst后，内核会立马释放该TCP连接所占用的内存资源（状态、数据）、以及端口号。<br>（2） 收到rst后，应用层首次读，read返回-1，并设置errno为ECONNRESET。POLLIN 会立刻再次触发，再read会返回0。<br>（3） 收到rst后，应用层首次写，（此时写操作返回EPIPE错误）内核向该进程发送一个SIGPIPE信号，该信号的默认行为是终止进程，因此进程必须捕获它以免不情愿地被终止。</p><h1 id="2、关闭TCP连接"><a href="#2、关闭TCP连接" class="headerlink" title="2、关闭TCP连接"></a>2、关闭TCP连接</h1><p>对于本端来讲，关闭一个TCP连接只有两种情况：<br>（1）RST，相当于重置了。<br>（2）关掉本端写（即发送FIN分节），而无法主动关闭对端写，也就是只能主动关闭半个连接，另外一个方向连接的关闭是对端主动进行的。</p><ul><li>调用shutdown发送FIN分节，这时进入到半关闭的状态（写关闭）。这样做可以保证完整的接受数据。</li><li>调用close发送FIN分节，是把该套接字标记成已关闭，该套接字就不能再由调用进程使用了，该套接字就不能再作为read或write的第一个参数了。</li></ul><p>（3）假如本端收到对端的FIN分节后（即read返回0），是无法判断对端究竟是close（对端也不读了）还是shutdown（对端还可以读，半关闭）。</p><p><strong>Q : 那么此时，我们再去wirte会怎么样呢？</strong><br>1、客户端可能调用shutdown(cfd, SHUT_WR)，即单向关闭了它的写端，于是我read到0，这种情况我不想马上关闭这个连接，而是把给这个客户的回复都写完后再关闭。<br>2、客户端可能调用close(cfd)。这时我如果write(sfd, buf2,size2)，就会返回EPIPE错误。</p><p><strong>Q : 当read返回0后，该怎么办呢？</strong><br><em>此时是否要close取决于你的应用。通常来说如果对方调用的是close，那么你也可以close。否则你不能close，例如对方发送一个包给你并shutdown write然后调用recv，这时候你还可以返回一个或多个包，连接此时处于半关闭状态，可以一直持续。</em><a href="https://links.jianshu.com/go?to=https://www.zhihu.com/question/48871684/answer/113135138">摘自 知乎 胡宇光</a></p><p><strong>Q : FIN_WAIT2 和CLOSE_WAIT这两状态会一直持续下去么？</strong></p><ul><li>FIN_WAIT2状态只有接收到对端的FIN分节，才会进入TIME WAIT状态，主动权在对方手里了。如果对端不发送FIN分节，FIN_WAIT2状态理论上可以无限的等待下去。但是操作系统设置了一个定时器，如果这个连接空闲时间超时了，那么该连接将进入CLOSED状态。<br>linux下查看FIN_WAIT2方法</li></ul><pre class="line-numbers language-ruby" data-language="ruby"><code class="language-ruby">root<span class="token variable">@zeo</span><span class="token operator">-</span>virtual<span class="token operator">-</span>machine<span class="token operator">:</span><span class="token operator">~</span><span class="token comment"># more /proc/sys/net/ipv4/tcp_fin_timeout </span><span class="token number">60</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li>当我们read返回0时，就可能进入到CLOSE_WAIT状态（为什么是可能呢？）。此时是我们可以控制的，只要我们发送FIN分节（close或者shutdown），就会进入LAST ACK状态。</li></ul><h1 id="2-UDP"><a href="#2-UDP" class="headerlink" title="2.UDP"></a>2.UDP</h1><h2 id="1-UDP头部"><a href="#1-UDP头部" class="headerlink" title="1.UDP头部"></a>1.UDP头部</h2><p><strong>UDP头部8字节</strong><img src="/images/2021030809185216.png" alt="2021030809185216"></p><ol><li>源端口号，目的端口号：发送端和接收端的端口号</li><li>长度：UDP用户数据报的长度，最小值是8字节（只有首部）</li><li>校验和：检测UDP用户数据报在传输中是否出错，出错就丢弃</li></ol><h1 id="知道哪些socket？"><a href="#知道哪些socket？" class="headerlink" title="知道哪些socket？"></a>知道哪些socket？</h1><p>流式套接字(SOCK_STREAM),数据报套接字(SOCK_DGRAM)及原始套接字</p><p>SOCK_STREAM、SOCK_DGRAM、SOCK_RAW、SOCK_PACKET、SOCK_SEQPACKET等</p><p>1.流式套接字(SOCK_STREAM)<br>&nbsp; &nbsp; 流式的套接字可以提供可靠的、面向连接的通讯流。如果你通过流式套接字发送了顺序的数据:“1”“2”，那么数据到达远程时候的顺序也是“1”“2”。<br>&nbsp; &nbsp; 流式套接字可以做什么呢?你听说过Telnet应用程序吗?听过?哦,最常用的BBS服务,以及系统的远程登陆都是通过Telnet协议连接的。Telnet就是一个流式连接。你是否希望你在Telnet应用程序上输入的字符(或汉字)在到达远程应用程序的时候是以你输入的顺序到达的?答案应该是肯定的吧。还有WWW浏览器,它使用的HTTP协议也是通过流式套接字来获取网页的。事实上,如果你Telnet到一个Web Site的80端口上,然后输入“GET网页路径名”然后按两下回车(或者是两下 Ctrl+回车)然后你就得到了“网页路径名”所代表的网页!<br>&nbsp; &nbsp; 流式套接字是怎样保证这种应用层次上的数据传输质量呢?它使用了TCP(The&nbsp;Transmission Control Protocol)协议(可以参考RFC-793来得到TCP的细节)。TCP保证了你的数据传输是正确的,并且是顺序的。TCP是经常出现的TCP/IP中的前半部分。IP代表Internet Protocol(因特网协议,参考RFC-791)IP只处理网络路由。  </p><p>&nbsp; &nbsp; 2.数据报套接字(SOCK_DGRAM)<br>&nbsp; &nbsp; 数据报套接字定义了一种无连接的服务,数据通过相互独立的报文进行传输,是无序的,并且不保证可靠,无差错。原始套接字允许对低层协议如IP或ICMP直接访问,主要用于新的网络协议实现的测试等。<br>&nbsp; &nbsp; 数据报套接字(Datagram Sockets)怎样呢?为什么它叫做“无连接”?应该怎样处理它们呢?为什么它们是不可靠的?好的,这里有一些事实:<br>&nbsp; &nbsp; ·如果你发送了一个数据报,它可能不会到达。<br>&nbsp; &nbsp; ·它可能会以不同的顺序到达。<br>&nbsp; &nbsp; ·如果它到达了,它包含的数据中可能存在错误。<br>&nbsp; &nbsp; 数据报套接字也使用IP,但是它不使用TCP,它使用使用者数据报协议UDP(User&nbsp;Datagram Protocol可以参考RFC 768)<br>&nbsp; &nbsp; 为什么说它们是“无连接”的呢?因为它(UDP)不像流式套接字那样维护一个打开的连接,你只需要把数据打成一个包,把远程的IP贴上去,然后把这个包发送出去。这个过程是不需要建立连接的。UDP的应用例子有:tftp, bootp等。<br>&nbsp; &nbsp; &nbsp;那么,数据包既然会丢失,怎样能保证程序能够正常工作呢?事实上,每个使用UDP的程序都要有自己的对数据进行确认的协议。比如,TFTP协议定义了对于每一个发送出去的数据包,远程在接受到之后都要回送一个数据包告诉本地程序:“我已经拿到了!(一个“ACK”包)。如果数据包发的送者在5秒内没有的得到回应,它就会重新发送这个数据包直到数据包接受者回送了“ACK”信号。这些知识对编写一个使用UDP协议的程序员来说是非常必要的。<br>&nbsp; &nbsp; 无连接服务器一般都是面向事务处理的,一个请求一个应答就完成了客户程序与服务程序之间的相互作用。面向连接服务器处理的请求往往比较复杂,不是一来一去的请求应答所能解决的,而且往往是并发服务器。</p><p>&nbsp; &nbsp; 套接字工作过程如下:服务器首先启动,通过调用socket()建立一个套接字,然后调用bind()将该套接字和本地网络地址联系在一起,再调用listen()使套接字做好侦听的准备,并规定它的请求队列的长度,之后就调用accept()来接收连接。客户在建立套接字后就可调用connect()和服务器建立连接。连接一旦建立,客户机和服务器之间就可以通过调用read()和write()来发送和接收数据。最后,待数据传送结束后,双方调用close()关闭套接字。<br>&nbsp; &nbsp; 3.原始套接字<br>&nbsp; &nbsp; 原始套接字主要用于一些协议的开发,可以进行比较底层的操作。它功能强大,但是没有上面介绍的两种套接字使用方便,一般的程序也涉及不到原始套接字。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Network </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL</title>
      <link href="/2023/06/27/mysql/"/>
      <url>/2023/06/27/mysql/</url>
      
        <content type="html"><![CDATA[<h1 id="MYSQL"><a href="#MYSQL" class="headerlink" title="MYSQL"></a>MYSQL</h1><h1 id="MySql下大数据量级别（1000万-）优化查询和操作方法"><a href="#MySql下大数据量级别（1000万-）优化查询和操作方法" class="headerlink" title="MySql下大数据量级别（1000万+）优化查询和操作方法"></a>MySql下大数据量级别（1000万+）优化查询和操作方法</h1><p>1、应尽量避免在 where 子句中使用!=或&lt;&gt;操作符，否则将引擎放弃使用索引而进行全表扫描。</p><p>2、对查询进行优化，应尽量避免全表扫描，首先应考虑在 where 及 order by 涉及的列上建立索引。</p><p>3、应尽量避免在 where 子句中对字段进行 null 值判断，否则将导致引擎放弃使用索引而进行全表扫描</p><p>4、尽量避免在 where 子句中使用 or 来连接条件，否则将导致引擎放弃使用索引而进行全表扫描</p><p>5、下面的查询也将导致全表扫描：(不能前置百分号)</p><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp"><span class="token keyword">select</span> id <span class="token keyword">from</span> t <span class="token keyword">where</span> <span class="token class-name">name</span> like ‘�c<span class="token operator">%</span>’<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>若要提高效率，可以考虑全文检索。</p><p>6、in 和 not in 也要慎用，否则会导致全表扫描</p><p>对于连续的数值，能用 between 就不要用 in 了</p><p>7、如果在 where 子句中使用参数，也会导致全表扫描。因为SQL只有在运行时才会解析局部变量，但优化程序不能将访问计划的选择推迟到运行时；它必须在编译时进行选择。然 而，如果在编译时建立访问计划，变量的值还是未知的，因而无法作为索引选择的输入项。如下面语句将进行全表扫描：</p><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp"><span class="token keyword">select</span> id <span class="token keyword">from</span> t <span class="token keyword">where</span> <span class="token class-name">num</span><span class="token operator">=</span>@num<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>可以改为强制查询使用索引：</p><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp"><span class="token keyword">select</span> id <span class="token keyword">from</span> <span class="token return-type class-name">t</span> <span class="token function">with</span><span class="token punctuation">(</span><span class="token function">index</span><span class="token punctuation">(</span>索引名<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">where</span> <span class="token class-name">num</span><span class="token operator">=</span>@num<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>8、应尽量避免在 where 子句中对字段进行表达式操作，这将导致引擎放弃使用索引而进行全表扫描。</p><p>9、应尽量避免在where子句中对字段进行函数操作，这将导致引擎放弃使用索引而进行全表扫描。</p><p>10、不要在 where 子句中的“=”左边进行函数、算术运算或其他表达式运算，否则系统将可能无法正确使用索引。</p><p>11、在使用索引字段作为条件时，如果该索引是复合索引，那么必须使用到该索引中的第一个字段作为条件时才能保证系统使用该索引，否则该索引将不会被使 用，并且应尽可能的让字段顺序与索引顺序相一致。</p><p>12、不要写一些没有意义的查询，如需要生成一个空表结构</p><p>13、很多时候用 exists 代替 in 是一个好的选择。</p><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp"><span class="token keyword">select</span> num <span class="token keyword">from</span> a <span class="token keyword">where</span> <span class="token class-name">num</span> <span class="token keyword">in</span><span class="token punctuation">(</span><span class="token keyword">select</span> num <span class="token keyword">from</span> b<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>用下面的语句替换：</p><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp"><span class="token keyword">select</span> num <span class="token keyword">from</span> a <span class="token keyword">where</span> <span class="token class-name">exists</span><span class="token punctuation">(</span><span class="token keyword">select</span> <span class="token number">1</span> <span class="token keyword">from</span> b <span class="token keyword">where</span> <span class="token class-name">num</span><span class="token operator">=</span>a<span class="token punctuation">.</span>num<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>14、并不是所有索引对查询都有效，SQL是根据表中数据来进行查询优化的，当索引列有大量数据重复时，SQL查询可能不会去利用索引，如一表中有字段 sex，male、female几乎各一半，那么即使在sex上建了索引也对查询效率起不了作用。</p><p>15、索引并不是越多越好，索引固然可以提高相应的 select 的效率，但同时也降低了 insert 及 update 的效率，因为 insert 或 update 时有可能会重建索引，所以怎样建索引需要慎重考虑，视具体情况而定。一个表的索引数最好不要超过6个，若太多则应考虑一些不常使用到的列上建的索引是否有 必要。</p><p>16.应尽可能的避免更新 clustered 索引数据列，因为 clustered 索引数据列的顺序就是表记录的物理存储顺序，一旦该列值改变将导致整个表记录的顺序的调整，会耗费相当大的资源。若应用系统需要频繁更新 clustered 索引数据列，那么需要考虑是否应将该索引建为 clustered 索引。</p><p>17、尽量使用数字型字段，若只含数值信息的字段尽量不要设计为字符型，这会降低查询和连接的性能，并会增加存储开销。这是因为引擎在处理查询和连接时会 逐个比较字符串中每一个字符，而对于数字型而言只需要比较一次就够了。</p><p>18、尽可能的使用 varchar/nvarchar 代替 char/nchar ，因为首先变长字段存储空间小，可以节省存储空间，其次对于查询来说，在一个相对较小的字段内搜索效率显然要高些。</p><p>19、任何地方都不要使用 select * from t ，用具体的字段列表代替“*”，不要返回用不到的任何字段。</p><p>20、尽量使用表变量来代替临时表。如果表变量包含大量数据，请注意索引非常有限（只有主键索引）。</p><p>21、避免频繁创建和删除临时表，以减少系统表资源的消耗。</p><p>22、临时表并不是不可使用，适当地使用它们可以使某些例程更有效，例如，当需要重复引用大型表或常用表中的某个数据集时。但是，对于一次性事件，最好使 用导出表。</p><p>23、在新建临时表时，如果一次性插入数据量很大，那么可以使用 select into 代替 create table，避免造成大量 log ，以提高速度；如果数据量不大，为了缓和系统表的资源，应先create table，然后insert。</p><p>24、如果使用到了临时表，在存储过程的最后务必将所有的临时表显式删除，先 truncate table ，然后 drop table ，这样可以避免系统表的较长时间锁定。</p><p>25、尽量避免使用游标，因为游标的效率较差，如果游标操作的数据超过1万行，那么就应该考虑改写。</p><p>26、使用基于游标的方法或临时表方法之前，应先寻找基于集的解决方案来解决问题，基于集的方法通常更有效。</p><p>27、与临时表一样，游标并不是不可使用。对小型数据集使用 FAST_FORWARD 游标通常要优于其他逐行处理方法，尤其是在必须引用几个表才能获得所需的数据时。在结果集中包括“合计”的例程通常要比使用游标执行的速度快。如果开发时 间允许，基于游标的方法和基于集的方法都可以尝试一下，看哪一种方法的效果更好。</p><p>28、在所有的存储过程和触发器的开始处设置 SET NOCOUNT ON ，在结束时设置 SET NOCOUNT OFF 。无需在执行存储过程和触发器的每个语句后向客户端发送 DONE_IN_PROC 消息。</p><p>29、尽量避免向客户端返回大数据量，若数据量过大，应该考虑相应需求是否合理。</p><p>30、尽量避免大事务操作，提高系统并发能力。</p><h2 id="1-DDL-数据定义语言"><a href="#1-DDL-数据定义语言" class="headerlink" title="1.DDL(数据定义语言)"></a>1.DDL(数据定义语言)</h2><h3 id="1-数据库操作"><a href="#1-数据库操作" class="headerlink" title="(1)数据库操作"></a>(1)数据库操作</h3><h4 id="A-查询"><a href="#A-查询" class="headerlink" title="A.查询"></a>A.查询</h4><p>​    查询所有数据库</p><p>​    SHOW DATABASES;  </p><p>​    查询当前数据库</p><p>​    SELECT DATABASES();</p><h4 id="B-创建"><a href="#B-创建" class="headerlink" title="B.创建"></a>B.创建</h4><p>​    CREATE DATABASE [IF NOT EXISTS] 数据库名 [DEFAULT CHARSET 字符集] [COLLATE 排序规则];</p><h4 id="C-删除"><a href="#C-删除" class="headerlink" title="C.删除"></a>C.删除</h4><p>​    DROP DATABASE [IF EXISTS] 数据库名;</p><h4 id="D-使用"><a href="#D-使用" class="headerlink" title="D.使用"></a>D.使用</h4><p>​    USE 数据库名;</p><h3 id="2-表操作"><a href="#2-表操作" class="headerlink" title="(2)表操作"></a>(2)表操作</h3><h4 id="A-查询-1"><a href="#A-查询-1" class="headerlink" title="A.查询"></a>A.查询</h4><p>​    查询当前数据库所有表</p><p>​    SHOW TABLES;</p><p>​    查询表结构</p><p>​    DESC 表名;</p><p>​    查询指定表的建表语句</p><p>​    SHOW CREATE TABLE 表名;</p><h4 id="B-创建-1"><a href="#B-创建-1" class="headerlink" title="B.创建"></a>B.创建</h4><p>​    CREATE TABLE 表名(</p><p>​    字段1 字段1类型 约束 [COMMENT 字段1注释],</p><p>​    字段2 字段2类型 约束 [COMMENT 字段2注释],</p><p>​    字段3 字段3类型 约束 [COMMENT 字段3注释],</p><p>​    …</p><p>​    字段n 字段n类型 约束 [COMMENT 字段n注释]</p><p>​    )[COMMENT 表注释];</p><h3 id="3-数据类型"><a href="#3-数据类型" class="headerlink" title="(3)数据类型"></a>(3)数据类型</h3><h4 id="A-数值类型"><a href="#A-数值类型" class="headerlink" title="A.数值类型"></a>A.数值类型</h4><p>​    TINYINT    1byte    (-128, 127)    (0, 255)    小整数值</p><p>​    SMALLINT    2bytes    (-32768, 32767)    (0, 65535)    大整数值</p><p>​    MEDIUMINT    3bytes    (-8388608, 8388607)    (0, 16777215)    大整数值</p><p>​    INT or INTEGER    4bytes    (-2147483648, 2147483647)    (0, 4294967295)    大整数值</p><p>​    BIGINT    8bytes    (-2^63, 2^63-1)    (0, 2^64-1)    极大整数值</p><p>​    FLOAT    4bytes    (-3.402823466E+38, 3.402823466351E+38)    0 和 (1.175494351E-38, 3.402823466E+38)    单精度浮点数值</p><p>​    DOUBLE    8bytes    (-1.7976931348623157E+308, 1.7976931348623157E+308)    0和(2.2250738585072014E-3.8, 1.7976931348623157E+308)    双精度浮点数值</p><p>​    DECIMAL        依赖于M(精度)和D(标度)的值    依赖于M(精度)和D(标度)的值    小数值(精确定点数)</p><h4 id="B-字符串类型"><a href="#B-字符串类型" class="headerlink" title="B.字符串类型"></a>B.字符串类型</h4><p>​    CHAR    0-255bytes    定长字符串</p><p>​    VARCHAR    0-65535bytes    变长字符串</p><p>​    TINYBLOB    0-255bytes    不超过255个字符的二进制数据</p><p>​    TINYTEXT    0-255bytes    短文本字符串</p><p>​    BLOB    0-65535bytes    二进制形式的长文本数据</p><p>​    TEXT    0-65535bytes    长文本数据</p><p>​    MEDIUMBLOB    0-16777215bytes    二进制形式的中等长度文本数据</p><p>​    LONGBLOB    0-4294967295bytes    二进制形式的极大文本数据</p><p>​    LONGTEXT    0-4294967295bytes    极大文本数据</p><h4 id="C-日期时间类型"><a href="#C-日期时间类型" class="headerlink" title="C.日期时间类型"></a>C.日期时间类型</h4><p>​    DATE    3bytes    1000-01-01至9999-12-31    YYYY-MM-DD    日期值</p><p>​    TIME    3bytes    -838:59:59至838:59:59    HH:MM:SS    日期值或持续时间</p><p>​    YEAR    1bytes    1901至2155    YYYY    年份值</p><p>​    DATATIME    8bytes    1000-01-01 00:00:00至9999-12-31 23:59:59    YYYY-MM-DD HH:MM:SS    混合日期和时间值</p><p>​    TIMESTAMP    4bytes    1970-01-01 00:00:01至2038-01-19 03:14:07     YYYY-MM-DD HH:MM:SS    混合日期和时间值，时间戳</p><h3 id="4-修改"><a href="#4-修改" class="headerlink" title="(4)修改"></a>(4)修改</h3><p>​    添加字段</p><p>​    ALTER TABLE 表名 ADD 字段名 类型(长度) [COMMENT 注释] [约束];</p><p>​    修改字段名和字段类型</p><p>​    ALTER TABLE 表名 CHANGE 旧字段名 新字段名 类型(长度) [COMMENT 注释] [约束];</p><p>​    删除字段</p><p>​    ALTER TABLE 表名 DROP 字段名;</p><p>​    修改表名</p><p>​    ALTER TABLE 表名 RENAME TO 新表名;</p><h3 id="5-删除"><a href="#5-删除" class="headerlink" title="(5)删除"></a>(5)删除</h3><p>​    删除表</p><p>​    DROP TABLE [IF EXISTS] 表名;</p><p>​    删除指定表，并重新创建该表</p><p>​    TRUNCATE TABLE 表名;</p><h2 id="2-DML-数据操作语言"><a href="#2-DML-数据操作语言" class="headerlink" title="2.DML(数据操作语言)"></a>2.DML(数据操作语言)</h2><h3 id="1-添加数据"><a href="#1-添加数据" class="headerlink" title="(1)添加数据"></a>(1)添加数据</h3><p>​    给指定字段添加数据</p><p>​    INSERT INTO 表名 (字段名, 字段名2,…) VALUES (值1,值2,…);</p><p>​    给全部字段添加数据</p><p>​    INSERT INTO 表名 VALUES (值1, 值2,…);</p><p>​    批量添加数据</p><p>​    INSERT INTO 表名 (字段名1, 字段名2, …) VALUES (值1, 值2,…), (值1, 值2,…), (值1, 值2,…);</p><p>​    INSERT INTO 表名 VALUES  (值1, 值2,…), (值1, 值2,…), (值1, 值2,…);</p><h3 id="2-修改数据"><a href="#2-修改数据" class="headerlink" title="(2)修改数据"></a>(2)修改数据</h3><p>​    UPDATE 表名 SET 字段名1=值1,字段名2=值2,…[WHERE 条件];</p><h3 id="3-删除数据"><a href="#3-删除数据" class="headerlink" title="(3)删除数据"></a>(3)删除数据</h3><p>​    DELETE FROM 表名 [WHERE 条件];</p><h2 id="3-DQL-数据查询语言"><a href="#3-DQL-数据查询语言" class="headerlink" title="3.DQL(数据查询语言)"></a>3.DQL(数据查询语言)</h2><p>SELECT 字段列表 FROM 表名列表 WHERE 条件列表 GROUP BY 分组字段列表 HAVING 分组后条件列表 ORDER BY 排序字段列表 LIMIT 分页参数</p><h3 id="DQL-执行顺序"><a href="#DQL-执行顺序" class="headerlink" title="DQL 执行顺序"></a>DQL 执行顺序</h3><p>FROM 表名列表 WHERE 条件列表 GROUP BY 分组字段列表 HAVING 分组后条件列表 SELECT 字段列表 ORDER BY 排序字段列表 LIMIT 分页参数</p><h3 id="1-基本查询"><a href="#1-基本查询" class="headerlink" title="(1)基本查询"></a>(1)基本查询</h3><p>​    查询多个字段</p><p>​    SELECT 字段1,字段2,字段3,… FROM 表名;</p><p>​    SELECT * FROM 表名;</p><p>​    设置别名</p><p>​    SELECT 字段1[AS 别名1], 字段2[AS 别名2] … FROM 表名;</p><p>​    去除重复记录</p><p>​    SELECT DISTINCT 字段列表 FROM 表名;</p><h3 id="2-条件查询-WHERE"><a href="#2-条件查询-WHERE" class="headerlink" title="(2)条件查询(WHERE)"></a>(2)条件查询(WHERE)</h3><p>​    SELECT 字段列表 FROM 表名 WHERE 条件列表;</p><p>​    条件</p><p>A.比较运算符</p><p>= &lt; &lt;= = </p><p>&lt;&gt;或!= 不等于</p><p>BETWEEN…AND… 在某个范围之内(含最小、最大值)</p><p>IN(…) 在IN之后的列表中的值，多选一</p><p>LIKE 占位符 模糊匹配(_匹配单个字符，%匹配任意个字符)</p><p>IS NULL 是NULL</p><p>B.逻辑运算符</p><p>AND 或 &amp;&amp; 并且(多个条件同时成立)</p><p>OR 或 || 或者(多个条件任意一个成立)</p><p>NOT 或 ! 非，不是</p><h3 id="3-聚合函数-COUNT-MAX-MIN-AVG-SUM"><a href="#3-聚合函数-COUNT-MAX-MIN-AVG-SUM" class="headerlink" title="(3)聚合函数(COUNT,MAX,MIN,AVG,SUM)"></a>(3)聚合函数(COUNT,MAX,MIN,AVG,SUM)</h3><p>将数据作为整体，进行纵向计算。</p><p>count    统计数量</p><p>max    最大值</p><p>min    最小值</p><p>avg    平均值</p><p>sum    求和</p><p>SELECT 聚合函数(字段列表) FROM 表名;</p><h3 id="4-分组查询-GROUP-BY"><a href="#4-分组查询-GROUP-BY" class="headerlink" title="(4)分组查询(GROUP BY)"></a>(4)分组查询(GROUP BY)</h3><p>SELECT 字段列表 FROM 表名 [WHERE 条件] GROUP BY 分组字段名 [HAVING 分组后过滤条件];</p><p>​    where与having区别</p><p>​    执行时机不同：where是分组之前进行过滤，不满足where条件，不参与分组;而having是分组之后对结果进行过滤。</p><p>​    判断条件不同：where不能对聚合函数进行判断，而having可以。</p><p>执行顺序：where&gt;聚合函数&gt;having</p><h3 id="5-排序查询-ORDER-BY"><a href="#5-排序查询-ORDER-BY" class="headerlink" title="(5)排序查询(ORDER BY)"></a>(5)排序查询(ORDER BY)</h3><p>SELECT 字段列表 FROM 表名 RODER BY 字段1 排序方式1,字段2 排序方式2;</p><p>排序方式</p><p>ASC:升序(默认值)</p><p>DESC:降序</p><h3 id="6-分页查询-LIMIT"><a href="#6-分页查询-LIMIT" class="headerlink" title="(6)分页查询(LIMIT)"></a>(6)分页查询(LIMIT)</h3><p>SELECT 字段列表 FROM 表名 LIMIT 起始索引,查询记录数;</p><p>起始索引从0开始，起始索引=(查询页码-1) * 每页显示记录数</p><h2 id="4-DCL"><a href="#4-DCL" class="headerlink" title="4.DCL"></a>4.DCL</h2><h3 id="1-管理用户"><a href="#1-管理用户" class="headerlink" title="(1)管理用户"></a>(1)管理用户</h3><p>​    查询用户</p><p>​    USE mysql;</p><p>​    SELECT * FROM user;</p><p>​    创建用户</p><p>​    CREATE USER ‘用户名‘@’主机名’ IDENTIFIED BY ‘密码’;</p><p>​    修改用户密码</p><p>​    ALTER USER ‘用户名‘@’主机名’ IDENTIFIED WITH mysql_native_password BY ‘新密码’;</p><p>​    删除用户</p><p>​    DROP USER ‘用户名‘@’主机名’;</p><h3 id="2-权限控制"><a href="#2-权限控制" class="headerlink" title="(2)权限控制"></a>(2)权限控制</h3><p>ALL,ALL PRIVILEGES    所有权限</p><p>SELECT    查询数据</p><p>INSERT    插入数据</p><p>UPDATE    修改数据</p><p>DELETE    删除数据</p><p>ALTER    修改表</p><p>DROP    删除数据库/表/视图</p><p>CREATE    创建数据库/表</p><p>​    查询权限</p><p>​    SHOW GRANTS FOR ‘用户名‘@’主机名’;</p><p>​    授予权限</p><p>​    GRANT 权限列表 ON 数据库名.表名 TO ‘用户名‘@’主机名’;</p><p>​    撤销权限</p><p>​    REVOKE 权限列表 ON 数据库名.表名 FROM ‘用户名‘@’主机名’;</p><h2 id="5-函数"><a href="#5-函数" class="headerlink" title="5.函数"></a>5.函数</h2><h3 id="1-字符串函数"><a href="#1-字符串函数" class="headerlink" title="(1)字符串函数"></a>(1)字符串函数</h3><p>CONCAT(S1,S2,…Sn)    字符串拼接，将S1,S2,..Sn拼接成一个字符串</p><p>LOWER(str)    将字符串str全部转为小写</p><p>UPPER(str)    将字符串str全部转为大写</p><p>LPAD(str,n,pad)    左填充，用字符串pad对str的左边进行填充，达到n个字符串长度</p><p>RPAD(str,n,pad)    左填充，用字符串pad对str的右边进行填充，达到n个字符串长度</p><p>TRIM(str)    去掉字符串头部和尾部的空格</p><p>SUBSTRING(str,start,len)    返回从字符串str从start位置起的len个长度的字符串</p><h3 id="3-数值函数"><a href="#3-数值函数" class="headerlink" title="(3)数值函数"></a>(3)数值函数</h3><p>CEIL(x)    向上取整</p><p>FLOOR(x)    向下取整</p><p>MOD(x,y)    返回x/y的模</p><p>RAND()    返回0-1内的随机数</p><p>ROUND(x,y)    求参数x的四舍五入的值，保留y位小数</p><h3 id="4-日期函数"><a href="#4-日期函数" class="headerlink" title="(4)日期函数"></a>(4)日期函数</h3><p>CURDATE()    返回当前日期</p><p>CURTIM()    返回当前时间</p><p>NOW()    返回当前日期和时间</p><p>YEAR(date)    获取指定date的年份</p><p>MONTH(date)    获取指定date的月份</p><p>DAY(date)    获取指定date的日期</p><p>DATE_ADD(date,INTERVAL expr type)    返回一个日期/时间值加上一个时间间隔expr后的时间值</p><p>DATEDIFF(date1,date2)    返回起始时间date1和结束时间date2之间的天数</p><h3 id="5-流程控制"><a href="#5-流程控制" class="headerlink" title="(5)流程控制"></a>(5)流程控制</h3><p>IF(value,t,f)    如果value为true,则返回t,否则返回f</p><p>IFNULL(value1,value2)    如果value1不为空，返回value1,否则返回value2</p><p>CASE WHEN [val1] THEN [res1] … ELSE [default] END    如果val1为true,返回res1,…否则返回default默认值</p><p>CASE [expr] WHEN [val1] THEN [res1] …ELSE [default] END    如果expr的值等于val1，返回res1,…否则返回default默认值</p><h2 id="6-约束"><a href="#6-约束" class="headerlink" title="6.约束"></a>6.约束</h2><p>非空约束    限制该字段的数据不能为null    NOT NULL</p><p>唯一约束    保证该字段的所有数据都是唯一、不重复的    UNIQUE</p><p>主键约束    主键是一行数据的唯一标识，要求非空且唯一    PRIMARY KEY</p><p>默认约束    保存数据时，如果未指定该字段的值，则采用默认值    DEFAULT</p><p>检查约束    保证字段值满足某一个条件    CHECK</p><p>外键约束    用来让两张表的数据之间建立连接，保证数据的一致性和完整性</p><h4 id="外键约束"><a href="#外键约束" class="headerlink" title="外键约束"></a>外键约束</h4><p>​    添加外键 </p><p>​    CREATE TABLE 表名(</p><p>​    字段名 数据类型,</p><p>​    …</p><p>​    [CONSTRAINT] [外键名称] FOREIGN KEY (外键字段名) REFERENCES 主表(主表列名)</p><p>​    );</p><p>​    ALTER TABLE 表名 ADD CONSTRAINT 外键名称 FOREIGN KEY(外键字段名) REFERENCES 主表(主表列名);</p><p>​    删除/更新行为</p><p>​    NO ACTION    当在父表中删除/更新对应记录时，首先检查该记录是否有对应外键，如果有则不允许删除/更新。(与RESTRICT一致)</p><p>​    RESTRICT    当在父表中删除/更新对应记录时，首先检查该记录是否有对应外键，如果有则不允许删除/更新。(与NO ACTION一致)</p><p>​    CASCADE    当在父表中删除/更新对应记录时，首先检查该记录是否有对应外键，如果有，则也则删除/更新外键在子表中的记录。</p><p>​    SET NULL    当在父表中删除对应记录时，首先检查该记录是否有对应外键，如果有则设置子表中该外键为null(这就要求该外键允许取null)。</p><p>​    SET DEFAULT    父表有变更时，子表将外键列设置成一个默认的值(Innodb不支持)</p><p>ALTER TABLE 表名 ADD CONSTRAINT 外键名称 FOREIGN KEY (外键字段) REFERENCES 主表名(主表字段名) ON UPDATE CASCADE ON DELETE CASCADE;</p><h2 id="7-多表查询"><a href="#7-多表查询" class="headerlink" title="7.多表查询"></a>7.多表查询</h2><h3 id="1-多表关系"><a href="#1-多表关系" class="headerlink" title="(1)多表关系"></a>(1)多表关系</h3><h4 id="A-一对多-多对一"><a href="#A-一对多-多对一" class="headerlink" title="A.一对多(多对一)"></a>A.一对多(多对一)</h4><h4 id="B-多对多"><a href="#B-多对多" class="headerlink" title="B.多对多"></a>B.多对多</h4><p>建立中间表，至少包含两个外键，分别关联两方主键</p><h4 id="C-一对一"><a href="#C-一对一" class="headerlink" title="C.一对一"></a>C.一对一</h4><p>任意一方加入外键，关联另一方的主键，并且设置外键为唯一的</p><h3 id="2-多表查询概述"><a href="#2-多表查询概述" class="headerlink" title="(2)多表查询概述"></a>(2)多表查询概述</h3><p>笛卡尔积：两个集合A和B的所有组合情况(在多表查询时，需要消除无效的笛卡尔积)</p><h3 id="3-多表查询分类"><a href="#3-多表查询分类" class="headerlink" title="(3)多表查询分类"></a>(3)多表查询分类</h3><h4 id="A-连接查询"><a href="#A-连接查询" class="headerlink" title="A.连接查询"></a>A.连接查询</h4><h5 id="1-内连接：相当于查询A、B交集部分数据"><a href="#1-内连接：相当于查询A、B交集部分数据" class="headerlink" title="(1)内连接：相当于查询A、B交集部分数据"></a>(1)内连接：相当于查询A、B交集部分数据</h5><p>​    隐式内连接</p><p>​    SELECT 字段列表 FROM 表1,表2 WHERE 条件 …;</p><p>​    显示内连接</p><p>​    SELECT 字段列表 FROM 表1 [INNER] JOIN 表2 ON 连接条件…;</p><h5 id="2-外连接："><a href="#2-外连接：" class="headerlink" title="(2)外连接："></a>(2)外连接：</h5><h6 id="左外连接：查询左表所有数据，以及两张表交集部分的数据"><a href="#左外连接：查询左表所有数据，以及两张表交集部分的数据" class="headerlink" title="左外连接：查询左表所有数据，以及两张表交集部分的数据"></a>左外连接：查询左表所有数据，以及两张表交集部分的数据</h6><p>​    SELECT 字段列表 FROM 表1 LEFT [OUTER] JOIN 表2 ON 连接条件…;</p><h6 id="右外连接：查询右表所有数据，以及两张表交集部分数据"><a href="#右外连接：查询右表所有数据，以及两张表交集部分数据" class="headerlink" title="右外连接：查询右表所有数据，以及两张表交集部分数据"></a>右外连接：查询右表所有数据，以及两张表交集部分数据</h6><p>​    SELECT 字段列表 FROM 表1 RIGHT [OUTER] JOIN 表2 ON 连接条件…;</p><h5 id="3-自连接：当前表与自身的连接查询，自连接必须使用表别名"><a href="#3-自连接：当前表与自身的连接查询，自连接必须使用表别名" class="headerlink" title="(3)自连接：当前表与自身的连接查询，自连接必须使用表别名"></a>(3)自连接：当前表与自身的连接查询，自连接必须使用表别名</h5><p>​    SELECT 字段列表 FROM 表1 别名A,表2 别名B WHERE 条件 …;</p><p>​    SELECT 字段列表 FROM 表A 别名A JOIN 表A 别名B ON 条件 …;</p><h4 id="B-联合查询-union-union-all"><a href="#B-联合查询-union-union-all" class="headerlink" title="B.联合查询  union, union all"></a>B.联合查询  union, union all</h4><p>把多次查询的结果合并起来，形成一个新的查询结果集。</p><p>SELECT 字段列表 FROM 表A …</p><p>UNION [ALL]</p><p>SELECT 字段列表 FROM 表B …;</p><p>对于联合查询的多张表的列数必须保持一致，字段类型也需要保持一致。</p><p>union all 会将全部的数据直接合并在一起，union会对合并之后的数据去重</p><h4 id="C-子查询"><a href="#C-子查询" class="headerlink" title="C.子查询"></a>C.子查询</h4><p>SQL语句中嵌套SELECT语句，称为嵌套查询，又称子查询。外部的语句可以是INSERT/UPDATE/DELETE/SELECT中任何一个。</p><p>SELECT * FROM t1 WHERE column1 = (SELECT column1 FROM t2);</p><p>根据子查询结果不同，分为：</p><p>标量子查询（子查询结果为单个值）</p><p>列子查询（子查询结果为一列）</p><p>行子查询（子查询结果为一行）</p><p>表子查询（子查询结果为多行多列）</p><h2 id="8-事务"><a href="#8-事务" class="headerlink" title="8.事务"></a>8.事务</h2><p>事务是一组操作的集合，是一个不可分割的工作单位，事务会把所有的操作作为一个整体一起向系统提交或撤销操作请求，即这些操作要么同时成功，要么同时失败,整个事务回滚（rollback）到最初的状态。</p><h3 id="1-事务操作"><a href="#1-事务操作" class="headerlink" title="(1)事务操作"></a>(1)事务操作</h3><h4 id="1-显示事务"><a href="#1-显示事务" class="headerlink" title="1.显示事务"></a>1.显示事务</h4><h5 id="1-事务完成过程"><a href="#1-事务完成过程" class="headerlink" title="1.事务完成过程"></a>1.事务完成过程</h5><p>1.开启事务</p><p>start transaction 或 BEGIN</p><p>start transaction 后面可以跟：read only/ read write(默认)/with consistent snapshot(启动一致性读)</p><p>2.一系列的DML操作</p><p>3.事务结束的状态：提交事务(COMMIT)、中止事务(ROLLBACK/ROLLBACK TO [SAVEPOINT]) </p><p>SAVEPOINT相关操作：</p><p>在事务中创建保存点，方便后续针对保存点进行回滚</p><p>SAVEPOINT    保存点名称；</p><p>删除某个保存点</p><p>RELEASE SAVEPOINT 保存点名称；</p><h4 id="2-隐式事务"><a href="#2-隐式事务" class="headerlink" title="2.隐式事务"></a>2.隐式事务</h4><p>系统变量 @@autocommit:</p><p>查看/设置事务提交方式</p><p>SELECT @@autocommit;     //为1自动提交</p><p>SET @@autocommit = 0;    //设置手动提交 </p><p>关闭自动提交</p><p>方式1：</p><p>SET autocommit = FALSE;    针对于DML操作是有效的，对DDL操作是无效的。</p><p>方式2：</p><p>在autocommit为true的情况下，使用start transaction或begin开启事务，那么DML操作就不会自动提交数据；</p><p>默认情况下（autocommit为true），没有开启事务，DML操作也会自动提交数据。</p><p>提交事务</p><p>COMMIT;</p><p>回滚事务</p><p>ROLLBACK;</p><p>开启事务</p><p>START TRANSACTION 或 BEGIN</p><p>提交事务</p><p>COMMIT;</p><p>回滚事务</p><p>ROLLBACK;</p><h4 id="3-隐式提交数据的情况"><a href="#3-隐式提交数据的情况" class="headerlink" title="3.隐式提交数据的情况"></a>3.隐式提交数据的情况</h4><p>1.数据定义语言(DDL)</p><p>2.隐式使用或修改mysql数据库中的表</p><p>3.事务控制或关于锁定的语句</p><p>​    1.在一个事务还没提交或者回滚时就又用START TRANSACTION或者BEGIN语句开启了另一个事务时，会隐式的提交上一个事务。</p><p>​    2.当前的autocommit系统变量的值为OFF，我们手动把它调为ON时，也会隐式的提交前边语句所属的事务。</p><p>​    3.使用LOCK TABLES、UNLOCK TABLES等关于锁定的语句也会隐式的提交前边语句所属的事务。</p><p>4.加载数据的语句</p><p>使用LOAD DATA 语句来批量往数据库中导入数据时，也会隐式的提交前边语句所属的事务。</p><p>5.关于MYSQL复制的一些语句</p><p>使用START SLAVE、STOP ALAVE、RESET SLAVE、CHANGE MASTER TO 等语句时会隐式的提交前边语句所属的事务。</p><p>6.其他的一些语句</p><p>使用ANALYZE TABLE、CHAHE INDEX、CHECK TABLE、FLUSH、LOAD INDEX INFO CACHE、OPTIMIZE TABLE、REPAIR TABLE、RESET等语句也会隐式的提交前边语句所属的事务。</p><h3 id="2-事务四大特性-ACID"><a href="#2-事务四大特性-ACID" class="headerlink" title="(2)事务四大特性(ACID)"></a>(2)事务四大特性(ACID)</h3><h4 id="原子性-Atomicity-：事务是不可分割的最小操作单元，要么全部成功，要么全部失败。"><a href="#原子性-Atomicity-：事务是不可分割的最小操作单元，要么全部成功，要么全部失败。" class="headerlink" title="原子性(Atomicity)：事务是不可分割的最小操作单元，要么全部成功，要么全部失败。"></a>原子性(Atomicity)：事务是不可分割的最小操作单元，要么全部成功，要么全部失败。</h4><h4 id="一致性-Consistency-：事务完成时，必须使所有的数据都保持一致状态。"><a href="#一致性-Consistency-：事务完成时，必须使所有的数据都保持一致状态。" class="headerlink" title="一致性(Consistency)：事务完成时，必须使所有的数据都保持一致状态。"></a>一致性(Consistency)：事务完成时，必须使所有的数据都保持一致状态。</h4><p>定义：一致性是指事务执行前后，数据从一个合法性状态变换到另一个合法性状态，这种状态是语义上的而不是语法上的，跟具体业务有关。</p><h4 id="隔离性-Isolation-：数据库系统提供的隔离机制，保证事务在不受外部并发操作影响的独立环境下运行。"><a href="#隔离性-Isolation-：数据库系统提供的隔离机制，保证事务在不受外部并发操作影响的独立环境下运行。" class="headerlink" title="隔离性(Isolation)：数据库系统提供的隔离机制，保证事务在不受外部并发操作影响的独立环境下运行。"></a>隔离性(Isolation)：数据库系统提供的隔离机制，保证事务在不受外部并发操作影响的独立环境下运行。</h4><p>事务的隔离性是指一个事务的执行不能被其他事务干扰，即一个事务内部的操作及使用的数据对并发的其他事务是隔离的，并发执行的各个事务之间不能互相干扰。</p><h4 id="持久性-Durability-：事务一旦提交或回滚，它对数据库中的数据的改变就是永久的。"><a href="#持久性-Durability-：事务一旦提交或回滚，它对数据库中的数据的改变就是永久的。" class="headerlink" title="持久性(Durability)：事务一旦提交或回滚，它对数据库中的数据的改变就是永久的。"></a>持久性(Durability)：事务一旦提交或回滚，它对数据库中的数据的改变就是永久的。</h4><p>持久性是指一个事务一旦被提交，它对数据库中数据的改变就是永久性的，接下来的其他操作和数据库故障不应该对其有任何影响。</p><p>持久性是通过事务日志来保证的。日志包括了重做日志和回滚日志。当我们通过事务对数据进行修改的时候，首先会将数据库的变化信息记录到重做日志中，然后再对数据库中对应的行进行修改。这样做的好处是，即使数据库系统崩溃，数据库重启后也能找到没有更新到数据库系统中的重做日志，重新执行，从而使事务具有持久性。</p><p>总结：</p><p>ACID是事务的四大特性，在这四个特性中，原子性是基础，隔离性是手段，一致性是约束条件，而持久性是我们的目的。</p><p>数据库事务，其实就是数据库设计者为了方便起见，把需要保证原子性、隔离性、一致性和持久性的一个或多个数据库操作称为一个事务。</p><h3 id="3-事务的状态"><a href="#3-事务的状态" class="headerlink" title="(3)事务的状态"></a>(3)事务的状态</h3><p>事务是一个抽象的概念，对应着一个或多个数据库操作，mysql根据这些操作所执行的不同阶段把事务大致划分成几个状态：</p><p>1.活动的（active）</p><p>事务对应的数据库操作正在执行过程中时，该事务处于活动的状态的。</p><p>2.部分提交的（partially committed）</p><p>当事务中的最后一个操作执行完成，但由于操作都在内存中执行，所造成的影响并没有刷新到磁盘时，我们就说该事务处在部分提交的状态。</p><p>3.失败的（failed）</p><p>当事务处在活动的或者部分提交的状态时，可能遇到了某些错误（数据库自身的错误、操作系统错误或者直接断电等）而无法继续执行，或者人为的停止当前事务的执行，我们就说该事务处于失败的状态。</p><p>4.中止的（aborted）</p><p>如果事务执行了一部分而变为失败的状态，那么就需要把已经修改的事务中的操作还原到事务执行前的状态。换句话说，就是要撤销失败事务对当前数据库造成的影响。我们把这个撤销的过程称之为回滚。当回滚操作执行完毕时，也就是数据库恢复到了执行事务之前的状态，我们就说该事务处在了中止的状态。</p><p>5.提交的（committed）</p><p>当一个处在部分提交的状态的事务将修改过的数据都同步到磁盘上之后，我们就可以说该事物处在了提交的状态。</p><p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220308154544445.png" alt="image-20220308154544445"></p><h3 id="4-数据并发问题"><a href="#4-数据并发问题" class="headerlink" title="(4)数据并发问题"></a>(4)数据并发问题</h3><p>访问相同数据的事务在不保证串行执行的情况下可能出现的问题：</p><p>1.脏写（dirty write）</p><p>对于两个事务Session A、Session B，如果事务Session A修改了另一个未提交事务Session B修改过的数据，那就意味着发生了脏写。</p><p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220308171606373.png" alt="image-20220308171606373"></p><p>2.脏读（dirty read）</p><p>对于两个事务Session A、Session B，Session A读取了已经被Session B更新但还没有被提交的字段。之后若Session B回滚，Session A读取的内容就是临时且无效的。</p><p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220308171855243.png" alt="image-20220308171855243"></p><p>3.不可重复读（non-repeatable read）</p><p>对于两个事务Session A、Session B，Session A读取了一个字段，然后Session B更新了该字段。之后Session A再次读取同一个字段，值就不同了。那就意味着发生了不可重复读。</p><p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220308172529673.png" alt="image-20220308172529673"></p><p>4.幻读（Phantom）</p><p>对于两个事务Session A、Session B，Session A从一个表中读取了一个字段，然后Session B在该表中插入了一些新的行。之后，如果Session A再次读取同一个表，就会多出几行。那就意味着发生了幻读。</p><p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220308173031168.png" alt="image-20220308173031168"></p><p>注意：对于Session B中删除了一些符合的记录而不是插入新记录，那Session A之后根据条件读取的记录变少了，这种不算幻读，幻读强调的是一个事务按照某个相同条件多次读取记录时，后读取时读到了之前没有读到的记录。</p><p><strong>脏读</strong>    一个事务读到另外一个事务还没有提交的数据。</p><p><strong>不可重复读</strong>    一个事务先后读取同一条记录，但两次读取的数据不同，称之为不可重复读。</p><p><strong>幻读</strong>    一个事务按照条件查询数据时，没有对应的数据行，但是在插入数据时，又发现这行数据已经存在，好像出现了“幻影”。</p><p>严重性排序：</p><p>脏写 &gt; 脏读 &gt; 不可重复读 &gt; 幻读</p><h3 id="5-事务隔离级别"><a href="#5-事务隔离级别" class="headerlink" title="(5)事务隔离级别"></a>(5)事务隔离级别</h3><p>1.SQL四种隔离级别：</p><ol><li>READ UNCOMMITTED：读未提交，在该隔离级别，所有事务都可以看到其它未提交事务的执行结果。不能避免脏读、不可重复读、幻读</li><li>READ COMMITTED：读已提交，它满足了隔离的简单定义：一个事务只能看见已经提交事务所做的改变。这是大多数数据库系统的默认隔离级别（但不是MySQL默认的）。可以避免脏读，但不可重复读、幻读问题仍然存在。</li><li>REPEATABLE READ：可重复读，事务A在读到一条数据后，此时事务B对该数据进行了修改并提交，那么事务A再读该数据，读到的还是原来的内容。可以避免脏读、不可重复读，但幻读问题仍然存在。这是MySQL的默认隔离级别。</li><li>SERIALIZABLE：可串行化，确保事务可以从一个表中读取相同的行。在这个事务持续期间，禁止其他事务对该表执行插入、更新和删除操作。所有的并发问题都可以避免，但性能十分低下。能避免脏读、不可重复读和幻读。</li></ol><p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220308180134114.png" alt="image-20220308180134114"></p><p>MySQL中隔离级别</p><p>隔离级别                                脏读                不可重复读                幻读</p><p>Read uncommitted                √                            √                            √</p><p>Read committed                    ×                            √                            √</p><p>Repeatable Read(默认)        ×                                ×                            √</p><p>Serializable                            ×                                ×                            ×</p><p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220308180028956.png" alt="image-20220308180028956"></p><p>查看事务隔离级别</p><p>SELECT @@TRANSACTION_ISOLATION;</p><p>设置事务隔离级别</p><p>SET [SESSION | GLOBAL] TRANSACTION ISOLATION LEVEL {READ UNCOMMITTED | READ COMMITTED | REPEATABLE READ | SERIALIZABLE}</p><p>设置时使用GLOBAL或SESSION的影响：</p><p>1.使用GLOBAL关键字（在全局范围影响）：</p><p>​    1.当前已经存在的会话无效</p><p>​    2.只对执行完该语句之后产生的会话起作用</p><p>2.使用SESSION关键字（在会话范围影响）：</p><p>​    1.对当前会话的所有后续的事务有效</p><p>​    2.如果在事务之间执行，则对后续的事务有效</p><p>​    3.该语句可以在已经开始的事务中间执行，但不会影响当前正在执行的事务。</p><p><strong>幻读的解决方案</strong></p><p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220308183042221.png" alt="image-20220308183042221"></p><h2 id="9-MYSQL事务日志"><a href="#9-MYSQL事务日志" class="headerlink" title="9.MYSQL事务日志"></a>9.MYSQL事务日志</h2><p>事务的四种特性：原子性、一致性、隔离性和持久性。四种特性基于什么机制实现？</p><p>1.事务的隔离性由锁机制实现</p><p>2.事务的原子性、一致性、持久性由事务的redo日志和undo日志来保证。</p><p>​    REDO LOG称为重做日志，提供再写入操作，恢复提交事务修改的页操作，用来保证事务的持久性。</p><p>​    UNDO LOG称为回滚日志，回滚行记录到某个特定的版本，用来保证事务的原子性、一致性。</p><p>REDO和UNDO都可以视为是一种恢复操作，但是：</p><p>1.redo log：是存储引擎（innodb）生成的日志，记录的是“物理级别”上的页修改操作，比如页号xxx、偏移量yyy写入了’zzz’数据。主要为了保证数据的可靠性。</p><p>2.undo log：是存储引擎层（innodb）生成的日志，记录的是逻辑操作日志，比如对某一行数据进行了INSERT语句操作，那么undo log就记录一条与之相反的DELETE操作。主要用于事务的回滚（undo log记录的是每个修改操作的逆操作）和一致性非锁定读（undo log回滚行记录到某种特定的版本–MVCC，即多版本并发控制）。</p><h3 id="1-redo-日志"><a href="#1-redo-日志" class="headerlink" title="1.redo 日志"></a>1.redo 日志</h3><h4 id="1-为什么需要redo-日志"><a href="#1-为什么需要redo-日志" class="headerlink" title="1.为什么需要redo 日志"></a>1.为什么需要redo 日志</h4><p>在事务提交完成之前把该事务所修改的所有页面都刷新到磁盘，但是这个做法有些问题：</p><p>1.修改量与刷新磁盘工作量严重不成比例</p><p>2.随机IO刷新较慢</p><p>InnoDB引擎的事务采用了WAL技术，这种技术的思想就是先写日志，再写磁盘，只有日志写入成功，才算事务提交成功，这里的日志就是redo log。当发生宕机且数据未刷到磁盘的时候，可以通过redo log来恢复，保证ACID中的持久性。</p><h4 id="2-redo日志的好处、特点"><a href="#2-redo日志的好处、特点" class="headerlink" title="2.redo日志的好处、特点"></a>2.redo日志的好处、特点</h4><h5 id="1-好处"><a href="#1-好处" class="headerlink" title="1.好处"></a>1.好处</h5><p>redo日志降低了刷盘频率</p><p>redo日志占用的空间非常小</p><p>存储表空间ID、页号、偏移量以及需要更新的值，所需要的存储空间是很小的，刷盘快。</p><h5 id="2-特点"><a href="#2-特点" class="headerlink" title="2.特点"></a>2.特点</h5><p>1.redo日志是顺序写入磁盘的</p><p>2.事务执行过程中，redo log不断记录</p><p>redo log和bin log的区别，redo log是存储引擎层产生的，而bin log是数据库产生的。假设一个事务，对表做10万行的记录插入，在这个过程中，一直不断的往redo log顺序记录，而bin log不会记录，直到这个事务提交，才会一次写入到bin log文件中。</p><h4 id="3-redo日志的组成"><a href="#3-redo日志的组成" class="headerlink" title="3.redo日志的组成"></a>3.redo日志的组成</h4><p>redo log分为两个部分：</p><p>1.重做日志的缓冲（redo log buffer)，保存在内存中，是易失的。</p><p>在服务器启动时就向操作系统申请了一大片称之为redo log buffer的连续内存空间，就是redo日志缓冲区。这片内存空间被划分成若干个连续的redo log block。一个redo log block占用512字节大小。</p><p>参数设置：innodb_log_buffer_size:</p><p>redo log buffer大小，默认16M，最大值是4096M，最小值为1M。</p><p>2.重做日志文件（redo log file），保存在硬盘中，是持久的。</p><p>ib_logfile0/ib_logfile1</p><h4 id="4-redo-整体流程"><a href="#4-redo-整体流程" class="headerlink" title="4.redo 整体流程"></a>4.redo 整体流程</h4><p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220309114054869.png" alt="image-20220309114054869"></p><h4 id="5-redo-log-的刷盘策略"><a href="#5-redo-log-的刷盘策略" class="headerlink" title="5.redo log 的刷盘策略"></a>5.redo log 的刷盘策略</h4><p>redo log的写入并不是直接写入磁盘的，InnoDB引擎会在写redo log的时候先写redo log的时候先写redo lg buffer，之后以一定的频率刷入都真正的redo log file中。这里的一定频率怎么看待呢？这就是我们要说的刷盘策略。</p><p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220309120522787.png" alt="image-20220309120522787"></p><p>注意，redo log buffer刷盘到redo log file的过程并不是真正的刷到磁盘中去，只是刷入到文件系统缓存(page cache)中去（这是现代操作系统为了提高文件写入效率做的一个优化），真正的写入会交给系统自己来决定（比如page cache足够大了）。那么对于InnoDB来说就存在一个问题，如果交给系统来同步，同样如果系统宕机，那么数据也丢失了（虽然整个系统宕机的概率还是比较小的）。</p><p>针对这种情况，InnoDB给出了innodb_flush_log_at_trx_commit参数，该参数控制commit提交事务时，如何将redo log buffer中的日志刷新到redo log file中。它支持三种策略：</p><p>1.设置为0：表示每次事务提交时不进行刷盘操作。（系统默认master thread每隔1s进行一次重做日志的同步）</p><p>2.设置为1：表示每次事务提交时都将进行同步，刷盘操作（默认值）</p><p>3.设置为2：表示每次事务提交时都只把redo log buffer内容写入page cache，不进行同步。由os自己决定什么时候同步到磁盘文件。</p><p>另外，InnoDB存储引擎有一个后台线程，每隔一秒，就会把redo log buffer中的内容写到文件系统缓存（page cache），然后调用刷盘操作。</p><p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220309122628033.png" alt="image-20220309122628033"></p><p>也就是说，一个没有提交事务的redo log记录，也可能会刷盘。因为在事务执行过程redo log记录是会写入redo log buffer中，这些redo log记录会被后台线程刷盘。</p><p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220309122924899.png" alt="image-20220309122924899"></p><p>除了后台线程每秒1次的轮询操作，还有一种情况，当redo log buffer占用的空间即将达到innodb_log_buffer_size（这个参数默认是16M）的一半的时候，后台线程会主动刷盘。</p><h4 id="6-不同刷盘演示"><a href="#6-不同刷盘演示" class="headerlink" title="6.不同刷盘演示"></a><strong>6.不同刷盘演示</strong></h4><p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220309123351821.png" alt="image-20220309123351821"></p><p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220309123458473.png" alt="image-20220309123458473"></p><p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220309123532027.png" alt="image-20220309123532027"></p><p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220309131146910.png" alt="image-20220309131146910"></p><h4 id="7-写入redo-log-buffer过程"><a href="#7-写入redo-log-buffer过程" class="headerlink" title="7.写入redo log buffer过程"></a>7.写入redo log buffer过程</h4><p><strong>1.补充概念：Mini-Transaction</strong></p><p>MYSQL把底层页面中的一次原子访问的过程称之为一个Mini-Transaction，简称mtr，比如，向某个索引对应的B+树中插入一条记录的过程就是一个Mini-Transaction。一个所谓的mtr可以包含一组redo日志，在进行崩溃恢复时这一组redo日志作为一个不可分割的整体。</p><p>一个事务可以包含若干条语句，每一条语句其实是由若干个mtr组成，每一个mtr又可以包含若干条redo日志，图示关系：</p><p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220309141615389.png" alt="image-20220309141615389"></p><p><strong>2.redo日志写入 log buffer</strong></p><p>向log buffer中写入redo日志的过程是顺序的，也就是先往前边的block中写，当该block的空闲空间用完之后再往下一个block中写。当我们想往log buffer中写入redo日志时，第一个遇到的问题就是应该写在哪个block的哪个偏移量处，所以InnoDB的设计者特意提供了一个称之为buf_free的全局变量，该变量指明后续写入的redo日志应该写入到log buffer中的哪个位置，如图所示：</p><p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220309142202489.png" alt="image-20220309142202489"></p><p>一个mtr执行过程中可能产生若干条redo日志，这些redo日志是一个不可分割的组，所以不是每生成一条redo日志，就将其插入到log buffer中，而是每个mtr运行过程中产生的日志先暂时存放到一个地方，当该mtr结束的时候，将过程中产生的一组redo日志再全部复制到log buffer中。</p><p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220309142723863.png" alt="image-20220309142723863"></p><p><strong>3.redo log block的结构图</strong></p><p>一个redo log block是由日志头、日志体、日志尾组成。日志头占用12字节，日志尾占用8字节，所以一个block真正能存储的数据就是512-12-8=492字节。</p><p>一个block设计成512字节，和磁盘的扇区有关，机械磁盘默认扇区就是512字节。</p><p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220309143429579.png" alt="image-20220309143429579"></p><h4 id="8-redo-log-file"><a href="#8-redo-log-file" class="headerlink" title="8.redo log file"></a>8.redo log file</h4><p>磁盘上的redo日志文件是以一个日志文件组的形式出现的，采用循环使用的方式向redo日志文件组里写数据。</p><p>checkpoint来防止后写入的redo日志覆盖掉前边的redo日志。</p><p>write pos：是当前记录的位置，一边写一边后移</p><p>checkpoint：是当前要擦除的位置，也是往后推移</p><p>每次刷盘redo log记录到日志文件组中，write pos位置就会后移更新。每次MYSQL加载日志文件组恢复数据时，会清空加载过的redo log记录，并把checkpoint后移更新。write pos和checkpoint之间的还空着的部分可以用来写入新的redo log记录。</p><p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220309151317492.png" alt="image-20220309151317492"></p><p>如果write pos追上checkpoint，表示日志文件组满了，这时候不能再写入新的redo log记录，MYSQL得停下来，清空一些记录，把checkpoint推进。</p><p>小结：</p><p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220309151702677.png" alt="image-20220309151702677"></p><h3 id="2-Undo日志"><a href="#2-Undo日志" class="headerlink" title="2.Undo日志"></a>2.Undo日志</h3><p>redo log是事务持久性的保证，undo log是事务原子性的保证。在事务中更新数据的前置操作其实是要先写入一个undo log。</p><h4 id="1-如何理解Undo日志"><a href="#1-如何理解Undo日志" class="headerlink" title="1.如何理解Undo日志"></a>1.如何理解Undo日志</h4><p>事务需要原子性，也就是事务中的操作要么全部完成，要么什么也不做。但是有时候事务执行到一半会出现一些情况，比如：</p><p>1.事务执行过程中可能遇到各种错误，比如服务器本身的错误，操作系统错误，甚至是突然断电导致的错误。</p><p>2.程序员可以在事务执行过程中手动输入ROLLBACK语句结束当前事务的执行。</p><p>以上这种情况，我们需要把数据改回原来的样子，这个过程为回滚，这样就造成一个假象：这个事务看起来什么都没做，所以符合原子性要求。每当我们要对一条记录做改动时（INSERT、DELETE、UPDATE）</p><p>MYSQL把这些为了回滚而记录的这些内容称之为撤销日志或者回滚日志。注意，由于查询操作（SELECT）并不会修改任何用户记录，所以在查询操作执行前，并不记录相应的undo日志。</p><p>此外，undo log会产生redo log，也就是undo log的产生会伴随着redo log的产生，这是因为undo log也需要持久性的保护。</p><h4 id="2-Undo日志作用"><a href="#2-Undo日志作用" class="headerlink" title="2.Undo日志作用"></a>2.Undo日志作用</h4><p>1.回滚数据</p><p>undo是逻辑日志，只是将数据库逻辑恢复到原来的样子</p><p>2.MVCC</p><h4 id="3-undo的存储结构"><a href="#3-undo的存储结构" class="headerlink" title="3.undo的存储结构"></a>3.undo的存储结构</h4><p><strong>1.回滚段与undo页</strong></p><p>InnoDB对undo log的管理采用段的方式，也就是回滚段(rollback segment)。每个回滚段记录了1024个undo log segment，而在每个undo log segment段中进行undo页的申请。</p><p>undo页的重用</p><p>当我们开启一个事务需要写undo log的时候，就得先去undo log seg segment中去找到一个空闲的位置，当有空位的时候，就去申请undo页，在这个申请到的undo页中进行undo log的写入。</p><p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220309160525716.png" alt="image-20220309160525716"></p><p><strong>2.回滚段与事务</strong></p><p>1.每个事务只会使用一个回滚段，一个回滚段在同一时刻可能会服务于多个事务。</p><p>2.当一个事务开始的时候，会制定一个回滚段，在事务进行的过程中，当数据被修改时，原始数据会被复制到回滚段。</p><p>3.在回滚段中，事务会不断填充盘区，直到事务结束或所有的空间被用完。如果当前的盘区不够用，事务会在段中请求扩展下一个盘区，如果所有已分配的盘区都被用完，事务会覆盖最初的盘区或者在回滚段允许的情况下扩展新的盘区来使用。</p><p>4.回滚段存在于undo表空间中，在数据库中可以存在多个undo表空间，但同一时刻只能使用一个undo表空间。</p><p>5.当事务提交时，InnoDB存储引擎会做以下两件事情：</p><p>1.将undo log放入列表中，以供之后的purge操作</p><p>2.判断undo log所在的页是否可以重用，若可以，分配给下个事务使用</p><p><strong>3.回滚段中的数据分类</strong></p><p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220309162304301.png" alt="image-20220309162304301"></p><h4 id="4-undo的类型"><a href="#4-undo的类型" class="headerlink" title="4.undo的类型"></a>4.undo的类型</h4><p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220309162536149.png" alt="image-20220309162536149"></p><h4 id="5-undo-log的生命周期"><a href="#5-undo-log的生命周期" class="headerlink" title="5.undo log的生命周期"></a>5.undo log的生命周期</h4><p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220309162749543.png" alt="image-20220309162749543"></p><p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220309162915181.png" alt="image-20220309162915181"></p><p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220309162944888.png" alt="image-20220309162944888"></p><p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220309163228353.png" alt="image-20220309163228353"></p><p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220309163314504.png" alt="image-20220309163314504"></p><p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220309163401376.png" alt="image-20220309163401376"></p><p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220309163443895.png" alt="image-20220309163443895"></p><p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220309163734636.png" alt="image-20220309163734636"></p><p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220309163909494.png" alt="image-20220309163909494"></p><h2 id="一、存储引擎"><a href="#一、存储引擎" class="headerlink" title="一、存储引擎"></a>一、存储引擎</h2><p>在建表时指定存储引擎CREATE TABLE 表名 () ENGINE = INNODB</p><p>查看当前数据库支持的存储引擎</p><p>SHOW ENGINES;</p><h2 id="二、索引"><a href="#二、索引" class="headerlink" title="二、索引"></a>二、索引</h2><h3 id="1、索引"><a href="#1、索引" class="headerlink" title="1、索引"></a>1、索引</h3><p>索引(index)是帮助MYSQL高效获取数据的数据结构(有序)。</p><p>优势：提高数据检索的效率，降低数据库的IO成本；创建唯一索引，保证数据的唯一性；加速表与表之间的连接；减少查询中分组和排序的时间，通过索引列对数据进行排序，降低数据排序的成本，降低CPU的消耗。</p><p>劣势：创建索引和维护索引要耗费时间；索引列也是要占用空间的，存在磁盘上；索引大大提高了查询效率，同时却也降低更新表的速度，如对表进行INSERT、UPDATE、DELETE时，效率降低。</p><h3 id="2、索引结构"><a href="#2、索引结构" class="headerlink" title="2、索引结构"></a>2、索引结构</h3><p>B+Tree索引                最常见的索引类型，大部分引擎都支持B+树索引</p><p>Hash索引                    底层数据结构是用哈希表实现的，只有精确匹配索引列的查询才有效，不支持范围查询</p><p>R-tree(空间索引)        空间索引是MyISAM引擎的一个特殊索引类型，主要用于地理空间数据类型，通常使用较少</p><p>Full-text(全文索引)    是一种通过建立倒排索引，快速匹配文档的方式、类似于Lucene,Solr,ES</p><p>B+Tree</p><p>MYSQL索引数据结构对经典的B+Tree进行了优化。在原B+Tree的基础上，增加一个指向相邻叶子节点的链表指针，就形成了带有顺序指针的B+Tree，提高区间访问的性能。</p><p>Hash</p><p>哈希索引就是采用一定的hash算法，将键值换算成新的hash值，映射到对应的槽位上，然后存储在hash表中。</p><h3 id="3、索引分类"><a href="#3、索引分类" class="headerlink" title="3、索引分类"></a>3、索引分类</h3><p>主键索引                针对于表中主键创建的索引                                                            默认自动创建，只能有一个            PRIMARY</p><p>唯一索引                避免同一个表中某数据列中的值重复                                            可以有多个                                        UNIQUE</p><p>常规索引                快速定位特定数据                                                                            可以有多个                                    </p><p>全文索引                全文索引查找的是文本中的关键词，而不是比较索引中的值        可以有多个                                        FULLTEXT</p><p>根据索引的存储形式分类：</p><p>聚集索引(Clustered Index)                将数据存储与索引放到了一块，索引结构的叶子节点保存了行数据                必须有，而且只有一个</p><p>二级索引(Secondary Index)(辅助索引)                将数据与索引分开存储，索引结构的叶子节点关联的是对应的主键                可以存在多个</p><p>聚集索引选取规则：</p><p>如果存在主键，主键索引就是聚集索引。</p><p>如果不存在主键，将使用第一个唯一索引作为聚集索引。</p><h3 id="4、索引语法"><a href="#4、索引语法" class="headerlink" title="4、索引语法"></a>4、索引语法</h3><h4 id="A-创建索引"><a href="#A-创建索引" class="headerlink" title="A.创建索引"></a>A.创建索引</h4><p>CREATE [UNIQUE|FULLTEXT] INDEX index_name ON table_name (index_col_name,…);</p><p>such as:</p><p>CREATE INDEX idx_user_name ON tb_user(name);</p><p>CREATE UNIQUE INDEX idx_user_phone ON tb_user(phone);</p><p>CREATE INDEX idx_user_pro_age_ata ON tb_user(profession,age,status);</p><h4 id="B-查看索引"><a href="#B-查看索引" class="headerlink" title="B.查看索引"></a>B.查看索引</h4><p>SHOW INDEX FROM table_name;</p><h4 id="C-删除索引"><a href="#C-删除索引" class="headerlink" title="C.删除索引"></a>C.删除索引</h4><p>DROP INDEX index_name ON table_name;</p><h3 id="5、SQL性能分析"><a href="#5、SQL性能分析" class="headerlink" title="5、SQL性能分析"></a>5、SQL性能分析</h3><p>SQL执行频率</p><p>SHOW GLOBAL STATUS LIKE ‘Com______’;</p><p>慢查询日志</p><p>/etc/my,cnf</p><p>#开启Mysql慢日志查询开关</p><p>slow_query_log = 1</p><p>#设置慢日志的时间为2秒，SQL语句执行时间超过2秒，就会视为慢查询，记录慢查询日志</p><p>long_query_time=2</p><p>profile详情</p><p>show profiles 能够在做SQL优化时帮助我们了解时间耗费。通过having_profiling参数，能够看到当前Mysql是否支持profile操作：</p><p>SELECT @@have_profiling;</p><p>通过set语句在session/global级别开启profiling:</p><p>SET profiling=1;</p><p>explain执行计划</p><p>EXPLAIN或者DESC命令获取Mysql如何执行SELECT语句的信息，包括在SELECT语句执行过程中表如何连接和连接的顺序。</p><p>explain select 字段列表 from 表名 where 条件;</p><p>EXPLAIN执行计划各字段含义：</p><p>id：select查询的序列号，表示查询中执行select子句或者是操作表的顺序(id相同，执行顺序从上到下；id不同，值越大，越先执行)。</p><p>select_type：表示SELECT的类型，常见的取值有SIMPLE(简单表，即不是用表连接或者子查询)、PRIMARY(主查询，即外层的查询)、UNION(UNION中的第二个或者后面的查询语句)、SUBQUERY(SELECT/WHERE之后包含了子查询)等</p><p>type：表示连接类型，性能由好到差的连接类型为NULL、system、const、eq_ref、ref、range、index、all。</p><p>possible_key</p><p>显示可能应用在这张表上的索引，一个或多个。</p><p>key：实际使用的索引，如果为NULL,则没有使用索引。</p><p>key_len：表示索引中使用的字节数，该值为索引字段最大可能长度，并非实际使用长度，在不损失精确性的前提下，长度越短越好。</p><p>rows：MySQL认为必须要执行查询的行数，在innodb引擎的表中，是一个估计值，可能并不总是精确的。</p><p>filtered：表示返回结果的行数占需读取行数的百分比，filtered的值越大越好。</p><h3 id="6-索引使用"><a href="#6-索引使用" class="headerlink" title="6.索引使用"></a>6.索引使用</h3><h4 id="验证索引效率"><a href="#验证索引效率" class="headerlink" title="验证索引效率"></a>验证索引效率</h4><p>先CREATE INDEX INDEX_ ON TABLENAME();</p><h4 id="最左前缀法则-最左匹配"><a href="#最左前缀法则-最左匹配" class="headerlink" title="最左前缀法则(最左匹配)"></a>最左前缀法则(最左匹配)</h4><p>如果索引了多列（<strong>联合索引</strong>），要遵守最左前缀法则。最左前缀法则指的是查询从索引的最左列开始，并且不跳过索引中的列。</p><p>如果跳跃某一列，索引将部分失效（后面的字段索引失效）。</p><h4 id="范围查询"><a href="#范围查询" class="headerlink" title="范围查询"></a>范围查询</h4><p>联合索引中，出现范围查询(&gt;,&lt;)，范围查询右侧的列索引失效，加上=可能有用。</p><h4 id="索引列运算"><a href="#索引列运算" class="headerlink" title="索引列运算"></a>索引列运算</h4><p>不要在索引列上进行运算操作，索引将失效。</p><h4 id="字符串不加引号"><a href="#字符串不加引号" class="headerlink" title="字符串不加引号"></a>字符串不加引号</h4><p>字符串类型字段使用时，不加引号，索引将失效。</p><h4 id="模糊查询"><a href="#模糊查询" class="headerlink" title="模糊查询"></a>模糊查询</h4><p>如果仅仅是尾部模糊匹配，索引不会失效。如果是头部模糊匹配，索引失效。</p><h4 id="or连接的条件"><a href="#or连接的条件" class="headerlink" title="or连接的条件"></a>or连接的条件</h4><p>用or分割开的条件，如果or前的条件中的列有索引，而后面的列中没有索引，那么涉及的索引都不会被用到。</p><h4 id="数据分布影响"><a href="#数据分布影响" class="headerlink" title="数据分布影响"></a>数据分布影响</h4><p>如果Mysql评估使用索引比全表更慢，则不使用索引。</p><h4 id="SQL提示"><a href="#SQL提示" class="headerlink" title="SQL提示"></a>SQL提示</h4><p>SQL提示，是优化数据库的一个重要手段，简单来说，就是在SQL语句中加入一些人为的提示来达到优化操作的目的。</p><p>use index、ignore index、force index</p><p>explain select * from tb_user use index(idx_user_pro) where profession=’sss’;</p><h4 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h4><p>尽量使用覆盖索引(查询使用了索引，并且需要返回的列，在该索引中已经全部能够找到)，减少select *。（联合索引中各列）</p><p>using index condition：查找使用了索引，但是需要回表查询数据；使用的是二级索引，二级索引叶子节点下方存的是聚集索引，根据聚集索引再次查找就是回表。select 后面的数据在查找树中没有，根据叶子对应的聚集索引回去查找（可以建立联合索引解决）</p><p>using where;using index：查找使用了索引，但是需要的数据都在索引列中能找到，所以不需要回表查询数据；</p><h4 id="前缀索引"><a href="#前缀索引" class="headerlink" title="前缀索引"></a>前缀索引</h4><p>当字段类型为字符串（varchar,text）时，有时候需要索引很长的字符串，这会让索引变得很大，查询时，浪费大量的磁盘IO,影响查询效率。此时可以只将字符串的一部分前缀，建立索引，这样可以大大节约索引空间，从而提高索引效率。</p><p>CREATE INDEX IDX_XXX ON TABLE_NAME(COLUMN(N));</p><p>前缀长度</p><p>可以根据索引的选择性来决定，而选择性是指不重复的索引值（基数）和数据表的记录总数的比值，索引选择性越高则查询效率越高，唯一索引的选择性是1，这是最好的索引选择性，性能也是最好的。</p><p>select count(distinct email) / count(*) from tb_user;</p><p>select count(distinct substring(email, 1, 5)) / count(*) from tb_user;</p><p>select * from tb_user where email=’ssss’;</p><h4 id="单列索引与联合索引"><a href="#单列索引与联合索引" class="headerlink" title="单列索引与联合索引"></a>单列索引与联合索引</h4><p>单列索引：即一个索引只包含单个列。</p><p>联合索引：即一个索引包含了多个列。</p><p>在业务场景中，如果存在多个查询条件，考虑针对于查询字段建立索引时，建议建立联合索引，而非单列索引。</p><h4 id="索引设计原则"><a href="#索引设计原则" class="headerlink" title="索引设计原则"></a>索引设计原则</h4><p>1.针对于数据量较大，且查询比较频繁的表建立索引。</p><p>2.针对于常作为查询条件（where)、排序(ORDER BY)、分组(GROUP BY)操作的字段建立索引。</p><p>3.尽量选择区分度高的列作为索引，尽量建立唯一索引，区分度越高，使用索引的效率越高。</p><p>4.如果是字符串类型的字段，字段的长度较长，可以针对于字段的特点，建立前缀索引。</p><p>5.尽量使用联合索引，减少单列索引，查询时，联合索引很多时候可以覆盖索引，节省存储空间，避免回表，提高查询效率。</p><p>6.要控制索引的数量，索引不是多多益善，索引越多，维护索引结构的代价也就越大，会影响增删改的效率。</p><p>7.如果索引列不能存储NULL值，请在创建表时使用NOT NULL约束它。当优化器知道每列是否包含NULL值时，它可以更好地确定哪个索引最有效地用于查询。</p><h1 id="SQL优化策略"><a href="#SQL优化策略" class="headerlink" title="SQL优化策略"></a>SQL优化策略</h1><h2 id="1-索引失效"><a href="#1-索引失效" class="headerlink" title="1.索引失效"></a>1.索引失效</h2><p>1.全值匹配</p><p>2.最左前缀法则</p><p>对于多列索引，过滤条件要使用索引必须按照索引建立时的顺序，依次满足，一旦跳过某个字段，索引后面的字段都无法被使用。如果查询条件中没有使用这些字段中第一个字段时，多列（或联合）索引不会被使用。</p><p>3.主键插入顺序</p><p>插入乱序的话数据页满后当前页面分裂成两个页面，把本页中的一些记录移动到新创建的这个页中，这会造成性能损耗，所以最好插入的记录的主键值依次递增</p><p>4.计算、函数、类型转换（自动或手动）导致索引失效</p><p>查询条件最好不要进行计算，函数、类型转换，这样会全部取出做运算，导致索引失效</p><p>5.类型转换导致索引失效</p><p>转换需要全部取出转换比对，索引失效</p><p>6.范围条件右边的列索引失效</p><p>范围查找根据是根据索引顺序来的，和查找条件顺序无关；范围右边的索引会导致失效，解决的话创建索引时顺序先按照确定值在前的顺序来创建。</p><p>7.不等于(!=或者&lt;&gt;)索引失效</p><p>需要全部查找，</p><p>8.is null可以使用索引，is not null无法使用索引</p><p>解决方法最好在设计数据表的时候就将字段设置为NOT NULL约束，比如将INT类型字段，默认设置为0.将字符类型的默认值设置为空字符串。</p><p>在查询中使用not like 也无法使用索引，导致全表扫描</p><p>9.like以通配符%开头索引失效</p><p>在使用like关键字进行查询的查询语句中，如果匹配字符串的第一个字符为”%”，索引不会起作用。只有”%”不在第一个位置，索引才会起作用。</p><p>页面搜索严禁左模糊或者全模糊。</p><p>10.OR前后存在非索引的列，索引失效</p><p>在WHERE子句中，如果在OR前的条件列进行了索引，而在OR后的条件列没有进行索引，那么索引会失效。</p><p>OR前后的两个条件中的列都是索引时，查询中才使用索引。</p><p>因为OR的含义就是两个只要满足一个即可，因此只有一个条件列进行了索引是没有意义的，只要有条件列没有进行索引，就会进行全表扫描，因此索引的条件列也会失效。</p><p>11.数据库和表的字符集统一使用utf8mb4</p><h3 id="一般性建议"><a href="#一般性建议" class="headerlink" title="一般性建议"></a>一般性建议</h3><p>1.对于单列索引，尽量选择针对当前query过滤性更好的索引</p><p>2.在选择组合索引的时候，当前query中过滤性最好的字段在索引字段顺序中，位置越靠前越好。</p><p>3.在选择组合索引的时候，尽量选择能够包含当前query中的where子句中更多字段的索引。</p><p>4.在选择组合索引的时候，如果某个字段可能出现范围查询时，尽量把这个字段放在索引次序的最后面。</p><h2 id="2-关联查询优化"><a href="#2-关联查询优化" class="headerlink" title="2.关联查询优化"></a>2.关联查询优化</h2><h5 id="1-内连接：相当于查询A、B交集部分数据-1"><a href="#1-内连接：相当于查询A、B交集部分数据-1" class="headerlink" title="(1)内连接：相当于查询A、B交集部分数据"></a>(1)内连接：相当于查询A、B交集部分数据</h5><p>​    隐式内连接</p><p>​    SELECT 字段列表 FROM 表1,表2 WHERE 条件 …;</p><p>​    显示内连接</p><p>​    SELECT 字段列表 FROM 表1 [INNER] JOIN 表2 ON 连接条件…;</p><p>对于内连接来说，查询优化器可以决定谁作为驱动表，谁作为被驱动表出现</p><p>对于内连接来说，如果表的连接条件中只有一个字段有索引，则有索引的字段所在的表会被作为被驱动表出现</p><p>对于内连接来说，在两个表的连接条件都存在索引的情况下，会选择小表作为驱动表。“小表驱动大表”。</p><h5 id="2-外连接：-1"><a href="#2-外连接：-1" class="headerlink" title="(2)外连接："></a>(2)外连接：</h5><h6 id="左外连接：查询左表所有数据，以及两张表交集部分的数据-1"><a href="#左外连接：查询左表所有数据，以及两张表交集部分的数据-1" class="headerlink" title="左外连接：查询左表所有数据，以及两张表交集部分的数据"></a>左外连接：查询左表所有数据，以及两张表交集部分的数据</h6><p>​    SELECT 字段列表 FROM 表1 LEFT [OUTER] JOIN 表2 ON 连接条件…;</p><h6 id="右外连接：查询右表所有数据，以及两张表交集部分数据-1"><a href="#右外连接：查询右表所有数据，以及两张表交集部分数据-1" class="headerlink" title="右外连接：查询右表所有数据，以及两张表交集部分数据"></a>右外连接：查询右表所有数据，以及两张表交集部分数据</h6><p>​    SELECT 字段列表 FROM 表1 RIGHT [OUTER] JOIN 表2 ON 连接条件…;</p><h5 id="3-自连接：当前表与自身的连接查询，自连接必须使用表别名-1"><a href="#3-自连接：当前表与自身的连接查询，自连接必须使用表别名-1" class="headerlink" title="(3)自连接：当前表与自身的连接查询，自连接必须使用表别名"></a>(3)自连接：当前表与自身的连接查询，自连接必须使用表别名</h5><p>​    SELECT 字段列表 FROM 表1 别名A,表2 别名B WHERE 条件 …;</p><p>​    SELECT 字段列表 FROM 表A 别名A JOIN 表A 别名B ON 条件 …;</p><p><strong>JOIN语句原理</strong></p><p>join方式连接多个表，本质就是各个表之间数据的循环匹配。mysql5.5之前，嵌套循环（Nested Loop Join)。mysql5.5之后，通过BNLJ算法来优化嵌套执行。</p><p>1.驱动表和被驱动表</p><p>驱动表就是主表，被驱动表就是从表、非驱动表。</p><p>对于内连接来说，优化器会根据查询语句做优化，决定先查哪张表，先查询的那张表就是驱动表，反之就是被驱动表。</p><p>对于外连接</p><p>select * from A LEFT JOIN B ON. ..</p><p>或select * from B RIGHT JOIN A ON…</p><p>通常会认为A是驱动表，B是被驱动表，但是也未必，可能优化器会优化为内连接，就变换了。</p><p>2.Simple Nested-Loop Join(简单嵌套循环连接)</p><p>算法相当简单，从表A中取出一条数据1，遍历表B，将匹配到的数据放到result。依次类推，驱动表A中的每一条记录与被驱动表B的记录进行判断，性能较差。</p><p>3.Index Nested-Loop Join(索引嵌套循环连接)</p><p>其优化的思路主要是为了减少内层表数据的匹配次数，所以要求被驱动表上必须有索引才行。通过外层表匹配条件直接与内层表索引进行匹配，避免和内层表的每条记录去进行比较，这样极大的减少了对内层表的匹配次数。</p><p>驱动表中的每条记录通过被驱动表的索引进行访问，因为索引查询的成本是比较固定的，故mysql优化器都倾向于使用记录数少的表作为驱动表（外表）。</p><p>如果被驱动表加索引，效果是非常高的，但如果索引不是主键索引，所以还得进行一次回表查询。相比，被驱动表的索引是主键索引，效率会更高。</p><p>4.Block Nested-Loop Join(块嵌套循环连接)</p><p>如果存在索引，那么会使用index的方式进行join，如果join的列没有索引，被驱动表要扫描的次数太多了。每次访问被驱动表，其表中的记录都会被加载到内存中，然后再从驱动表中取一条与其匹配，匹配结束后清除内存，然后再从驱动表中加载一条记录，然后把被驱动表的记录在加载到内存匹配，这样周而复始，大大增加了IO的次数。为了减少被驱动表的IO次数，就出现了Block Nested-Loop Join的方式。</p><p>不再是逐条获取驱动表的数据，而是一块一块的获取，引入了join buffer缓冲区，将驱动表join相关的部分数据列（大小受join buffer的限制）缓存到join buffer中，然后全表扫描被驱动表，被驱动表的每一条记录一次性和join buffer中的所有驱动表记录进行匹配（内存中操作），将简单嵌套循环中的多次比较合并成一次，降低了被驱动表的访问频率。</p><p>参数设置：</p><p>block_nested_loop</p><p>通过show variables like ‘%optimizer_switch%’ 查看block_nested_loop状态，默认是开启的。</p><p>join_buffer_size</p><p>默认情况下join_buffer_size = 256k。</p><p>5.Join小结</p><p>1.整体效率：INLJ&gt;BNLJ&gt;SNLJ</p><p>2.永远用小结果集驱动大结果集（其本质就是减少外层循环的数据数量）（小的度量单位指的是 表行数*每行大小）</p><p>select t1.b t2.* from t1 straight_join t2 on (t1.b=t2.b) where t2.id &lt;=100;  推荐</p><p>select t1.b t2.* from t2 straight_join t1 on (t1.b=t2.b) where t2.id &lt;=100;  不推荐</p><p>3.为被驱动表匹配的条件增加索引（较少内层表的循环匹配次数）</p><p>4.增大join buffer size的大小（一次缓存的数据越多，那么内层包的扫表次数就越少）</p><p>5.减少驱动表不必要的字段查询（字段越少，join buffer所缓存的数据就越多）</p><p>6.hash join</p><p>废弃BNLJ，加入hash join</p><p>Nested Loop:</p><p>对于被连接的数据子集较小的情况，Nested Loop是个较好的选择。</p><p>Hash Join是大数据集连接时的常用方式，优化器使用两个表中较小（相对较小）的表利用Join Key在内存中建立散列表，然后扫描较大的表并探测散列表，找出与Hash表匹配的行。</p><p>​    1.这种方式适用于较小的表完全可以放于内存中的情况，这样总成本就是访问两个表的成本之和。</p><p>​    2.在表很大的情况下并不能完全放入内存，这时优化器会将它分割成若干不同的分区，不能放入内存的部分就把该分区写入磁盘的临时段，此时要求有较大的临时段从而尽量提高I/O的性能。</p><p>​    3.它能够很好的工作于没有索引的大表和并行查询的环境中，并提供最好的性能。大多数人都说它是Join的重型升降机。Hash Join只能应用于等值连接，这是由Hash的特点决定的。</p><h2 id="3-子查询优化"><a href="#3-子查询优化" class="headerlink" title="3.子查询优化"></a>3.子查询优化</h2><p>子查询可以进行SELECT语句的嵌套查询，即一个SELECT查询的结果作为另一个SELECT语句的条件。子查询可以一次性完成很多逻辑上需要多个步骤才能完成的SQL操作。</p><p>子查询效率不高，原因：</p><p>1.执行子查询时，Mysql需要为内层查询语句的查询结果建立一个临时表，然后外层查询语句从临时表中查询记录。查询完毕后，再撤销这些临时表。这样会消耗过多的CPU和IO资源，产生大量的慢查询。</p><p>2.子查询的结果集存储的临时表，不论是内存临时表还是磁盘临时表都不会存在索引，所以查询性能会受到一定的影响。</p><p>3.对于返回结果集比较大的子查询，其对查询性能的影响也就越大。</p><p>在MYSQL中，可以使用连接（Join）查询来代替子查询。连接查询不需要建立临时表，其速度比子查询要快，如果查询中使用索引的话，性能就会更好。</p><p>尽量不要使用NOT IN 或者NOT EXISTS，用LEFT JOIN xxx ON xx WHERE xx IS NULL替代。</p><h2 id="4-排序优化"><a href="#4-排序优化" class="headerlink" title="4.排序优化"></a>4.排序优化</h2><h3 id="1-排序优化"><a href="#1-排序优化" class="headerlink" title="1.排序优化"></a>1.排序优化</h3><p>问题：在WHERE条件字段上加上索引，但是为什么在ORDER BY字段上还要加索引呢？</p><p>回答：</p><p>在MYSQL中，支持两种排序方式，分别是FileSort和Index排序。</p><p>​    1.Index排序中，索引可以保证数据的有序性，不需要再进行排序，效率更高。</p><p>​    2.FileSort排序则一般在内存中进行排序，占用CPU较多。如果待排结果较大，会产生临时文件I/O到磁盘进行排序的情况，效率较低。</p><p>优化建议：</p><p>1.SQL中，可以在WHERE子句和ORDER BY子句中使用索引，目的是在WHERE子句中避免全表扫描，在ORDER BY子句避免使用FileSort排序。当然，某些情况下全表扫描，或者FileSort排序不一定比索引慢。但总的来说，我们还是要避免，以提高查询效率。</p><p>2.尽量使用Index完成ORDER BY排序。如果WHERE和ORDER BY后面是相同的列就使用单索引列；如果不同就使用联合索引。</p><p>3.无法使用Index时，需要对FileSort方式进行调优。</p><h3 id="2-失效案例："><a href="#2-失效案例：" class="headerlink" title="2.失效案例："></a>2.失效案例：</h3><p>1.无索引</p><p>2.order by时不limit，索引失效</p><p>select * from student order by age, classid;    索引失效，数据量过大，*全部字段，因此会回表查找</p><p>select * from student order by age, classid limit 10;    数据量比较小，用索引</p><p>3.order by 时顺序错误，索引失效</p><p>要满足最左前缀法则</p><p>4.order by时规则不一致，索引失效（顺序错，不索引；方向反，不索引）</p><p>5.无过滤，不索引</p><h3 id="3-filesort算法：双路排序和单路排序"><a href="#3-filesort算法：双路排序和单路排序" class="headerlink" title="3.filesort算法：双路排序和单路排序"></a>3.filesort算法：双路排序和单路排序</h3><p>排序的字段若如果不在索引列上，则filesort会有两种算法：双路排序和单路排序</p><p><strong>双路排序（慢）</strong></p><p>​    1.两次扫描磁盘，最终得到数据，读取行指针和order by 列，对他们进行排序，然后扫描已经排序好的列表，按照列表中的值重新从列表中读取对应的数据输出。</p><p>​    2.从磁盘取排序字段，在buffer进行排序，再从磁盘取其他字段。</p><p>取一批数据，对磁盘进行两次扫描，I/O很耗时。改进为单路排序。</p><p><strong>单路排序（快）</strong></p><p>从磁盘读取查询需要的所有列，按照order by列在buffer对他们进行排序，然后扫描排序后的列表进行输出，它的效率更快一些，避免了第二次读取数据。并且把随机IO变成了顺序IO，但是它会使用更多的空间，因为它把每一行都保存在内存中了。</p><p><strong>结论及引申问题</strong></p><p>1.单路总体好过双路</p><p>2.单路也有问题：</p><p>​    1.在sort_buffer中，单路比多路要多占用很多空间，因为单路是把所有字段都取出，所以有可能取出的数据的总大小超出了sort_buffer的容量，导致每次只能取sort_buffer容量大小的数据，进行排序（创建tmp文件，多路合并），排完再取sort_buffer容量大小，再排…从而多次I/O。</p><p>​    2.单路本来想省一次I/O操作，反而导致了大量的I/O操作，反而得不偿失。</p><p>优化策略：提高sort_buffer大小、提高max_length_for_sort_data、select需要的字段</p><h2 id="5-GROUP-BY优化"><a href="#5-GROUP-BY优化" class="headerlink" title="5.GROUP BY优化"></a>5.GROUP BY优化</h2><p>1.group by使用索引的原则几乎根order by一致，group by即使没有过滤条件用到索引，也可以直接使用索引。</p><p>2.group by先排序再分组，遵照索引键的最左前缀法则</p><p>3.当无法使用索引列时，增大max_length_for_sort_data和sort_buffer_size参数的设置</p><p>4.where效率高于having，能写在where限定的条件就不要写在having中了</p><p>5.减少使用order by,和业务沟通能不排序就不排序，或将排序放到程序端去做。order by、group by、distinct这些语句较为耗费CPU，数据库的CPU资源是及其宝贵的。</p><p>6.包含了order by、group by、distinct这些查询的语句，where条件过滤出来的结果集请保持在1000行以内，否则SQL会很慢。</p><h2 id="6-优化分页查询"><a href="#6-优化分页查询" class="headerlink" title="6.优化分页查询"></a>6.优化分页查询</h2><p>一般分页查询时，通过创建覆盖索引能够比较好地提升性能。常见头疼的问题是limit 2000000， 10，此时需要mysql排序前2000010记录，仅仅返回2000000-2000010的记录，其他记录丢弃，查询排序的代价非常大。</p><p>优化思路：</p><p>1.在索引上完成排序分页操作，最后根据主键关联回原表查询所需要的其他列内容</p><p>select * from student t,(select id from student order by id limit 2000000,10) a where t.id = a.id;</p><p>2.该方案适用于主键自增的表，可以把limit查询转换成某个位置的查询。</p><p>select * from student where id &gt; 2000000 limit 10;</p><h2 id="7-优先考虑覆盖索引"><a href="#7-优先考虑覆盖索引" class="headerlink" title="7.优先考虑覆盖索引"></a>7.优先考虑覆盖索引</h2><p>1.一个索引包含了满足查询结果的数据就叫做覆盖索引。</p><p>索引列+主键包含select 到 from 之间查询的列。</p><p>2.覆盖索引利弊</p><p>好处：</p><p>1.避免Innodb表进行索引的二次查询（回表）</p><p>Innodb是以聚集索引的顺序来存储的，对于Innodb来说，二级索引在叶子节点中所保存的是行的主键信息，如果是用二级索引查询数据，在查找到相应的键后，还需通过主键进行二次查询才能获取我们真实所需要的数据。在覆盖索引中，二级索引的键值可以获取所要的数据，避免了对主键的二次查询，减少了IO操作，提升了查询效率。</p><p>2.可以把随机IO变成顺序IO加快查询效率。</p><p>由于覆盖索引是按键值的顺序存储的，对于IO密集型的范围查找来说，对比随机从磁盘读取每一行的数据IO要少的多，因此利用覆盖索引在访问时也可以把磁盘的随机读取的IO转变成索引查找的顺序IO。</p><p>弊端：</p><p>索引字段的维护总是有代价的。因此，在建立冗余索引来支持覆盖索引时就需要权衡考虑了。</p><h2 id="8-字符串添加索引，前缀索引"><a href="#8-字符串添加索引，前缀索引" class="headerlink" title="8.字符串添加索引，前缀索引"></a>8.字符串添加索引，前缀索引</h2><h2 id="9-索引条件下推（ICP）"><a href="#9-索引条件下推（ICP）" class="headerlink" title="9.索引条件下推（ICP）"></a>9.索引条件下推（ICP）</h2><p>Index Condition Pushdown(ICP)是mysql新特性，是一种在存储引擎层使用索引过滤数据的优化方式。</p><p>1.如果没有ICP，存储引擎会遍历索引以定位基表中的行，并将它们返回给mysql服务器，由mysql服务器评估WHERE后面的条件是否保留行。</p><p>2.启用ICP后，如果部分WHERE条件可以仅适用索引中的列进行筛选，则mysql服务器会把这部分WHERE条件放到存储引擎筛选。然后，存储引擎通过使用索引条目来筛选数据，并且只有在满足这一条件时才从表中读取行。</p><p>​    1.好处：ICP可以减少存储引擎必须访问基表的次数和mysql服务器必须访问存储引擎的次数。</p><p>​    但是，ICP的加速效果取决于在存储引擎内通过ICP筛选掉的数据的比例。</p><p>就是在联合索引中，where条件中前面满足可索引的条件，后面的条件不满足索引条件不能用索引（索引失效），前面条件查询完后先不要回表查询，是放到存储引擎中，再对后面条件进行筛选，然后回表。这样回表的次数减少了，随机IO次数也可能减少了。</p><h3 id="ICP的开启和关闭"><a href="#ICP的开启和关闭" class="headerlink" title="ICP的开启和关闭"></a>ICP的开启和关闭</h3><p>关闭索引下推</p><p>set optimizer_switch = ‘index_condition_pushdown = off’;</p><p>打开索引下推</p><p>set optimizer_switch = ‘index_condition_pushdown = on’;</p><p>ICP的使用条件</p><p>1.如果表访问的类型为range、ref、eq_ref和ref_or_null可以使用ICP</p><p>2.ICP可以用于InnoDB和myISAM表，包括分区表InnoDB和MyISAM表</p><p>3.对于InnoDB表，ICP仅用于二级索引。ICP的目标是减少全行读取次数，从而减少I/O操作。（聚集索引不需要回表）</p><p>4.当SQL使用覆盖索引时，不支持ICP。因为这种情况下使用ICP不会减少I/O。（覆盖索引也不需要回表）</p><p>5.相关子查询的条件不能使用ICP。</p><h2 id="10-其它查询优化策略"><a href="#10-其它查询优化策略" class="headerlink" title="10.其它查询优化策略"></a>10.其它查询优化策略</h2><h3 id="1-EXISTS和IN的区分"><a href="#1-EXISTS和IN的区分" class="headerlink" title="1.EXISTS和IN的区分"></a>1.EXISTS和IN的区分</h3><p>问题：</p><p>不太理解哪种情况应该使用呢EXISTS,哪种情况应该用IN。选择的标准是看能否使用表的索引吗？</p><p>回答：</p><p>索引是个前提，其实选择与否还是要看表的大小。你可以将选择的标准理解为小表驱动大表。在这种方式下效率是最高的。</p><h3 id="2-count-与count-具体字段-效率"><a href="#2-count-与count-具体字段-效率" class="headerlink" title="2.count(*)与count(具体字段)效率"></a>2.count(*)与count(具体字段)效率</h3><p>问：在mysql中统计数据表的行数，可以用三种方式：select count(*)、select count(1)、select count(具体字段)，使用这三者之间的查询效率怎样？</p><p>答：</p><p>前提：如果你要统计的是某个字段的非空数据行数，则另当别论，毕竟比较执行效率的前提是结果一样才可以。</p><p>环节1：count(*)和count(1)都是对所有结果进行count；count(**)和count(1)本质上并没有区别（二者执行时间可能略有差别，不过你还是可以把它两的执行效率看成是相等的）。如果有WHERE子句，则是对所有符合筛选条件的数据行进行统计；如果没有WHERE子句，则是对数据表的数据行数进行统计。</p><p>环节2：如果是MyISAM存储引擎，统计数据表的行数只需要O(1)的复杂度，这是因为每张MyISAM的数据表都有一个meta信息存储了row_count值，而一致性则由表级锁来保证。</p><p>如果是InnoDB存储引擎，因为InnoDB支持事务，采用行级锁和MVCC机制，所以无法像MyISAM一样，维护一个row_count变量，因此需要采用扫描全表，是O(n)的复杂度，进行循环+计数的方式来完成统计。</p><p>环节3：在InnoDB引擎中，如果采用COUNT(具体字段)来统计数据行数，要尽量采用二级索引。因为主键采用的索引是聚簇索引，聚簇索引包含的信息多，明显会大于二级索引（非聚簇索引）。对于count(*)和count(1)来说，它们不需要查找具体的行，只是统计行数，系统会自动采用占用空间更小的二级索引来进行统计。</p><p>如果有多个二级索引，会使用key_len小的二级索引进行扫描。当没有二级索引的时候，才会采用主键索引来进行统计。</p><h3 id="3-关于SELECT"><a href="#3-关于SELECT" class="headerlink" title="3.关于SELECT(*)"></a>3.关于SELECT(*)</h3><p>在表查询中，建议明确字段，不要使用*作为查询的字段列表，推荐使用SELECT&lt;字段列表&gt;查询。原因：</p><p>1.MYSQL在解析的过程中，会通过查询数据字典将”*”按序转换成所有列名，这会大大的耗费资源和时间。</p><p>2.无法使用覆盖索引</p><h3 id="4-LIMIT-1对优化的影响"><a href="#4-LIMIT-1对优化的影响" class="headerlink" title="4.LIMIT 1对优化的影响"></a>4.LIMIT 1对优化的影响</h3><p>针对的是会扫描全表的SQL语句，如果你可以确定结果集只有一条，那么加上LIMIT 1的时候，当找到一条结果的时候就不会继续扫描了，这样会加快查询速度。</p><p>如果数据表已经对字段建立了唯一索引，那么可以通过索引进行查询，不会全表扫描的话，就不需要加上LIMIT 1了。</p><h3 id="5-多使用COMMIT"><a href="#5-多使用COMMIT" class="headerlink" title="5.多使用COMMIT"></a>5.多使用COMMIT</h3><p>只要有可能，在程序中尽量多使用COMMIT，这样程序的性能得到提高，需求也会因为COMMIT所释放的资源而减少。</p><p>COMMIT所释放的资源：</p><p>​    1.回滚段上用于恢复数据的信息</p><p>​    2.被程序语句获得的锁</p><p>​    3.redo/undo log buffer中的空间</p><p>​    4.管理上述3种资源中的内部花费</p><h1 id="淘宝数据库主键设计"><a href="#淘宝数据库主键设计" class="headerlink" title="淘宝数据库主键设计"></a>淘宝数据库主键设计</h1><h2 id="1-自增ID问题"><a href="#1-自增ID问题" class="headerlink" title="1.自增ID问题"></a>1.自增ID问题</h2><p>自增ID做主键，简单易懂，几乎所有数据库都支持自增类型，只是实现上各有所不同而已。自增ID除了简单，其它都是缺点，总体来说存在以下几方面问题：</p><p>1.可靠性不高</p><p>存在自增ID回溯的问题，8.0修复</p><p>2.安全性不高</p><p>对外暴露的接口可以非常容易猜测对应的信息。不如：/user/1/这样的接口，可以非常容易猜测用户ID的值为多少，总数量有多少，也可以非常容易地通过接口进行数据的爬取。</p><p>3.性能差</p><p>自增ID的性能较差，需要在数据库服务器端生成。</p><p>4.交互多</p><p>业务还需要额外执行一次类似last_insert_id()的函数才能知道刚才插入的自增值，这需要多一次的网络交互。在海量并发的系统中，多一条SQL，就多一次性能上的开销。</p><p>5.局部唯一性</p><p>最重要的一点，自增ID是局部唯一，只在当前数据库实例中唯一，而不是全局唯一，在任意服务器间都是唯一的。对于目前分布式系统来说，这简直就是噩梦。</p><h2 id="2-业务字段做主键"><a href="#2-业务字段做主键" class="headerlink" title="2.业务字段做主键"></a>2.业务字段做主键</h2><p>为了能够唯一地标识一个会员的信息，需要为会员信息表设置一个主键。那么，怎么为这个表设置主键，才能达到我们理想的目标呢？这里我们考虑业务字段做主键。</p><p>会员号、电话号、重新收回分配会出问题；身份证号隐私，设计表时允许身份证号和电话都为空。</p><p>所以，建议尽量不要用跟业务有关的字段做主键。</p><h2 id="3-淘宝主键设计"><a href="#3-淘宝主键设计" class="headerlink" title="3.淘宝主键设计"></a>3.淘宝主键设计</h2><p>订单ID = 时间 + 去重字段 +用户ID后6位尾号</p><h2 id="4-推荐主键设计"><a href="#4-推荐主键设计" class="headerlink" title="4.推荐主键设计"></a>4.推荐主键设计</h2><p>非核心业务：对应表的主键自增ID，如告警、日志、监控等信息。</p><p>核心业务：主键设计至少应该是全局唯一且是单调递增。全局唯一保证在各系统之间都是唯一的，单调递增是希望插入时不影响数据库性能。</p><p>最简单的一种主键设计：UUID（<strong>U</strong>niversally <strong>U</strong>nique <strong>Id</strong>entifier 通用唯一识别码）</p><p><strong>UUID特点</strong>：全局唯一，占用36字节，数据无序，插入性能差。</p><p><strong>认识UUID:</strong></p><p>MYSQL数据库UUID组成：</p><p>UUID = 时间 + UUID版本（16字节）- 时钟序列（4字节）- MAC地址（12字节）</p><p>时间低位32位+时间中位16位+时间高位12位+UUID版本4位</p><p>为什么UUID是全局唯一的？</p><p>在UUID中时间部分占用60位，存储的类似TIMESTAMP的时间戳，但表示的是从1582-10-15 00：00：00.00到现在的100ns的计数。可以看到UUID存储的时间精度比TIMESTAMPE更高，时间维度发生重复的概率降低到1/100ns。</p><p>时钟序列是为了避免时钟被回拨导致产生时间重复的可能性。MAC地址用于全局唯一。</p><p>为什么UUID占用36字节？</p><p>UUID根据字符串进行存储，设计时还带有无用”-“字符串，因此总共需要36字节。</p><p>为什么UUID是随机无序的呢?</p><p>因为UUID的设计中，将时间低位放在最前面，而这部分的数据是一直在变化的，并且是无序。</p><p><strong>改造UUID:</strong></p><p>若将时间高低位互换，则时间就是单调递增的了，也就变得单调递增了。MYSQL8.0可以更换时间低位和时间高位的存储方式，这样UUID就是有序的UUID了。</p><p>MYSQL8.0还解决了UUID存在的空间占用的问题，除去了UUID字符串中无意义的”-“字符串，并且将字符串用二进制类型保存，这样存储空间降低为了16字节。</p><p>可以通过MYSQL8.0提供的uuid_to_bin函数实现上述功能，同样的，MYSQL也提供了bin_to_uuid函数进行转化：</p><p>set @uuid = UUID();</p><p>SELECT @uuid,uuid_to_bin(@uuid),uuid_to_bin(@uuid,TRUE);</p><h2 id="三、SQL优化"><a href="#三、SQL优化" class="headerlink" title="三、SQL优化"></a>三、SQL优化</h2><p>SQL查询优化</p><p><strong>物理查询优化</strong></p><p>通过索引和表连接方式等技术来进行优化</p><p><strong>逻辑查询优化</strong></p><p>通过SQL等价变换提升查询效率</p><h3 id="1、插入数据"><a href="#1、插入数据" class="headerlink" title="1、插入数据"></a>1、插入数据</h3><h4 id="A-INSERT-优化"><a href="#A-INSERT-优化" class="headerlink" title="A.INSERT 优化"></a>A.INSERT 优化</h4><p>1.批量插入</p><p>insert into tb_test values(),(),()</p><p>2.手动提交事务</p><p>start transaction;</p><p>insert …</p><p>commit;</p><p>3.主键顺序插入</p><h4 id="B-大批量插入数据"><a href="#B-大批量插入数据" class="headerlink" title="B.大批量插入数据"></a>B.大批量插入数据</h4><p>如果一次性需要插入大批量数据，使用insert语句插入性能较低，此时可以使用Mysql数据库提供的load指令进行插入。操作如下：</p><p>#客户端连接服务器时，加上参数 –local-infile</p><p>mysql –local-infile -u root -p</p><p>#设置全局参数local_infile为1，开启从本地加载文件导入数据的开关</p><p>set global local_infile = 1;</p><p>#执行load指令将准备好的数据，加载到表结构中</p><p>load data local infile ‘/root/sql.log’ into table ‘tb_user’ fields terminated by ‘,’ lines teminated by ‘\n’;</p><p>主键顺序插入性能高于乱序插入</p><h3 id="2、主键优化"><a href="#2、主键优化" class="headerlink" title="2、主键优化"></a>2、主键优化</h3><h4 id="数据组织方式"><a href="#数据组织方式" class="headerlink" title="数据组织方式"></a>数据组织方式</h4><p>在InnoDB存储引擎中，表数据都是根据主键顺序组织存放的，这种存储方式的表称为索引组织表(index organized table IOT)。</p><p>InnoDB逻辑存储结构</p><p>TableSpace：表空间</p><p>Segment：段</p><p>Extent：区（1M）64页</p><p>Page：页（16K）</p><p>Row：行</p><h4 id="页分裂"><a href="#页分裂" class="headerlink" title="页分裂"></a>页分裂</h4><p>页可以为空，也可以填充一半，也可以填充100%。每个页包含了2-N行数据(如果一行数据过大，会行溢出)，根据主键排列。</p><p>某一个页填满之后，继续插入叶子节点，会新开一个页，将满的页从中间分开填充到新开的页，再插入叶子节点，而且还需要调整页指针指向。</p><h4 id="页合并"><a href="#页合并" class="headerlink" title="页合并"></a>页合并</h4><p>当删除一行记录时，实际上记录并没有被物理删除，只是记录被标记(flaged)为删除并且它的空间变得允许被其他记录声明使用。</p><p>当页中删除的记录达到MERGE_THRESHOLD(默认为页的50%)，InnoDB会开始寻找最近的页（前或后）看看是否可以将两个页合并以优化空间使用。</p><h4 id="主键设计原则"><a href="#主键设计原则" class="headerlink" title="主键设计原则"></a>主键设计原则</h4><p>满足业务需求的情况下，尽量降低主键的长度。</p><p>插入数据时，尽量选择顺序插入，选择使用AUTO_INCREMENT自增主键。</p><p>尽量不要使用UUID做主键或者是其他自然主键，如身份证号。</p><p>业务操作时，避免对主键的修改。</p><h3 id="3-order-by优化"><a href="#3-order-by优化" class="headerlink" title="3.order by优化"></a>3.order by优化</h3><p>Using filesort：通过表的索引或全表扫描，读取满足条件的数据行，然后在排序缓冲区sort buffer中完成排序操作，所有不是通过索引直接返回排序结果的排序都叫FileSort排序。</p><p>Using index：通过有序索引顺序扫描直接返回有序数据，这种情况即为using index,不需要额外排序，操作效率高。</p><p>#没有创建索引时，根据age,phone进行排序</p><p>explain select id,age,phone from tb_user order by age,phone;</p><p>#创建索引</p><p>create index idx_user_age_phone_aa on tb_user(age,phone);</p><p>#创建索引后，根据age,phone进行升序排序</p><p>explain select id,age,phone from tb_user order by age, phone;</p><p>#创建索引后，根据age,phone进行降序排序</p><p>explain select id,age phone from tb_user order by age desc,phone desc;</p><p>#根据age,phone进行降序一个升序，一个降序</p><p>explain select id,age,phone from tb_user order by age asc,phone desc;</p><p>#创建索引</p><p>create index idx_user_age_phone_ad on tb_user(age asc,phone desc);</p><p>#根据age,phone进行降序一个升序，一个降序</p><p>explain select id,age,phone from tb_user order by age asc,phone desc;</p><p>1.根据排序字段建立合适的索引，多字段排序时，也遵循最左前缀法则。</p><p>2.尽量使用覆盖索引。</p><p>3.多字段排序，一个升序一个降序，此时需要注意联合索引在创建时的规则。(ASC/DESC)。</p><p>4.如果不可避免的出现filesort，大数据量排序时，可以适当增大排序缓冲区大小sort_buffer_size(默认256K)。</p><h3 id="4-group-by优化"><a href="#4-group-by优化" class="headerlink" title="4.group by优化"></a>4.group by优化</h3><p>#创建索引</p><p>create index idx_user_pro_age_sta on tb_user(profession,age,status);</p><p>#执行分组操作，根据profession字段分组</p><p>explain select profession,count(*) from tb_user group by profession;</p><p>#执行分组操作，根据profession字段分组</p><p>explain select profession,count(*) from tb_user group by profession,age;  (Using index)</p><p>explain select age,count(*) from tb_user group by age;   (Using index;Using temporary)</p><p>explain select age,count(*) from tb_user where profession = ‘ss’ group by age;   (Using index)</p><p>1.在分组操作时，可以通过索引来提高效率。</p><p>2.分组操作时，索引的使用也是满足最左前缀法则的。</p><h3 id="5-limit优化"><a href="#5-limit优化" class="headerlink" title="5.limit优化"></a>5.limit优化</h3><p>limit 起始索引 长度，此时需要Mysql排序前 起始索引+length记录，仅仅返回length个记录，其他记录丢弃，查询排序的代价非常大。</p><p>优化思路：一般分页查询时，通过创建覆盖索引能够比较好地提高性能，可以通过覆盖索引加子查询形式进行优化。</p><p>explain select * from tb_sku t,(select id from tb_sku order by id limit 起始索引, length) a where t.id = a.id;</p><h3 id="6-count优化"><a href="#6-count优化" class="headerlink" title="6.count优化"></a>6.count优化</h3><p>count的几种用法</p><p>count()是一个聚合函数，对于返回的结果集，一行行地判断，如果count函数的参数不是NULL,累计值就加1，否则不加，最后返回累计值。</p><p>用法：count(*),count(主键),count(字段)，count(1);</p><p>count(主键)</p><p>InnoDB引擎会遍历整张表，把每一行的主键id值都取出来，返回给服务层。服务层拿到主键后，直接按行进行累加（主键不可能为null）。</p><p>count(字段)</p><p>没有not null 约束：InnoDB引擎会遍历整张表把每一行的字段值都取出来，返回给服务层，服务层判断是否为null，不为null，计数累加。</p><p>有not null约束：InnoDB引擎会遍历整张表把每一行的字段值都取出来，返回给服务层，直接按行进行累加。</p><p>count(1)</p><p>InnoDB引擎遍历整张表，但不取值。服务层对于返回的每一行，放一个数字“1“进去，直接按行进行累加。</p><p>count(*)</p><p>InnoDB引擎并不会把全部字段取出来，而是专门做了优化，不取值，服务层直接按行进行累加。</p><p>按照效率排序的话，count(字段)&lt;count(主键id)&lt;count(1)  ≈  count(*)，所以尽量使用count(星);</p><h3 id="7-update优化"><a href="#7-update优化" class="headerlink" title="7.update优化"></a>7.update优化</h3><p>InnoDB的行锁是针对索引加的锁，不是针对记录加的锁，并且该索引不能失效，否则会从行锁升级为表锁。</p><p>尽量根据主键/索引字段进行数据更新。</p><h2 id="四、视图-存储过程-触发器"><a href="#四、视图-存储过程-触发器" class="headerlink" title="四、视图/存储过程/触发器"></a>四、视图/存储过程/触发器</h2><h3 id="1-视图"><a href="#1-视图" class="headerlink" title="1.视图"></a>1.视图</h3><p>视图是一种虚拟存在的表。视图中的数据并不在数据库中实际存在，行和列来自定义视图的查询中使用的表，并且是在使用视图时动态生成的。</p><p>视图只保存了查询的SQL逻辑，不保存查询结果。所以我们在创建视图的时候，主要的工作就落在创建这条SQL查询语句上。</p><p><strong>创建</strong></p><p>CREATE [OR REPLACE] VIEW 视图名称 [(列名列表)] AS SELECT语句 [WITH [CASCADED | LOCAL] CHECK OPTION]</p><p><strong>查询</strong></p><p>查看创建视图语句：SHOW CREATE VIEW 视图名称；</p><p>查看视图数据：SELECT * FROM 视图名称 …;</p><p><strong>修改</strong></p><p>方式一：CREATE [OR REPLACE] VIEW 视图名称 [(列名列表)] AS SELECT语句 [WITH [CASCADED | LOCAL] CHECK OPTION]</p><p>方式二：ALTER VIEW 视图名称 [(列名列表)] AS SELECT语句 [WITH [CASCADED | LOCAL] CHECK OPTION]</p><p><strong>删除</strong></p><p>DROP VIEW [IF EXISTS] 视图名称 [视图名称] …</p><p><strong>视图的检查选项</strong></p><p>当使用WITH CHECK OPTION子句创建视图时，MySQL会通过视图检查正在更改的每个行，例如插入、更新。删除，以使其符合视图的定义。MySQL允许基于另一个视图创建视图，它还会检查依赖视图中的规则以保持一致性。为了确定检查的范围，mysql提供了两个选项：</p><p>CASCADED和LOCAL,默认值为CASCADED。</p><p>CASCADED：当前视图和所依赖的视图都要求满足各自条件。</p><p>LOCAL：递归查找当前视图所依赖视图是否定义了检查选项LOCAL CHECK ,若有则进行条件的检查，若没有检查选项，则不进行条件的检查。</p><p><strong>视图的更新</strong></p><p>要使视图可更新，视图中的行与基础表中的行之间必须存在一对一的关系。如果视图包含以下任何一项，则该视图不可更新：</p><p>1.聚合函数或窗口函数（SUM()、MIN()、MAX()、COUNT()等）</p><p>2.DISTINCT</p><p>3.GROUP BY</p><p>4.HAVING</p><p>5.UNION 或者UNION ALL</p><p>作用</p><p>1.简单</p><p>视图不仅可以简化用户对数据的理解，也可以简化他们的操作。那些被经常使用的查询可以被定义为视图，从而使得用户不必为以后的操作每次指定全部的条件。</p><p>2.安全</p><p>数据库可以授权，但不能授权到数据库特定行和特定的列上。通过视图用户只能查询和修改他们所能见到的数据</p><p>3.数据独立</p><p>视图可帮助用户屏蔽真实表结构变化带来的影响。</p><h3 id="2-存储过程"><a href="#2-存储过程" class="headerlink" title="2.存储过程"></a>2.存储过程</h3><p>介绍</p><p>存储过程是事先经过编译并存储在数据库中的一段SQL语句的集合，调用存储过程可以简化应用开发人员的很多工作，减少数据在数据库和应用服务器之间的传输，对于提高数据处理的效率是有好处的。</p><p>存储过程思想上很简单，就是数据库SQL语言层面的代码封装与重用。</p><p>特点</p><p>封装，复用</p><p>可以接收参数，也可以返回数据</p><p>减少网络交互，效率提升</p><p><strong>创建</strong></p><p><strong>CREATE PROCEDURE 存储过程名称 ([参数列表])</strong></p><p><strong>BEGIN</strong></p><p>​    <strong>–SQL语句</strong></p><p><strong>END;</strong></p><p><strong>调用</strong></p><p>CALL 名称([参数]);</p><p><strong>查看</strong></p><p>SELECT * FROM INFORMATION_SCHEMA.ROUTINES WHERE ROUTINE_SCHEMA=’xxx’;  –查询指定数据库的存储过程及状态信息</p><p>SHOW CREATE PROCEDURE 存储过程名称;  –查询某个存储过程的定义</p><p><strong>删除</strong></p><p>DROP PROCEDURE [IF EXISTS] 存储过程名称;</p><p>注意：在命令行中，执行创建存储过程的SQL时，需要通过关键字delimiter指定SQL语句的结束符。</p><p><strong>变量</strong></p><p>系统变量是Mysql服务器提供，不是用户定义的，属于服务器层面。分为全局变量(GLOBAL)、会话变量(SESSION)。</p><p>查看系统变量</p><p>SHOW [SESSION | GLOBAL] VARIABLES;  –查看所有系统变量</p><p>SHOW [SESSION | GLOBAL] VAILABLRS LIKE ‘….’;  –可以通过LIKE模糊匹配方式查找变量</p><p>SELECT @@[SESSION | GLOBAL] 系统变量名;  –查看指定变量的值</p><p><strong>设置系统变量</strong></p><p>SET [SESSION | GLOBAL] 系统变量名= 值;</p><p>SET @@[SESSION } GLOBAL] 系统变量名 = 值;</p><p>用户定义变量是用户根据需要自己定义的变量，用户变量不用提前声明，在用的时候直接用”@变量名”使用就可以。其作用域为当前连接。</p><p><strong>赋值</strong></p><p>SET @var_name = expr [, @var_name = expr] …;</p><p>SET @var_name := expr [, @var_name :=expr] …;</p><p>SELECT @var_name := expr [, @var_name :=expr] …;</p><p>SELECT字段名 INTO @var_name FROM 表名;</p><p><strong>使用</strong></p><p>SELECT @var_name;</p><p>局部变量是根据需要定义的在局部生效的变量，访问之前，需要DECLARE声明。可用作存储过程内的局部变量和输入参数，局部变量的范围是在其声明的BEGIN…END块。</p><p><strong>声明</strong></p><p>DECLARE 变量名 变量类型 [DEFAULT…];</p><p>变量类型就是数据库字段类型：INT、BIGINT、CHAR、VARCHAR、DATE、TIME等。</p><p><strong>赋值</strong></p><p>SET 变量名 = 值；</p><p>SET 变量名 := 值；</p><p>SELECT 字段名 INTO 变量名 FROM 表名 …;</p><p>IF判断</p><p>语法：</p><p>IF 条件1 THEN</p><p>​    …</p><p>ELSEIF 条件2 THEN   –可选</p><p>​    …</p><p>ELSE</p><p>​    …</p><p>END IF;</p><p><strong>参数</strong></p><p>IN        作为输入，也就是需要调用时传入值</p><p>OUT    作为输出，也就是该参数可以作为返回值</p><p>INOUT即可以作为输入参数，也可以作为输出参数</p><p><strong>CREATE PROCEDURE 存储过程名称 ([IN/OUT/INOUT 参数名 参数类型])</strong></p><p><strong>BEGIN</strong></p><p>​    <strong>–SQL语句</strong></p><p><strong>END;</strong></p><p><strong>case</strong></p><p>语法一</p><p>CASE case value</p><p>​    WHEN when_value1 THEN statement_list1 [WHEN when_value2 THEN statement_list2] …</p><p>​    [ELSE statement_list]</p><p>END CASE;</p><p>语法二</p><p>CASE</p><p>​    WHEN search_condition1 THEN statement_list1 </p><p>​    [WHEN search_condition2 THEN statement_list2] …</p><p>​    [ELSE statement_list]</p><p>END CASE;</p><p><strong>while</strong></p><p>WHILE 条件 DO</p><p>​    SQL逻辑</p><p>END WHILE;</p><p><strong>repeat</strong></p><p>repeat是有条件的循环控制语句，当满足条件的时候退出循环。</p><p>REPEAT</p><p>​    SQL逻辑</p><p>​    UNTIL 条件</p><p>END REPEAT;</p><p><strong>loop</strong></p><p>loop实现简单的循环，如果不在SQL逻辑中增加退出循环的条件，可以用其来实现简单的死循环。LOOP可以配合一下两个语句使用：</p><p>LEAVE：配合循环使用，退出循环。</p><p>ITERATE：必须用在循环中，作用是跳过当前循环剩下的语句，直接进入下一次循环。</p><p>[begin_label:]    LOOP</p><p>​    SQL逻辑…</p><p>END LOOP [end_label];</p><p>LEAVE label;    –退出指定标记的循环体</p><p>ITERATE label;    –直接进入下一次循环</p><p><strong>游标</strong></p><p>游标(CURSOR)是用来存储查询结果集的数据类型，在存储过程和函数中可以使用游标对结果集进行循环的处理。游标的使用包括游标的声明、OPEN、FETCH和CLOSE，其语法分别如下。</p><p><strong>声明游标</strong></p><p>DECLARE 游标名称 CURSOR FOR 查询语句</p><p><strong>打开游标</strong></p><p>OPEN 游标名称</p><p><strong>获取游标记录</strong></p><p>FETCH 游标名称 INTO 变量[,变量];</p><p><strong>关闭游标</strong></p><p>CLOSE 游标名称</p><p><strong>条件处理程序</strong></p><p>条件处理程序(Handler)可以用来定义在流程控制结构执行过程中遇到问题时相应的处理步骤。具体语法：</p><p>DECLARE handler_action HANDLER FOR condition_value [,condition_value] … statement;</p><p>handler_action</p><p>​    CONTINUE：继续执行当前程序</p><p>​    EXIT：终止执行当前程序</p><p>condition_value</p><p>​    SQLSTATE sqlstate_value：状态码，如 02000</p><p>​    SQLWARNING：所有以01开头的SQLSTATE代码的简写</p><p>​    NOT FOUND：所有以02开头的SQLSTATE代码的简写</p><p>​    SQLEXCEPTION：所有没有被SQLWARNING 或NOT FOUND捕获的SQLSTATE代码的简写</p><h3 id="3-存储函数"><a href="#3-存储函数" class="headerlink" title="3.存储函数"></a>3.存储函数</h3><p>存储函数是有返回值的存储过程，存储函数的参数只能是IN类型的。具体语法如下：</p><p>CREATE FUNCTION 存储函数名称([参数列表])</p><p>RETURNS type [characteristic …]</p><p>BEGIN</p><p>​    —SQL语句</p><p>​    RETURN …;</p><p>END;</p><p>characteristic说明：</p><p>DETERMINISTIC：相同的输入参数总是产生相同的结果</p><p>NO SQL：不包含SQL语句。</p><p>READS SQL DATA：包含读取数据的语句，但不包含写入数据的语句。</p><h3 id="4-触发器"><a href="#4-触发器" class="headerlink" title="4.触发器"></a>4.触发器</h3><p>触发器是与表有关的数据库对象，指在insert/update/delete之前或之后，触发并执行触发器中定义的SQL语句集合。触发器的这种特性可以协助应用在数据库端确保数据的完整性，日志记录，数据校验等操作。</p><p>使用别名OLD和NEW来引用触发器中发生变化的记录内容，这与其他的数据库是相似的。现在触发器还只支持行级触发，不支持语句级触发。</p><p>INSERT型触发器                NEW表示将要或者已经新增的数据</p><p>UPDATE型触发器                OLD表示修改之前的数据，NEW表示将要或已经修改后的数据</p><p>DELETE型触发器                OLD表示将要或者已经删除的数据</p><p>语法</p><p><strong>创建</strong></p><p>CREATE TRIGGER trigger_name</p><p>BEFORE/AFTER INSERT/UPDATE/DELETE</p><p>ON tbl_name FOR EACH ROW –行级触发器</p><p>BEGIN</p><p>​    trigger_stmt;</p><p>END;</p><p>查看</p><p>SHOW TRIGGERS;</p><p>删除</p><p>DROP TRIGGER [schema_name.]trigger_name;  –如果没有指定schema_name,默认为当前数据库</p><p>for example:</p><p>​    create trigger tb_user_insert_trigger after insert on tb_user for each row</p><p>begin</p><p>​    insert into user_logs(id,…) values (null,’..’, …);</p><p>end;</p><h2 id="五、锁"><a href="#五、锁" class="headerlink" title="五、锁"></a>五、锁</h2><p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220309164159482.png" alt="image-20220309164159482"></p><p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220309164345793.png" alt="image-20220309164345793"></p><p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220309164608686.png" alt="image-20220309164608686"></p><p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220309164642892.png" alt="image-20220309164642892"></p><p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220309164718523.png" alt="image-20220309164718523"></p><p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220309165058328.png" alt="image-20220309165058328"></p><p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220309165235155.png" alt="image-20220309165235155"></p><p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220309165705600.png" alt="image-20220309165705600"></p><p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220309165905507.png" alt="image-20220309165905507"></p><p>锁是计算机协调多个进程或线程并发访问某一资源的机制。</p><p>分类</p><p>Mysql中的锁，按照锁的粒度分，分为三类：</p><p>1.全局锁：锁定数据库中的所有表。</p><p>2.表级锁：每次操作锁住整张表。</p><p>3.行级锁：每次操作锁住对应的行数据。</p><h3 id="3-锁的不同角度分类"><a href="#3-锁的不同角度分类" class="headerlink" title="3.锁的不同角度分类"></a>3.锁的不同角度分类</h3><p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220309170239637.png" alt="image-20220309170239637"></p><p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220309170511451.png" alt="image-20220309170511451"></p><p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220309170626839.png" alt="image-20220309170626839"></p><p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220309170810263.png" alt="image-20220309170810263"></p><p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220309171509577.png" alt="image-20220309171509577"></p><p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220309171909498.png" alt="image-20220309171909498"></p><p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220309172120224.png" alt="image-20220309172120224"></p><p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220309172307713.png" alt="image-20220309172307713"></p><p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220309172816794.png" alt="image-20220309172816794"></p><p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220309172948856.png" alt="image-20220309172948856"></p><p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220309173340727.png" alt="image-20220309173340727"></p><p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220309174257357.png" alt="image-20220309174257357"></p><p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220309174351960.png" alt="image-20220309174351960"></p><p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220309174533017.png" alt="image-20220309174533017"></p><p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220309174728417.png" alt="image-20220309174728417"></p><p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220309174819279.png" alt="image-20220309174819279"></p><p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220309174941327.png" alt="image-20220309174941327"></p><p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220309175340975.png" alt="image-20220309175340975"></p><p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220309175509615.png" alt="image-20220309175509615"></p><p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220309191206412.png" alt="image-20220309191206412"></p><p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220309191452952.png" alt="image-20220309191452952"></p><p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220309191836476.png" alt="image-20220309191836476"></p><p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220309193209124.png" alt="image-20220309193209124"></p><p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220309193318817.png" alt="image-20220309193318817"></p><p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220309193420329.png" alt="image-20220309193420329"></p><p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220309194823369.png" alt="image-20220309194823369"></p><p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220309195342805.png" alt="image-20220309195342805"></p><p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220309195839145.png" alt="image-20220309195839145"></p><p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220309200204412.png" alt="image-20220309200204412"></p><p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220309200314386.png" alt="image-20220309200314386"></p><p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220309200346633.png" alt="image-20220309200346633"></p><p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220309200509985.png" alt="image-20220309200509985"></p><p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220309200736225.png" alt="image-20220309200736225"></p><p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220309201052043.png" alt="image-20220309201052043"></p><p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220309201140886.png" alt="image-20220309201140886"></p><p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220309201234786.png" alt="image-20220309201234786"></p><p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220309201700103.png" alt="image-20220309201700103"></p><p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220309201842287.png" alt="image-20220309201842287"></p><p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220309201921125.png" alt="image-20220309201921125"></p><p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220309202043841.png" alt="image-20220309202043841"></p><p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220309202343463.png" alt="image-20220309202343463"></p><p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220309203650685.png" alt="image-20220309203650685"></p><p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220309203851737.png" alt="image-20220309203851737"></p><p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220309203915634.png" alt="image-20220309203915634"></p><p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220309204014595.png" alt="image-20220309204014595"></p><p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220309204121259.png" alt="image-20220309204121259"></p><p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220309204254373.png" alt="image-20220309204254373"></p><p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220309204345921.png" alt="image-20220309204345921"></p><p>1.互斥条件：进程要求对所分配的资源进行排他性控制，即在一段时间内某资源仅为一个进程所占有。此时若有其他进程请求该资源，则请求进程只能等待。</p><p>2.不可剥夺条件：进程所获得的资源在未使用完毕之前，不能被其他进程强行夺走，即只能由获得该资源的进程自己来释放（只能是主动释放)。</p><p>3.请求与保持条件：进程已经保持了至少一个资源，但又提出了新的资源请求，而该资源已被其他进程占有，此时请求进程被阻塞，但对自己已获得的资源保持不放。</p><p>4.循环等待条件：存在一种进程资源的循环等待链，链中每一个进程已获得的资源同时被 链中下一个进程所请求。</p><p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220309210426060.png" alt="image-20220309210426060"></p><p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220309210515261.png" alt="image-20220309210515261"></p><p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220309210825867.png" alt="image-20220309210825867"></p><p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220309211004450.png" alt="image-20220309211004450"></p><p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220309211209258.png" alt="image-20220309211209258"></p><p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220309211230916.png" alt="image-20220309211230916"></p><p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220309211345538.png" alt="image-20220309211345538"></p><p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220309211442962.png" alt="image-20220309211442962"></p><p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220309211629980.png" alt="image-20220309211629980"></p><p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220309211759035.png" alt="image-20220309211759035"></p><p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220309211837921.png" alt="image-20220309211837921"></p><p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220309211934844.png" alt="image-20220309211934844"></p><p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220309212247419.png" alt="image-20220309212247419"></p><p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220309212415282.png" alt="image-20220309212415282"></p><p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220309212441764.png" alt="image-20220309212441764"></p><h3 id="1-全局锁"><a href="#1-全局锁" class="headerlink" title="1.全局锁"></a><strong>1.全局锁</strong></h3><p>全局锁就是对整个数据库实例加锁，加锁后整个实例就处于只读状态，后续的DML的写语句，DDL语句，已经更新操作的事务提交语句都将被阻塞。</p><p>其典型的使用场景是做全库的逻辑备份，对所有的表进行锁定，从而获取一致性视图，保证数据的完整性。</p><p>加全局锁</p><p>flush tables with read lock;</p><p>数据备份</p><p>mysqldump -h 192.168.0.0.1 -uroot -proot db1 &gt; xxx.sql</p><p>解锁</p><p>unlock tables;</p><p>特点</p><p>数据库中加全局锁，是一个比较重的操作，存在一下问题：</p><p>1.如果在主库上备份，那么在备份期间都不能执行更新，业务基本上就得停摆。</p><p>2.如果在从库上备份，那么在备份期间从库不能执行从库同步过来的二进制日志(binlog)，会导致主从延迟。</p><p>在InnoDB引擎中，我们可以在备份时加上参数 –single-transaction参数来完成不加锁的一致性数据备份。</p><h3 id="2-表级锁"><a href="#2-表级锁" class="headerlink" title="2.表级锁"></a><strong>2.表级锁</strong></h3><p>表级锁，每次操作锁住整张表。锁定粒度大，发生锁冲突的概率最高，并发度最低。应用在MyISAM、InnoDB、BDB等存储引擎中。</p><p>表级锁分为：</p><p>1.表锁</p><p>2.元数据锁(meta data lock,MDL)</p><p>3.意向锁</p><p><strong>1.表锁：</strong></p><p>1.表共享锁(read lock)</p><p>2.表独占写锁(write lock)</p><p>语法：</p><p>1.加锁：lock tables 表名.. read/write。</p><p>read 当前客户端和其他客户端能读，但是不能写。</p><p>write 当前客户端可读可写，其他客户端不可读写。</p><p>2.释放锁：unlock tables/客户端断开连接。</p><p><strong>2.元数据锁</strong></p><p>MDL加锁过程是系统自动控制，无需显式使用，在访问一张表的时候会自动加上。MDL锁主要作用是维护表元数据的数据一致性，在表上有活动事务的时候，不可以对元数据进行写入操作。为了避免DML与DDL冲突，保证读写的正确性。</p><p>当对一张表进行增删改查的时候，加MDL读锁(共享)；当对表结构进行变更操作的时候，加MDL写锁(排他)。</p><p>对应SQL                                                                   锁类型                                                                                            说明</p><p>lock tables xxx read/write                                SHARED_READ_ONLY/SHARED_NO_READ_WRITE</p><p>select、select … lock in share mode                SHARED_READ                                       与SHARED_READ、SHARES_WRITE兼容、与EXCLUSIVE互斥</p><p>insert、update、delete、select…for update  SHARED_WRITE                                    与SHARED_READ、SHARED_WRITE兼容，与EXCLUSIVE互斥</p><p>alter table…                                                            EXCLUSIVE                                            与其他的MDL都互斥</p><p>查看元数据锁</p><p>select object_type,object_schema,object_name,lock_type,lock_duration from performance_schema.metadata_locks;</p><p><strong>3.意向锁</strong></p><p>为了避免DML在执行时，加的行锁与表锁的冲突，在InnoDB中引入意向锁，使得表锁不用检查每行数据是否加锁，使用意向锁来减少表锁的检查。</p><p>1.意向共享锁(IS)：由语句select…lock in share mode添加。</p><p>与表锁共享锁(read)兼容，与表锁排它锁(write)互斥。</p><p>2.意向排他锁(IX)：由insert、update、delete、select…for update添加。</p><p>与表锁共享锁(read)及排它锁(write)都互斥。意向锁之间不会互斥。</p><p>查看意向锁及行锁的加锁情况：</p><p>select object_schema,object_name,index_name,lock_type,lock_mode,lock_data from performance_schema.data_locks;</p><h3 id="3-行级锁"><a href="#3-行级锁" class="headerlink" title="3.行级锁"></a>3.行级锁</h3><p>行级锁，每次操作锁住对应的行数据。锁定粒度最小，发生锁冲突的概率最低，并发度最高。应用在InnoDB存储引擎中。</p><p>InnoDB的数据是基于索引组织的，行锁是通过对索引上的索引项加锁来实现的，而不是对记录加的锁。对于行级锁，主要分为一下三类：</p><p>1.行锁(Record Lock)：锁定单个行记录的锁，防止其他事务对此行进行update和delete。在RC、RR隔离级别下都支持。</p><p>2.间隙锁(Gap Lock)：锁定索引记录间隙(不含该记录)，确保索引记录间隙不变，防止其他事务在这个间隙进行insert,产生幻读。在RR隔离级别下都支持。</p><p>3.临键锁(Next-Key Lock)：行锁和间隙锁组合，同时锁住数据，并锁住数据前面的间隙Gap。在RR隔离级别下支持。</p><p>1.行锁</p><p>InnoDB实现了以下两种类型的行锁：</p><p>1.共享锁(S)：允许一个事务去读一行，阻止其他事务获得相同数据集的排它锁。</p><p>2.排它锁(X)：允许获取排它锁的事务更新数据，阻止其他事务获得相同数据集的共享锁和排它锁。</p><p>INSERT …                                                                        排它锁                                                            自动加锁</p><p>UPDATE…                                                                        排它锁                                                            自动加锁</p><p>DELETE…                                                                        排它锁                                                            自动加锁</p><p>SELECT(正常)                                                                    不加任何锁</p><p>SELECT…LOCK IN SHARE MODE                                    共享锁                                                        需要手动在SELECT之后加LOCK IN SHARE MODE</p><p>SELECT… FOR UPDATE                                                    排它锁                                                        需要手动在SELECT之后加FOR UPDATE</p><p>默认情况下，InnoDB在REPEATABLE READ事务隔离级别运行，InnoDB使用next-key锁进行搜索和索引扫描，以防止幻读。</p><p>1.针对唯一索引进行检索时，对已存在的记录进行等值匹配时，将会自动优化为行锁。</p><p>2.InnoDB的行锁是针对于索引加的锁，不通过索引条件检索数据，那么InnoDB将对表中的所有记录加锁，此时就会<strong>升级为表锁</strong>。</p><p>2.间隙锁/临键锁</p><p>默认情况下，InnoDB在REPEATABLE READ事务隔离级别运行，InnoDB使用next-key锁进行搜索和索引扫描，以防止幻读。</p><p>1.索引上的等值查询(唯一索引)，给不存在的记录加锁时，优化为间隙锁。</p><p>2.索引上的等值查询(普通索引)，向右遍历时最后一个值不满足查询需求时，next-key lock退化为间隙锁。</p><p>3.索引上的范围查询(唯一索引)–会访问到不满足条件的第一个值为止。</p><p>注意：间隙锁唯一目的是防止其他事务插入间隙。间隙锁可以共存，一个事务采用的间隙锁不会阻止另一个事务在同一间隙上采用间隙锁。</p><h2 id="六、InnoDB引擎"><a href="#六、InnoDB引擎" class="headerlink" title="六、InnoDB引擎"></a>六、InnoDB引擎</h2><p>InnoDB主要包括了内存池、后台线程以及存储文件。</p><p>INNODB的三大特性：插入缓存，两次写，自适应hash。</p><h4 id="内存池"><a href="#内存池" class="headerlink" title="内存池"></a><strong>内存池</strong></h4><p>数据库读写数据如果直接操作磁盘进行读写的话，会带来一定的性能瓶颈，缓冲池就是为了提高数据库的读写性能，客户端读取数据时，如果数据存在于缓冲池中，客户端就会直接读取缓冲池中的数据，否则再去磁盘中读取，对于数据库中的修改数据，首先是修改在缓冲池中的数据，然后再通过Master Thread线程刷新到磁盘上。</p><p><strong>缓冲池中缓存的数据页类型</strong></p><p>索引页、数据页、 undo 页、插入缓冲(insert buffer)、自适应哈希索引(adaptive hash index)、锁信息(lock info)、数据字典信息(data dictionary)等。索引页和数据页占缓冲池的很大一部分。InnoDB中，缓冲池中的页大小默认为16KB。</p><p><strong>LUR算法</strong></p><p>缓冲池是通过LRU(Latest Recent Used，最近最少使用)算法来进行管理的，即最频繁使用的页在LRU列表的最前段，而最少使用的页在LRU列表的尾端，当缓冲池不能存放新读取到的页时，首先释放LRU列表尾端的页。</p><p><strong>缓冲池</strong>(buffer pool)</p><p>参数innodb_buffer_pool_size配置其大小，是占内存最大的一部分，用来存放各种数据的缓存，innodb将数据库文件按页(16K)读取到缓冲池，然后使用(LRU)算法来保留缓存数据。数据修改时，先修改缓存池中的页（即脏页），然后按一定频率将脏页刷新到磁盘文件里面。</p><p>查看buffer pool的使用情况：show engine innodb status</p><p><strong>重做日志缓冲池</strong>(redo log buffer)</p><p>其大小在参数innodb_log_buffer_size 配置，将重做日志先放入这个区，然后按一定频率将其刷新至重做日志文件，一般情况下每1秒就会刷新一次。</p><p><strong>额外内存池</strong>(additional memory pool)</p><p>其大小在参数innodb_additional_mem_pool_size 配置，innodb申请缓冲池(buffer pool)时，每个缓冲池中的页缓冲有对应的缓冲控制对象(buffer control block)，会记录LRU、锁、等待等信息，相对的占用内存空间大小。因此当buffer pool较大时，额外内存池参数页要相应的变大。</p><h4 id="后台线程"><a href="#后台线程" class="headerlink" title="后台线程"></a>后台线程</h4><p>InnoDB后台有多个不同的线程，用来负责不同的任务</p><p><strong>Master Thread</strong>：是最核心的一个线程,主要负责将缓冲池中的数据异步刷新到磁盘,保证数据的一致性,包括赃页的刷新、合并插入缓冲、UNDO页的回收等。具有最高的线程优先级别，内部由多个循环组成：主循环（loop）、后台循环（background loop）、刷新循环（flush loop）、暂停循环（suspend loop），Master Thread会根据数据库运行的状态进行循环之间的切换</p><pre class="line-numbers language-markdown" data-language="markdown"><code class="language-markdown">1.主循环 loop该循环中完成的有两种操作，每秒一次的操作和每10秒一次的操作每秒一次的操作:a)日志缓冲刷新到磁盘(总是)：即使事务没有提交，InnoDB也会每秒将重做日志缓冲刷新到重做日志文件中，因此可以理解为什么再大的事务提交，时间也是很短的。b)合并插入缓冲（可能）:并不是每秒刷新的，如果前一秒的IO次数小于5，则认为IO压力小，可以执行合并插入缓冲的操作。c)最多刷新100个InnoDB的缓冲池脏页到磁盘（可能）：判断当前缓冲池中脏页的比例(buf_get_modifyed_ratio_pct)是否超过了配置文件中innodb_max_dirty_pages_pct这个参数（默认为90）如               果超过了这个阈值，InnoDB存储引擎认为需要做同步操作，将100个脏页写入磁盘中。d)如果当前没有用户活动，切换到background loop（可能）。每10秒一次的操作:a)刷新100个脏页到磁盘（可能），如果过去10秒磁盘io操作小于200次，则执行本操作b)合并最多5个插入缓冲（总是）c)将日志缓冲刷新到磁盘（总是）d)删除无用的undo页（总是）e)刷新100个或10个脏页到磁盘（总是），判断缓冲池脏页比例，超过70%则刷新100个脏页，比例小于10%则刷新10个脏页；f)产生一个检查点checkpoint（总是），此时并不是把所有脏页都刷新到了磁盘，只是将最老日志序列号的页写入磁盘；2 后台循环 background loop当没有用户活动或数据库关闭时，会切换到这个循环a)删除无用的undo页（总是）；b)合并20个插入缓冲（总是）；c)跳回到主循环（总是）；d)不断刷新100个页,直到符合条件(可能,跳转到flush loop中完成),如果fulsh loop页没有事情可以做了，InnoDB存储引擎会切换到suspend loop，将Master Thread挂起。3 flush loop由background loop跳转到此loop中完成刷新脏页的工作当flush loop中无事可做时会切换到suspend loop4 suspend loop该loop将master thread挂起，等待事件发生，在启用了innodb引擎，但未使用innodb表时，master thread总是处于挂起状态；5 查看示例show engine innodb status<span class="token hr punctuation">-----------------</span><span class="token title important">BACKGROUND THREAD<span class="token punctuation">-----------------</span></span>srv_master_thread loops: 4 1_second, 4 sleeps, 0 10_second, 6 background, 6 flushsrv_master_thread log flush and writes: 4说明(1)主循环，每秒一次的操作有4次，每10秒一次的操作有0次；一般这两个比例在1:10时较合理。(2)background loop，执行了6次，flush loop执行了6次。(3)其中的sleeps指循环中的每秒sleep的操作，一般压力较小情况下此值和每秒一次的操作数相同，压力大时会小于每秒一次的操作数。6 新版本优化了上边的判断配置值innodb_io_capacity=200合并插入缓冲时，合并插入缓冲的数量为innodb_io_capacity数值的5%。缓冲区刷新到磁盘时，刷新脏页数量为innodb_io_capacity。使用情况：在使用了ssd磁盘，或做了raid后，可将此值设置较大，直到符合磁盘io的吞吐量7 其它配置值innodb_max_dirty_pages_pct=90每秒的主loop和flush loop中，会判断此值，如果大于才刷新100个脏页，在数据库压力很大时，这时刷新速度反而会降低，google的测试表明75是个合理值。innodb_adaptive_flushing=on该值影响每秒刷新脏页的操作，开启此配置后，刷新脏页会通过判断产生重做日志的速度来判断最合适的刷新脏页的数量。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>IO Thread</strong>：在InnoDB存储引擎中大量使用了异步IO来处理写的请求, IO Thread 的工作主要是负责这些IO请求的回调处理。包括以下几种：read thread、write thread、<a href="https://so.csdn.net/so/search?q=insert&amp;spm=1001.2101.3001.7020">insert</a>&nbsp;buffer thread、log thread。</p><pre class="line-numbers language-markdown" data-language="markdown"><code class="language-markdown">配置设置:read thread、write thread分别由innodb_read_io_threads、innodb_write_io_threads配置，log thread和insert buffer thread一般是1。查看命令：show variables like '%threads%';show engine innodb status;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>Purge Thread</strong>：事务被提交之后, undo log可能不再需要,因此需要Purge Thread 来回收已经使用并分配的undo页。InnoDB支持多个Purge Thread, 这样做可以加快undo页的回收。</p><p><strong>Page Cleaner Thread</strong>：在InnoDB 1.2.x版本新引入的,其作用是将之前版本中脏页的刷新操作都放入单独的线程中来完成,这样减轻了Master Thread的工作及对于用户查询线程的阻塞。</p><h4 id="存储文件"><a href="#存储文件" class="headerlink" title="存储文件"></a>存储文件</h4><p>由InnoDB存储引擎实现的表的存储结构文件一般包括表结构文件（.frm）、共享表空间文件（ibdata1）、独占表空间文件（ibd）以及日志文件（redo文件等）等。</p><p><strong>表空间</strong>(Tablespaces):表空间是由各个段组成。</p><p><strong>段</strong>(segment):一个段由若干个簇构成。</p><p><strong>簇/区</strong>(Extents):簇是构成段的基本元素,包含64个页。</p><p><strong>页</strong>(Page):在向表中插入数据时，如果一个页面已经被写完，系统会从当前簇中分配一个新的空闲页面处理使用，如果当前簇中的64个页面都被分配完，系统会从当前页面所在段中分配一个新的簇，然后再从这个簇中分配一个新的页面来使用。每个页大小为16KB，簇是由64个连续的页组成，即每个簇的大小为1MB。</p><h3 id="InnoDB原理"><a href="#InnoDB原理" class="headerlink" title="InnoDB原理"></a>InnoDB原理</h3><p>InnoDB存储引擎基于磁盘存储，数据存储在磁盘上，由于CPU速度和磁盘速度之间的鸿沟，使用缓冲池技术来提高数据库的整体性能。缓冲池简单来说就是一块内存区域，在数据库中进行读取页的操作时,首先从磁盘读到的页存放在缓冲池中,下一次读取相同的页时,先判断该页是不是在缓冲池中，若在则该页在缓冲池中被命中，直接读取该页，否则就读取磁盘上的页然后再放到缓冲池中。对于数据库中页的修改操作，首先修改在缓冲池中页，然后以一定的频率刷新到磁盘，并不是每次页发生改变就刷新回磁盘。</p><h3 id="InnoDB关键特性"><a href="#InnoDB关键特性" class="headerlink" title="InnoDB关键特性"></a>InnoDB关键特性</h3><p><strong>插入缓冲</strong>(insert buffer)：是innodb引擎的关键特性之一，是从缓冲池中分配的，用来对插入的性能进行优化和提升，即对有非唯一的非聚集索引的索引页的插入进行了缓冲，之后合并再插入。<br>工作原理：当表只有一个聚集索引时，插入顺序是按照该主键的顺序进行插入的，不需要磁盘的随机读取，当表有一个或多个非聚集索引且该索引不是表的唯一索引时，插入时数据按主键顺序存放，但叶子节点需要离散地访问非聚集索引页，插入性能会降低。这时插入缓冲生效，先判断非聚集索引页是否在缓冲池中，如果在就直接插入，如果不在则先放入一个插入缓冲区，然后再以一定的频率执行插入缓冲和非聚集索引页子节点的合并操作。</p><pre class="line-numbers language-markdown" data-language="markdown"><code class="language-markdown">插入缓冲生效的条件存在非聚集索引，且索引不是表的唯一索引；插入缓冲的分析<span class="token title important">show engine innodb status<span class="token punctuation">-------------------------------------</span></span><span class="token title important">INSERT BUFFER AND ADAPTIVE HASH INDEX<span class="token punctuation">-------------------------------------</span></span>Ibuf: size 1, free list len 2366, seg size 2368, 0 mergesmerged operations: insert 0, delete mark 0, delete 0discarded operations: insert 0, delete mark 0, delete 0Hash table size 103867, node heap has 1 buffer(s)0.00 hash searches/s, 0.20 non-hash searches/s说明(1)seg size：当前插入缓冲的大小 2368*16K，free list len表示空闲列表的长度，size表示已经合并记录页的数量，merges表示合并的数量。(2)merged operations：合并的情况,inserts表示插入的记录数。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>两次写缓存</strong>（doublewrite buffer）：innodb引擎的关键特性之一，两次写保证的是innodb的可靠性，插入缓冲保证的是性能。数据文件的结构： 页 page 16K, 区 extent 1M, 段 seg 2M。</p><pre class="line-numbers language-markdown" data-language="markdown"><code class="language-markdown">部分写失效情况：当数据库正在从内存向磁盘写一个数据页时，数据库宕机，导致这个页只写了部分数据，就造成了部分写失效，导致数据丢失。这个是无法通过重做日志恢复                                    的，因为重做日志记录的是对页的物理修改，如果页本身已经损坏，重做日志也无能为力，两次写需要额外添加两个部分：doublewrite由两部分组成：一部分是内存中的doublewrite buffer，大小为2MB；另一部分是物理磁盘上共享表空间中连续的128个页，即两个区（extent），大小同样为2MB(页的副本)。当缓冲                  池的脏页刷新时，并不直接写磁盘，而是会通过memcpy函数将脏页先拷贝到内存中的doublewrite buffer，之后通过doublewrite buffer再分两次，每次写入1MB到共享表空间的物理磁盘上，然后                  马上调用fsync函数，同步磁盘，避免缓冲写带来的问题。在这个过程中，因为doublewrite页是连续的，因此这个过程是顺序写的，开销并不是很大。在完成doublewrite页的写入后，再将                        doublewrite buffer中的页写入各个表空间文件中，此时的写入则是离散的。<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>br</span><span class="token punctuation">&gt;</span></span> 刷新脏页时，先后做三步工作： 一先将脏页拷贝到内存的doublewrite buffer， 二是通过该buffer两次写入（每次写入1M）到共享表空间，然后马上调用fsync函数同步磁盘；这个过程是顺序写的，开销不大； 三是再将该buffer中的页写入各个表空间文件中，此过程中的写入是离散的； 查看doublewrite的运行情况 show global status like 'innodb_dblwr%'\G +----------------------------+-------+ | Variable_name             | Value | +----------------------------+-------+ | Innodb_dblwr_pages_written | 4    | | Innodb_dblwr_writes       | 2    | +----------------------------+-------+ 结果分析 pages_written为写的页数，writes为写的次数，一般两者的比例小于64：1； 如果比例较高，说明写入压力较大； 写入磁盘失效时的恢复原理 从共享表空间中的doublewrite中找到该页的一个副本，拷贝到表空间文件，再应用重做日志进行恢复； 配置 innodb_doublewrite=ON <span class="token title important"><span class="token punctuation">#</span>skip_innodb_doublewrite 或 innodb_doublewrite=OFF</span> 需要提供较快的性能时，可禁用双写；但在主服务器上，任何时间都应确保开启双写功能； 有些文件系统本身提供了部分写失效的机制，如zfs文件系统，此时可以关闭双写；<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>自适应哈希索引</strong>：哈希是一种非常快的查找方法，在一般情况时间复杂度为O(1)。而B+树的查找次数，取决于B+树的高度。InnoDB存储引擎会监控对表上索引的查找，如果观察到建立哈希索引可以带来速度的提升，则建立哈希索引，称之为自适应哈希索引(Adaptive Hash Index, AHI)。自适应哈希索引通过缓冲池的B+树构造而来，因此建立的速度很快。而且不需要将整个表都建哈希索引。InnoDB存储引擎会自动根据访问的频率和模式来自动的为某些热点页建立哈希索引。AHI有一个要求，对这个页的连续访问模式(查询条件)必须一样的。例如联合索引(a,b)其访问模式可以有以下情况:WHERE a=XXX;WHERE a=xxx AND b=xxx。若交替进行上述两张查询，InnoDB存储引擎不会对该页构造AHI。此外AHI还有如下要求：以该模式访问了100次；页通过该模式访问了N次，其中N=页中记录/16。根据官方文档显示，启用AHI后，读取和写入的速度可以提高2倍，负责索引的链接操作性能可以提高5倍。其设计思想是数据库自由化的，无需DBA对数据库进行人为调整。</p><pre class="line-numbers language-markdown" data-language="markdown"><code class="language-markdown">工作机制innodb会自动监控表上索引的查找，如果发现建立哈希索引可以带来速度的提升，则建立哈希索引；建立的依据是根据访问的频率和模式自动进行的；据官方文档说明，对读取和写入可以提高2倍，对辅助索引的连接操作性能可提高5倍；适用条件只能用来搜索等值的查询，如select * from table where index_col='xxx'；对其他类型是不会被使用的；查看运行情况<span class="token title important">show engine innodb status<span class="token punctuation">-------------------------------------</span></span><span class="token title important">INSERT BUFFER AND ADAPTIVE HASH INDEX<span class="token punctuation">-------------------------------------</span></span>Ibuf: size 1, free list len 2366, seg size 2368, 0 mergesmerged operations: insert 0, delete mark 0, delete 0discarded operations: insert 0, delete mark 0, delete 0Hash table size 103867, node heap has 1 buffer(s)0.00 hash searches/s, 0.00 non-hash searches/s结果说明hash searches显示了hash查找的次数non-hash searches显示了不能利用hash查找的次数；配置：innodb_adaptive_hash_index=ON<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>异步IO</strong>(AIO)：为了提高磁盘操作性能，当前的数据库系统都采用异步IO的方式来处理磁盘操作。InnoDB也是如此。与AIO对应的是Sync IO，即每进行一次IO操作，需要等待此次操作结束才能继续接下来的操作。但是如果用户发出的是一条索引扫描的查询，那么这条SQL语句可能需要扫描多个索引页，也就是需要进行多次IO操作。在每扫描一个页并等待其完成再进行下一次扫描。用户可以在发出一个IO请求后立即再发出另外一个IO请求，当全部IO请求发送完毕后，等待所有IO操作完成，这就是AIO。AIO的另外一个优势是进行IO Merge操作，也就是将多个IO合并为一个IO操作，这样可以提高IOPS的性能。在InnoDB 1.1.x之前，AIO的实现是通过InnoDB存储引擎中的代码来模拟的。但是从这之后，提供了内核级别的AIO的支持，称为Native AIO。Native AIO需要操作系统提供支持。Windows和Linux都支持，而Mac则未提供。在选择MySQL数据库服务器的操作系统时，需要考虑这方面的因素。MySQL可以通过参数innodb_use_native_aio来决定是否启用Native AIO。在InnoDB存储引擎中，read ahead方式的读取都是通过AIO完成，脏页的刷新，也是通过AIO完成。</p><p><strong>刷新邻接页</strong>：InnoDB存储引擎在刷新一个脏页时，会检测该页所在区(extent)的所有页，如果是脏页，那么一起刷新。这样做的好处是通过AIO可以将多个IO写操作合并为一个IO操作。InnoDB存储引擎1.2.x版本开始提供参数innodb_flush_neighbors决定是否启用。</p><h3 id="CheckPoint"><a href="#CheckPoint" class="headerlink" title="CheckPoint"></a>CheckPoint</h3><p>数据库在执行增删查改操作的时候，为了提高事物操作的效率，都是先在buffer pool中完成的，buffer pool中修改之后的数据，并没有立即写入到磁盘，这有可能会导致内存中数据与磁盘中的数据产生不一致的情况。 事物要求之一是持久性（Durability），buffer pool与磁盘数据的不一致性的情况下发生故障，可能会导致数据无法持久化。为了防止在内存中修改但尚未写入到磁盘的数据，在发生故障重启数据之后产生事物未持久化的情况，是通过日志(redo log)先行的方式来保证的。redo log可以在故障重启之后实现重做，保证了事物的持久化的特性，但是redo log空间不可能无限制扩大，对于内存中已修改但尚未提交到磁盘的数据(脏页)，要写入磁盘的情况，用checkpoint技术来解决。内存中的脏页，什么时候，什么情况下，将多少脏页写入磁盘，是由多方面因素决定的，checkpoint的工作之一，就是对于内存中的脏页，在一定条件下刷新到磁盘。checkpoint技术主要的作用：</p><p><strong>缩短数据库恢复时间</strong></p><p><strong>缓冲池不够用时</strong>，将脏页刷新到磁盘 每次刷新多少页到磁盘？每次从哪里取脏页？什么时间触发checkpoint？</p><pre class="line-numbers language-markdown" data-language="markdown"><code class="language-markdown">InnoDB存储引擎内部，两种checkpoint:1.Sharp Checkpoint：发生在数据库关闭时，将所有的脏页都刷新回磁盘，这是默认的工作方式，即参数：innodb_fast_shutdown=1。不适用于数据库运行时的刷新。2.Fuzzy Checkpoint：在数据库运行时，InnoDB存储引擎内部采用Fuzzy Checkpoint，只刷新一部分脏页。几种发生Fuzzy Checkpoint的情况：1.MasterThread Checkpoint异步刷新，每秒或每10秒从缓冲池脏页列表刷新一定比例的页回磁盘。异步刷新，即此时InnoDB存储引擎可以进行其他操作，用户查询线程不会受阻。--&gt;参考master Thread的介绍2.FLUSH_LRU_LIST CheckpointInnoDB存储引擎需要保证LRU列表中差不多有100个空闲页可供使用。在InnoDB 1.1.x版本之前，用户查询线程会检查LRU列表是否有足够的空间操作。如果没有，根据LRU算法，溢出LRU列表尾端的页，如             果这些页有脏页，需要进行checkpoint。因此叫：flush_lru_list checkpoint.mysql5.6之后，也就是Innodb1.2.x开始，这个检查放在了单独的进程（Page Cleaner）中进行。好处：1.减少master Thread的压力 2.减轻用户线程阻塞。--&gt;参考page cleaner线程。设置参数：innodb_lru_scan_dept：控制LRU列表中可用页的数量，该值默认1024 3.Async/Sync Flush Checkpoint指重做日志不可用的情况，需要强制刷新页回磁盘，此时的页是脏页列表选取的。保证重做日志的可用性。写入日志的LSN:redo_lsn刷新回磁盘的最新页LSN:checkpoint_lsn定义:          checkpoint_age = redo_lsn - checkpoint_lsn          async_water_mark = 75% <span class="token italic"><span class="token punctuation">*</span><span class="token content"> total_redo_file_size          sync_water_mark = 90% </span><span class="token punctuation">*</span></span> total_redo_file_size4.Dirty Page too much Checkpoint即脏页太多，强制checkpoint.保证缓冲池有足够可用的页。参数设置：innodb_max_dirty_pages_pct = 75 表示：当缓冲池中脏页的数量占75%时，强制checkpoint。1.0.x之后默认75<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>&nbsp;<strong>重做日志不可用时，刷新脏页</strong></p><h3 id="1-逻辑存储结构"><a href="#1-逻辑存储结构" class="headerlink" title="1.逻辑存储结构"></a>1.逻辑存储结构</h3><p><strong>表空间</strong>(Tablespace)-&gt;Segment<strong>段</strong>-&gt;Extent(<strong>区</strong>)-&gt;Page(<strong>页</strong>)-&gt;Row(<strong>行</strong>)</p><p>表空间(ibd文件)，一个mysql实例可以对应多个表空间，用于存储记录、索引等数据。</p><p>段，分为数据段，索引段，回滚段，InnoDB是索引组织表，数据段就是B+树的叶子节点，索引段即为B+树的非叶子节点。段用来管理多个Extent(区)。</p><p>区，表空间的单元结构，每个区的大小为1M。默认情况下，InnoDB存储引擎页大小为16K，即一个区中一共有64个连续的页。</p><p>页，是InnoDB存储引擎磁盘管理的最小单元，每个页的大小默认为16KB。为了保证页的连续性，InnoDB存储引擎每次从磁盘申请4-5个区。</p><p>行，InnoDB存储引擎数据是按行进行存放的。</p><h3 id="2-架构"><a href="#2-架构" class="headerlink" title="2.架构"></a>2.架构</h3><p><strong>内存架构</strong></p><p>Buffer Pool：缓冲池是主内存中的一个区域，里面可以缓存磁盘上经常操作的真实数据，在执行增删改查操作时，先操作缓冲池中的数据（若缓冲池没有数据，则从磁盘加载并缓存），然后再以一定频率刷新到磁盘，从而减少磁盘IO，加快处理速度。</p><p>缓冲池以Page页为单位，底层采用链表数据结构管理Page。根据状态，将Page分为三种类型：</p><p>free page：空闲page,未被使用。</p><p>clean page：被使用page,数据没有被修改过。</p><p>dirty page：脏页，被使用page，数据被修改过，页中数据与磁盘的数据产生了不一致。</p><p>Change Buffer：更改缓冲区(针对于非唯一二级索引页)，在执行DML语句时，如果这些数据Page没有在Buffer Pool中，不会直接操作磁盘，而会将数据变更存在更改缓冲区Change Buffer中，在未来数据被读取时，再将数据合并恢复到Buffer Pool中，再将合并后的数据刷新到磁盘中。</p><p>Change Buffer的意义：</p><p>与聚集索引不同，二级索引通常是非唯一的，并且以相对随机的顺序插入二级索引。同样，删除和更新可能会影响索引树中不相邻的二级索引页，如果每一次都操作磁盘，会造成大量的磁盘IO。有了ChangeBuffer之后，我们可以在缓冲池中进行合并处理，减少磁盘IO。</p><p>Adaptive Hash Index：自适应hash索引，用于优化对Buffer Pool数据的查询。InnoDB存储引擎会监控对表上个索引页的查询，如果观察到hash索引可以提升速度，则建立hash索引，称之为自适应hash索引。</p><p>自适应哈希索引，无需人工干预，是系统根据情况自动生成。</p><p>参数：adaptive_hash_index</p><p>Log Buffer：日志缓冲区，用来保存要写入到磁盘中的log日志数据(redo log, undo log)，默认大小为16MB，日志缓冲区的日志会定期刷新到磁盘中。如果需要更新。插入或删除许多行的事务，增加日志缓冲器的大小可以节省磁盘IO。</p><p><strong>磁盘结构</strong></p><p>System Tablespace：系统表空间是更改缓冲区的存储区域。</p><p>File-Per-Table Tablespaces：每个表的文件表空间包含单个InnoDB表的数据和索引，并存储在文件系统上的单个数据文件中。</p><p>General Tablespaces：通用表空间，需要通过CREATE TABLESPACE语法创建通用表空间，在创建表时，可以指定该表空间。</p><p>CREATE TABLESPACE XXX ADD DATAFILE ‘file_name’ ENGINE = engine_name;</p><p>Create table xxx… TABLESPACE ts_name;</p><p>Undo Tablespaces：撤销表空间，Mysql实例在初始化时会自动创建两个默认的undo表空间（初始大小16M），用于存储undo log日志。</p><p>Temporary Tablespaces：InnoDB使用会话临时表空间和全局临时表空间。存储用户创建的临时表等数据。</p><p>Doublewrite Buffer Files：双写缓冲区，innoDB引擎将数据页从Buffer Pool刷新到磁盘前，先将数据页写入双写缓冲区文件中，便于系统异常时恢复数据。</p><p>Redo Log：重做日志，是用来实现事务的持久性。该日志文件由两部分组成；重做日志缓冲区(redo log buffer) 以及重做日志文件(redo log)，前者是在内存中，后者在磁盘中。当事务提交之后会把所有修改信息都会存到该日志中，用于在刷新脏页到磁盘时，发生错误时，进行数据恢复使用。</p><p>以循环方式写入重做日志文件。</p><p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220301113509432.png" alt="image-20220301113509432"></p><h3 id="3-事务原理"><a href="#3-事务原理" class="headerlink" title="3.事务原理"></a>3.事务原理</h3><p>原子性    通过undo log实现</p><p>持久性    通过redo log实现</p><p>一致性    通过redo log，undo log实现</p><p>隔离性    通过锁，MVCC实现</p><p>redo log：重做日志，记录的是事务提交时数据页的物理修改，是用来实现事务的持久性。该日志文件由两部分组成；重做日志缓冲区(redo log buffer) 以及重做日志文件(redo log)，前者是在内存中，后者在磁盘中。当事务提交之后会把所有修改信息都会存到该日志中，用于在刷新脏页到磁盘时，发生错误时，进行数据恢复使用。</p><p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220301114520277.png" alt="image-20220301114520277"></p><p>undo log：回滚日志，用于记录数据被修改前的信息，作用包含两个：提前回滚和MVCC（多版本并发控制）。</p><p>undo log和redo log 记录物理日志不一样，它是逻辑日志。可以认为当delete一条记录时，undo log中会记录一条对应的insert记录，反之亦然，当update一条记录时，它记录一条对应相反的update记录。当执行rollback时，就可以从undo log中的逻辑记录读取到相应的内容并进行回滚。</p><p>Undo log 销毁：undo log 在事务执行时产生，事务提交时，并不会立即删除undo log,因为这些日志可能还用于MVCC。</p><p>undo log存储：undo log采用段的方式进行管理和记录，存放在前面介绍的rollback segment回滚段中，内部包含1024个undo log segment。</p><h3 id="4-MVCC"><a href="#4-MVCC" class="headerlink" title="4.MVCC"></a>4.MVCC</h3><p>1.当前读</p><p>读取的是记录的最新版本，读取时还要保证其他并发事务不能修改当前记录，会对读取的记录进行加锁。对于我们日常的操作，如：</p><p>select .. lock in share mode(共享锁)，select … for update、update、insert、delete(排它锁)都是一种当前读。</p><p>2.快照读</p><p>简单的select(不加锁)就是快照读，快照读，读取的是记录数据的可见版本，有可能是历史数据，不加锁，是非阻塞读。</p><p>优点是可以不用加锁就可以读取到数据，缺点是读取到的数据可能不是最新的版本。 </p><p>Read committed：每次select，都生成一个快照读。</p><p>Repeatable Read：开启事务后第一个select语句才是快照读的地方。</p><p>Serializable：快照读会退化为当前读。</p><p>3.MVCC</p><p>全称Multi-Version Concurrency Control，多版本并发控制。指维护一个数据的多个版本，使得读写操作没有冲突，快照读为Mysql实现MVCC提供了一个非阻塞读功能。MVCC的具体实现，还需要依赖于数据库记录中的三个隐藏字段、undo log日志、readView。</p><p>1.记录中的隐藏字段</p><p>DB_TRX_ID                            最近修改事务ID，记录插入这条记录或最后一次修改该记录的事务ID。</p><p>DB_ROLL_PTR                        回滚指针，指向这条记录的上一个版本，用于配合undo log，指向上一个版本。</p><p>DB_ROW_ID                            隐藏主键，如果表结构没有指定主键，将会生成该隐藏字段。</p><p>2.undo log</p><p>回滚日志，在insert、update、delete的时候产生的便于数据回滚的日志。</p><p>当insert的时候，产生的undo log日志只在回滚时需要，在事务提交后，可被立即删除。</p><p>而update、delete的时候，产生的undo log 日志不仅在回滚时需要，在快照读时也需要，不会立即删除。</p><p>undo log版本链</p><p>不同事务或相同事务对同一条记录进行修改，会导致该记录的undo log生成一条记录版本链表，链表的头部是最新的旧记录，链表尾部是最早的旧记录。</p><p>3.readView</p><p>ReadView(读视图)是快照读SQL执行时MVCC提取数据的依据，记录并维护系统当前活跃的事务(未提交)id。</p><p>ReadView中包含了四个核心字段：</p><p>m_ids                                                当前活跃的事务ID集合</p><p>min_trx_id                                        最小活跃事务ID</p><p>max_trx_id                                        预分配事务ID，当前最大事务ID+1（因为事务ID是自增的）</p><p>creator_trx_id                                    ReadView创建者的事务ID</p><p>readview</p><p>trx_id：代表是当前事务ID。</p><p><strong>版本链</strong>数据访问规则</p><ol><li>trx_id == creator_trx_id ? 可以访问该版本        成立，说明数据是当前这个事务更改的。</li><li>trx_id &lt; min_trx_id ? 可以访问该版本                成立，说明数据已经提交了。</li><li>trx_id &gt; max_trx_id ? 不可以访问该版本           成立，说明该事物是在ReadView生成后才开启。</li><li>min_trx_id &lt;= trx_id &lt;=max_trx_id ? 如果trx_id<strong>不在</strong>m_ids中是可以访问该版本的        成立，说明数据已经提交。</li></ol><p>不同的隔离级别，生成ReadView的时机不同：</p><p>READ COMMITTED：在事务中每一次执行快照读时生成ReadView。</p><p>REPEATABLE READ：仅在事务中第一次执行快照读时生成ReadView，后续复用该ReadView。</p><p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220309213056494.png" alt="image-20220309213056494"></p><p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220309214332164.png" alt="image-20220309214332164"></p><p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220309214431451.png" alt="image-20220309214431451"></p><h3 id="3-复习"><a href="#3-复习" class="headerlink" title="3.复习"></a>3.复习</h3><h4 id="3-1隔离级别"><a href="#3-1隔离级别" class="headerlink" title="3.1隔离级别"></a>3.1隔离级别</h4><p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220309214635388.png" alt="image-20220309214635388"></p><p>MVCC只是在“快照读”的情况下是可以解决“幻读”的问题的。</p><p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220309214841371.png" alt="image-20220309214841371"></p><p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220309214925034.png" alt="image-20220309214925034"></p><p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220309215007029.png" alt="image-20220309215007029"></p><p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220309215031586.png" alt="image-20220309215031586"></p><p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220309215109287.png" alt="image-20220309215109287"></p><p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220309215441717.png" alt="image-20220309215441717"></p><p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220309215708115.png" alt="image-20220309215708115"></p><p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220309220042372.png" alt="image-20220309220042372"></p><p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220309220149908.png" alt="image-20220309220149908"></p><p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220309220507524.png" alt="image-20220309220507524"></p><p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220309220656132.png" alt="image-20220309220656132"></p><p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220309220812677.png" alt="image-20220309220812677"></p><p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220309220839359.png" alt="image-20220309220839359"></p><p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220309220916591.png" alt="image-20220309220916591"></p><p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220309221158758.png" alt="image-20220309221158758"></p><p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220309221253029.png" alt="image-20220309221253029"></p><p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220309221342922.png" alt="image-20220309221342922"></p><p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220309221524999.png" alt="image-20220309221524999"></p><p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220309221553606.png" alt="image-20220309221553606"></p><p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220309221629942.png" alt="image-20220309221629942"></p><p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220309221653672.png" alt="image-20220309221653672"></p><p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220309221756868.png" alt="image-20220309221756868"></p><p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220309221834460.png" alt="image-20220309221834460"></p><p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220309221923243.png" alt="image-20220309221923243"></p><p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220309222010239.png" alt="image-20220309222010239"></p><p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220309222051998.png" alt="image-20220309222051998"></p><p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220309222139494.png" alt="image-20220309222139494"></p><p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220309222203628.png" alt="image-20220309222203628"></p><p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220309222228823.png" alt="image-20220309222228823"></p><p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220309222307330.png" alt="image-20220309222307330"></p><p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220309222326492.png" alt="image-20220309222326492"></p><p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220309222402125.png" alt="image-20220309222402125"></p><p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220309222526350.png" alt="image-20220309222526350"></p><p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220309222655909.png" alt="image-20220309222655909"></p><p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220309222844918.png" alt="image-20220309222844918"></p><p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220309222949019.png" alt="image-20220309222949019"></p><p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220309223003556.png" alt="image-20220309223003556"></p><p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220309223059420.png" alt="image-20220309223059420"></p><p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220309223133507.png" alt="image-20220309223133507"></p><h1 id="后记："><a href="#后记：" class="headerlink" title="后记："></a>后记：</h1><p>MySQL实现的MVCC，主要是用于在并发读写的情况下，保证 “读” 数据时无需加锁也可以读取到数据的某一个版本的快照，好处是可以避免加锁，降低开销，解决了读写冲突，增大了数据库的并发性能。 </p><p>在修改数据的时候，会向 redo log 中记录修改的页内容（为了在数据库宕机重启后恢复对数据库的操作），也会向 undo log 记录数据原来的快照（用于回滚事务）。undo log有两个作用，除了用于回滚事务，还用于实现MVCC。 </p><p><strong>MVCC</strong>主要是用来<strong>解决RU隔离级别下的脏读和RC隔离级别下的不可重复读的问题</strong>，所以<strong>MVCC只在RC（解决脏读）和RR（解决不可重复读）隔离级别下生效</strong>，也就是MySQL只会在RC和RR隔离级别下的快照读时才会生成ReadView。区别就是，在RC隔离级别下，每一次快照读都会生成一个最新的ReadView；在RR隔离级别下，只有事务中第一次快照读会生成ReadView，之后的快照读都使用第一次生成的ReadView。</p><h2 id="快照读–只针对Select操作"><a href="#快照读–只针对Select操作" class="headerlink" title="快照读–只针对Select操作"></a>快照读–只针对Select操作</h2><p>MVCC的机制。快照读不会产生幻读。因为ReadView生成后就不会发生变化</p><h2 id="当前读–针对数据修改操作"><a href="#当前读–针对数据修改操作" class="headerlink" title="当前读–针对数据修改操作"></a>当前读–针对数据修改操作</h2><p>每次执行都会读取最新的记录。（假设要update一条记录，但是在另一个事务中已经delete掉这条数据并且commit了，如果update就会产生冲突，所以在update的时候需要知道最新的数据。）</p><p>结论：<strong>MVCC的机制会使Select语句的快照读避免幻读，但是对于当前读的操作依然会出现幻读。</strong> </p><p>例子：假如A事务正在查询id&lt;10的所有数据，只存在id为1~7的数据，8、9并不存在，此时B事务向数据库插入id为8的数据，那么事务A就会出现幻读现象，本来是不存在id为8的数据的，但是像出现幻觉一样读取到了，这就是幻读。</p><p>解决办法：加上next-key锁（也就是行锁+gap锁）， 阻止事务A读取数据的时候，事务B向数据库插入数据，这样就避免幻读了。</p><p>结论：</p><ul><li>在快照读情况下，MySQL通过mvcc来避免幻读。</li><li>在当前读情况下，MySQL通过next-key来避免幻读</li></ul><h2 id="七、其他数据库日志"><a href="#七、其他数据库日志" class="headerlink" title="七、其他数据库日志"></a>七、其他数据库日志</h2><p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220310102215837.png" alt="image-20220310102215837"></p><p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220310102306361.png" alt="image-20220310102306361"></p><p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220310102419315.png" alt="image-20220310102419315"></p><p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220310102536683.png" alt="image-20220310102536683"></p><p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220310102703657.png" alt="image-20220310102703657"></p><p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220310102728587.png" alt="image-20220310102728587"></p><p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220310102925082.png" alt="image-20220310102925082"></p><p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220310102948906.png" alt="image-20220310102948906"></p><p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220310103009337.png" alt="image-20220310103009337"></p><p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220310103149506.png" alt="image-20220310103149506"></p><p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220310103212921.png" alt="image-20220310103212921"></p><p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220310103316794.png" alt="image-20220310103316794"></p><p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220310103432433.png" alt="image-20220310103432433"></p><p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220310103552939.png" alt="image-20220310103552939"></p><p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220310103705194.png" alt="image-20220310103705194"></p><p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220310103722010.png" alt="image-20220310103722010"></p><p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220310103920616.png" alt="image-20220310103920616"></p><p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220310105229287.png" alt="image-20220310105229287"></p><p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220310105453323.png" alt="image-20220310105453323"></p><p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220310105525884.png" alt="image-20220310105525884"></p><p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220310113738709.png" alt="image-20220310113738709"></p><p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220310113811435.png" alt="image-20220310113811435"></p><p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220310113932828.png" alt="image-20220310113932828"></p><p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220310114059444.png" alt="image-20220310114059444"></p><p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220310114232461.png" alt="image-20220310114232461"></p><p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220310114254582.png" alt="image-20220310114254582"></p><p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220310114345689.png" alt="image-20220310114345689"></p><p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220310114434806.png" alt="image-20220310114434806"></p><p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220310114645241.png" alt="image-20220310114645241"></p><p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220310114702706.png" alt="image-20220310114702706"></p><p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220310114757526.png" alt="image-20220310114757526"></p><p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220310114834825.png" alt="image-20220310114834825"></p><p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220310122435133.png" alt="image-20220310122435133"></p><p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220310122511422.png" alt="image-20220310122511422"></p><p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220310122641423.png" alt="image-20220310122641423"></p><p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220310122821774.png" alt="image-20220310122821774"></p><p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220310122901486.png" alt="image-20220310122901486"></p><p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220310123031374.png" alt="image-20220310123031374"></p><p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220310123147974.png" alt="image-20220310123147974"></p><p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220310123343953.png" alt="image-20220310123343953"></p><p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220310123517787.png" alt="image-20220310123517787"></p><p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220310123641580.png" alt="image-20220310123641580"></p><p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220310123722396.png" alt="image-20220310123722396"></p><p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220310123749112.png" alt="image-20220310123749112"></p><p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220310123823182.png" alt="image-20220310123823182"></p><p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220310124015603.png" alt="image-20220310124015603"></p><p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220310124036206.png" alt="image-20220310124036206"></p><p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220310124118133.png" alt="image-20220310124118133"></p><p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220310124216779.png" alt="image-20220310124216779"></p><p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220310124237194.png" alt="image-20220310124237194"></p><p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220310124300804.png" alt="image-20220310124300804"></p><p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220310124353744.png" alt="image-20220310124353744"></p><p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220310124503838.png" alt="image-20220310124503838"></p><p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220310124542493.png" alt="image-20220310124542493"></p><p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220310124838359.png" alt="image-20220310124838359"></p><p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220310125920672.png" alt="image-20220310125920672"></p><p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220310130111454.png" alt="image-20220310130111454"></p><h2 id="八、主从复制"><a href="#八、主从复制" class="headerlink" title="八、主从复制"></a>八、主从复制</h2><p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220310130524512.png" alt="image-20220310130524512"></p><p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220310131109367.png" alt="image-20220310131109367"></p><p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220310131647743.png" alt="image-20220310131647743"></p><p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220310131835593.png" alt="image-20220310131835593"></p><p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220310132409968.png" alt="image-20220310132409968"></p><p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220310132429660.png" alt="image-20220310132429660"></p><p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220310132504779.png" alt="image-20220310132504779"></p><p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220310132702320.png" alt="image-20220310132702320"></p><p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220310133022753.png" alt="image-20220310133022753"></p><h3 id="4-3如何减少主从延迟"><a href="#4-3如何减少主从延迟" class="headerlink" title="4.3如何减少主从延迟"></a>4.3如何减少主从延迟</h3><p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220310134014522.png" alt="image-20220310134014522"></p><p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220310134052880.png" alt="image-20220310134052880"></p><p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220310134157208.png" alt="image-20220310134157208"></p><p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220310134417926.png" alt="image-20220310134417926"></p><p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220310134549566.png" alt="image-20220310134549566"></p><p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220310134610253.png" alt="image-20220310134610253"></p><p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220310134642756.png" alt="image-20220310134642756"></p><h2 id="九、数据库备份"><a href="#九、数据库备份" class="headerlink" title="九、数据库备份"></a>九、数据库备份</h2><p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220310135055662.png" alt="image-20220310135055662"></p><p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220310135152003.png" alt="image-20220310135152003"></p><p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220310135325157.png" alt="image-20220310135325157"></p><p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220310135422641.png" alt="image-20220310135422641"></p><p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220310135451972.png" alt="image-20220310135451972"></p><p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220310135553045.png" alt="image-20220310135553045"></p><p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220310135655265.png" alt="image-20220310135655265"></p><p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220310135716727.png" alt="image-20220310135716727"></p><p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220310135819226.png" alt="image-20220310135819226"></p><p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220310135849437.png" alt="image-20220310135849437"></p><p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220310135952794.png" alt="image-20220310135952794"></p><p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220310140011041.png" alt="image-20220310140011041"></p><p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220310140058379.png" alt="image-20220310140058379"></p><p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220310140144108.png" alt="image-20220310140144108"></p><p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220310140311457.png" alt="image-20220310140311457"></p><p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220310140338451.png" alt="image-20220310140338451"></p><p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220310140410974.png" alt="image-20220310140410974"></p><p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220310140508008.png" alt="image-20220310140508008"></p><p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220310140545447.png" alt="image-20220310140545447"></p><p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220310140631579.png" alt="image-20220310140631579"></p><p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220310140707212.png" alt="image-20220310140707212"></p><p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220310140808086.png" alt="image-20220310140808086"></p><p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220310140825331.png" alt="image-20220310140825331"></p><p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220310140859356.png" alt="image-20220310140859356"></p><p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220310140956111.png" alt="image-20220310140956111"></p><p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220310141023978.png" alt="image-20220310141023978"></p><p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220310141157866.png" alt="image-20220310141157866"></p><p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220310141247257.png" alt="image-20220310141247257"></p><p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220310141435999.png" alt="image-20220310141435999"></p><p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220310141555735.png" alt="image-20220310141555735"></p><p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220310141745031.png" alt="image-20220310141745031"></p><p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220310141833972.png" alt="image-20220310141833972"></p><p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220310141923355.png" alt="image-20220310141923355"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Linuxlock</title>
      <link href="/2023/06/27/linuxlock/"/>
      <url>/2023/06/27/linuxlock/</url>
      
        <content type="html"><![CDATA[<h1 id="Linux中的各种锁及其基本原理"><a href="#Linux中的各种锁及其基本原理" class="headerlink" title="Linux中的各种锁及其基本原理"></a>Linux中的各种锁及其基本原理</h1><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h2><ul><li><p>Linux系统的并行特性</p></li><li><p>互斥和同步机制</p></li><li><p>Linux中常用锁的基本特征</p></li><li><p>互斥锁和条件变量</p></li></ul><h2 id="2-Linux的并行性特征"><a href="#2-Linux的并行性特征" class="headerlink" title="2.Linux的并行性特征"></a>2.Linux的并行性特征</h2><p>Linux作为典型的多用户、多任务、抢占式内核调度的操作系统，为了提高并行处理能力，无论在内核层面还是在用户层面都需要特殊的机制来确保任务的正确性和系统的稳定运行，就如同一个国家需要各种法律条款来约束每个公民的行为，才能有条不紊地运转。</p><p>在内核层面涉及到各种软硬件中断、进线程睡眠、抢占式内核调度、多处理器SMP架构等，因此内核在完成自己工作的时候一直在处理这些资源抢占的冲突问题。</p><p>在用户层面的进程，虽然Linux作为虚地址模式操作系统，为每个进程开辟了独立的虚拟地址空间，伪独占式拥有资源，但是仍然存在很多场景不得不产生多个进程共享资源的问题，来完成进程间的通信，但是在Go语言中进程间的通信使用消息来完成，处理地更优雅一些。</p><p>在线程层面，线程作为进程的一部分，进程内的多个线程只拥有自己的独立堆栈等少量结构，大部分的资源还是过线程共享，因此多线程的资源占用冲突比进程更加明显，所以多线程编程的线程安全问题是个重难点。综上可知，无论在kernel还是user space都必须有一些机制来确保对于资源共享问题的解决，然后这个机制就是接下来要说的：同步和互斥。</p><h2 id="3-同步和互斥机制"><a href="#3-同步和互斥机制" class="headerlink" title="3.同步和互斥机制"></a>3.同步和互斥机制</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>同步和互斥的概念有时候很容易混淆，可以简单地认为同步是更加宏观角度的一种说法，互斥是冲突解决的细节方法。所谓同步就是调度者让任务按照约定的合理的顺序进行，但是当任务之间出现资源竞争，也就是竞态冲突时，使用互斥的规则强制约束允许数量的任务占用资源，从而解决各个竞争状态，实现任务的合理运行。</p><p>简单来说:</p><ul><li>同步与互斥机制是用于控制多个任务对某些特定资源的访问策略</li><li>同步是控制多个任务按照一定的规则或顺序访问某些共享资源</li><li>互斥是控制某些共享资源在任意时刻只能允许规定数量的任务访问</li></ul><h3 id="角色分类"><a href="#角色分类" class="headerlink" title="角色分类"></a>角色分类</h3><p>整个协调流程涉及的角色本质上只有三类：</p><ul><li><p>不可独占的共享资源</p></li><li><p>多个使用者</p></li><li><p>调度者</p></li></ul><p>调度者需要为多个运行任务制定访问使用规则来实现稳定运行，这个调度者可以是内核、可以是应用程序，具体场景具体分析。</p><h3 id="重要术语"><a href="#重要术语" class="headerlink" title="重要术语"></a>重要术语</h3><p>要很好地理解同步和互斥，就必须得搞清楚几个重要术语：</p><h4 id="竞争冒险或竞态条件"><a href="#竞争冒险或竞态条件" class="headerlink" title="竞争冒险或竞态条件"></a>竞争冒险或竞态条件</h4><p>最早听说这个术语是在模电数电的课程上，门电路出现竞态条件造成错误的结果，在计算机里面就是多个使用者同时操作共享的变量造成结果的不确定。</p><h4 id="临界区"><a href="#临界区" class="headerlink" title="临界区"></a>临界区</h4><p>临界区域critical section是指多使用者可能同时共同操作的那部分代码，比如自加自减操作，多个线程处理时就需要对自加自减进行保护，这段代码就是临界区域。</p><h2 id="4-Linux中常用的锁"><a href="#4-Linux中常用的锁" class="headerlink" title="4.Linux中常用的锁"></a>4.Linux中常用的锁</h2><p>在说锁之前还需要知道几个东西:信号量和条件变量。这两个东西和锁有一定的联系和区别，在不同的场合单独使用或者配合实现来说实现安全的并发，至于网上很多说互斥锁是一种信号量的特例，对于这种特例理解不了也罢。信号量和互斥锁的场景不一样，信号量主要是资源数量的管理(池化)，实际用的频率远不如互斥锁，文字游戏着实无趣，实用主义至上，掌握高频工具的特点正确使用即可，大可不必过于学术派。在使用锁时需要明确几个问题：</p><ul><li><p>锁的所有权问题谁加锁 谁解锁 解铃还须系铃人</p></li><li><p>锁的作用就是对临界区资源的读写操作的安全限制</p></li><li><p>锁是否可以被多个使用者占用(互不影响的使用者对资源的占用)</p></li><li><p>占用资源的加锁者的释放问题 (锁持有的超时问题)</p></li><li><p>等待资源的待加锁者的等待问题(如何通知到其他等着资源的使用者)</p></li><li><p>多个临界区资源锁的循环问题(死锁场景)</p></li></ul><p>带着问题明确想要达到的目的，我们同样可以根据自己的需求设计锁，Linux现有的锁如果从上面几个问题的角度去理解，就非常容易了。</p><h3 id="自旋锁spinlock"><a href="#自旋锁spinlock" class="headerlink" title="自旋锁spinlock"></a>自旋锁spinlock</h3><p>自旋锁的主要特征是使用者在想要获得临界区执行权限时，如果临界区已经被加锁，那么自旋锁并不会阻塞睡眠，等待系统来主动唤醒，而是原地忙轮询资源是否被释放加锁，自旋就是自我旋转，这个名字还是很形象的。自旋锁有它的优点就是避免了系统的唤醒，自己来执行轮询，如果在临界区的资源代码非常短且是原子的，那么使用起来是非常方便的，避免了各种上下文切换，开销非常小，因此在内核的一些数据结构中自旋锁被广泛的使用。</p><h3 id="互斥锁mutex"><a href="#互斥锁mutex" class="headerlink" title="互斥锁mutex"></a>互斥锁mutex</h3><p>使用者使用互斥锁时在访问共享资源之前对进行加锁操作，在访问完成之后进行解锁操作，谁加锁谁释放，其他使用者没有释放权限。 加锁后，任何其他试图再次加锁的线程会被阻塞，直到当前进程解锁。 区别于自旋锁，互斥锁无法获取锁时将阻塞睡眠，需要系统来唤醒，可以看出来自旋转自己原地旋转来确定锁被释放了，互斥锁由系统来唤醒，但是现实并不是那么美好的，因为很多业务逻辑系统是不知道的，仍然需要业务线程执行while来轮询是否可以重新加锁。考虑这种情况：解锁时有多个线程阻塞，那么所有该锁上的线程都被编程就绪状态， 第一个变为就绪状态的线程又执行加锁操作，那么其他的线程又会进入等待，对其他线程而言就是虚假唤醒。 在这种方式下，只有一个线程能够访问被互斥锁保护的资源。</p><h3 id="读写锁rwlock"><a href="#读写锁rwlock" class="headerlink" title="读写锁rwlock"></a>读写锁rwlock</h3><p>读写锁也叫共享互斥锁：读模式共享和写模式互斥，本质上这种非常合理，因为在数据没有被写的前提下，多个使用者读取时完全不需要加锁的。读写锁有读加锁状态、写加锁状态和不加锁状态三种状态，当读写锁在写加锁模式下，任何试图对这个锁进行加锁的线程都会被阻塞，直到写进程对其解锁。</p><p><strong>读优先的读写锁</strong>：读写锁rwlock默认的也是读优先，也就是:当读写锁在读加锁模式先，任何线程都可以对其进行读加锁操作，但是所有试图进行写加锁操作的线程都会被阻塞，直到所有的读线程都解锁，因此读写锁很适合读次数远远大于写的情况。这种情况需要考虑写饥饿问题，也就是大量的读一直轮不到写，因此需要设置公平的读写策略。在一次面试中曾经问到实现一个写优先级的读写锁，感兴趣的可以想想如何实现。</p><h3 id="RCU锁"><a href="#RCU锁" class="headerlink" title="RCU锁"></a>RCU锁</h3><p>RCU锁是读写锁的扩展版本，简单来说就是支持多读多写同时加锁，多读没什么好说的，但是对于多写同时加锁，还是存在一些技术挑战的。RCU锁翻译为Read Copy Update Lock，读-拷贝-更新 锁。Copy拷贝：写者在访问临界区时，写者将先拷贝一个临界区副本，然后对副本进行修改；Update更新：RCU机制将在在适当时机使用一个回调函数把指向原来临界区的指针重新指向新的被修改的临界区，锁机制中的垃圾收集器负责回调函数的调用。更新时机：没有CPU再去操作这段被RCU保护的临界区后，这段临界区即可回收了，此时回调函数即被调用。从实现逻辑来看，RCU锁在多个写者之间的同步开销还是比较大的，涉及到多份数据拷贝，回调函数等，因此这种锁机制的使用范围比较窄，适用于读多写少的情况，如网络路由表的查询更新、设备状态表更新等，在业务开发中使用不是很多。</p><ul><li><strong>可重入锁和不可重入锁</strong></li><li>递归锁recursive mutex 可重入锁(reentrant mutex)</li><li>非递归锁non-recursive mutex 不可重入锁(non-reentrant mutex)</li></ul><p>Windows下的Mutex和Critical Section是可递归的。Linux下的pthread_mutex_t锁默认是非递归的。在Linux中可以显式设置PTHREAD_MUTEX_RECURSIVE属性，将pthread_mutex_t设为递归锁避免这种场景。 同一个线程可以多次获取同一个递归锁，不会产生死锁。而如果一个线程多次获取同一个非递归锁，则会产生死锁。</p><p>如下代码对于非递归锁的死锁示例：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">MutexLock mutex<span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">testa</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    mutex<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">do_sth</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    mutex<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">testb</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  mutex<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">testa</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  mutex<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>代码中testb使用了mutex并且调用testa，但是testa中也调用了相同的mutext，这种场景下如果mutex是非递归的就会出现死锁。</p><ul><li><strong>条件变量condition variables</strong></li></ul><p>条件变量是用来等待线程而不是上锁的，通常和互斥锁一起使用。互斥锁的一个明显的特点就是某些业务场景中无法借助系统来唤醒，仍然需要业务代码使用while来判断，这样效率本质上比较低。而条件变量通过允许线程阻塞和等待另一个线程发送信号来弥补互斥锁的不足，所以互斥锁和条件变量通常一起使用，来让条件变量异步唤醒阻塞的线程。</p><p>条件变量和互斥锁的典型使用就是生产者和消费者模型，这个模型非常经典，也在面试中经常被问到，示例代码：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;pthread.h&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">MAX</span> <span class="token expression"><span class="token number">5</span></span></span>pthread_mutex_t mutex <span class="token operator">=</span> PTHREAD_MUTEX_INITIALIZER<span class="token punctuation">;</span>pthread_cond_t notfull <span class="token operator">=</span> PTHREAD_COND_INITIALIZER<span class="token punctuation">;</span>  <span class="token comment">//是否队满</span>pthread_cond_t notempty <span class="token operator">=</span> PTHREAD_COND_INITIALIZER<span class="token punctuation">;</span> <span class="token comment">//是否队空</span><span class="token keyword">int</span> top <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">int</span> bottom <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">void</span><span class="token operator">*</span> <span class="token function">produce</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span> arg<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> i<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> MAX<span class="token operator">*</span><span class="token number">2</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token function">pthread_mutex_lock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>top<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">%</span>MAX <span class="token operator">==</span> bottom<span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"full! producer is waiting\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">//等待队不满</span>            <span class="token function">pthread_cond_wait</span><span class="token punctuation">(</span>notfull<span class="token punctuation">,</span> <span class="token operator">&amp;</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        top <span class="token operator">=</span> <span class="token punctuation">(</span>top<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">%</span> MAX<span class="token punctuation">;</span>        <span class="token comment">//发出队非空的消息</span>        <span class="token function">pthread_cond_signal</span><span class="token punctuation">(</span>notempty<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">pthread_mutex_unlock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">void</span><span class="token operator">*</span> <span class="token function">consume</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span> arg<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> i<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> MAX<span class="token operator">*</span><span class="token number">2</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token function">pthread_mutex_lock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span> top<span class="token operator">%</span>MAX <span class="token operator">==</span> bottom<span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"empty! consumer is waiting\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">//等待队不空</span>            <span class="token function">pthread_cond_wait</span><span class="token punctuation">(</span>notempty<span class="token punctuation">,</span> <span class="token operator">&amp;</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        bottom <span class="token operator">=</span> <span class="token punctuation">(</span>bottom<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">%</span> MAX<span class="token punctuation">;</span>        <span class="token comment">//发出队不满的消息</span>        <span class="token function">pthread_cond_signal</span><span class="token punctuation">(</span>notfull<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">pthread_mutex_unlock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token number">2</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span>argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    pthread_t thid1<span class="token punctuation">;</span>    pthread_t thid2<span class="token punctuation">;</span>    pthread_t thid3<span class="token punctuation">;</span>    pthread_t thid4<span class="token punctuation">;</span>    <span class="token keyword">int</span> ret1<span class="token punctuation">;</span>    <span class="token keyword">int</span> ret2<span class="token punctuation">;</span>    <span class="token keyword">int</span> ret3<span class="token punctuation">;</span>    <span class="token keyword">int</span> ret4<span class="token punctuation">;</span>    <span class="token function">pthread_create</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>thid1<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> produce<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">pthread_create</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>thid2<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> consume<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">pthread_create</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>thid3<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> produce<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">pthread_create</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>thid4<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> consume<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">pthread_join</span><span class="token punctuation">(</span>thid1<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>ret1<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">pthread_join</span><span class="token punctuation">(</span>thid2<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>ret2<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">pthread_join</span><span class="token punctuation">(</span>thid3<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>ret3<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">pthread_join</span><span class="token punctuation">(</span>thid4<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>ret4<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其中pthread_cond_wait的使用是个需要注意的地方:pthread_cond_wait()是先将互斥锁解开，并陷入阻塞，直到pthread_signal()发出信号后pthread_cond_wait()再加上锁，然后退出。</p><h1 id="自旋锁和互斥锁的区别"><a href="#自旋锁和互斥锁的区别" class="headerlink" title="自旋锁和互斥锁的区别"></a><a href="https://so.csdn.net/so/search?q=%E8%87%AA%E6%97%8B%E9%94%81&amp;spm=1001.2101.3001.7020">自旋锁</a>和互斥锁的区别</h1><p>POSIX threads(简称Pthreads)是在<a href="https://so.csdn.net/so/search?q=%E5%A4%9A%E6%A0%B8&amp;spm=1001.2101.3001.7020">多核</a>平台上进行并行编程的一套API。线程同步是并行编程中非常重要的通讯手段，其中最典型的应用就是用</p><p>Pthreads提供的<a href="https://so.csdn.net/so/search?q=%E9%94%81%E6%9C%BA%E5%88%B6&amp;spm=1001.2101.3001.7020">锁机制</a>(lock)来对多个线程之间的共享临界区(Critical Section)进行保护(另一种常用的同步机制是barrier)。</p><p>Pthreads提供了多种锁机制：</p><ul><li>Mutex(互斥量)：pthread_mutex_t</li><li>Spin lock(自旋锁): pthread_spin_t</li><li>Condition Variable(条件变量):&nbsp;pthread_cond_t</li><li>Read/Write lock(读写锁)：pthread_rwlock_t</li></ul><p>Pthreads提供的Mutex锁操作相关的<a href="https://so.csdn.net/so/search?q=API&amp;spm=1001.2101.3001.7020">API</a>主要有：</p><ul><li>pthread_mutex_lock(pthread_mutex_t *mutex);</li><li>pthread_mutex_trylock(pthread_mutex_t *mutex);</li><li>pthread_mutex_unlock(pthread_mutex_t *mutex);</li></ul><p>Pthreads提供的Spin Lock锁操作相关的API主要有：</p><ul><li>pthread_spin_lock(pthread_spinlock_t *lock);</li><li>pthread_spin_trylock(pthread_spinlock_t *lock);</li><li>pthread_spin_unlock(pthread_spinlock_t *lock);</li></ul><p>从实现原理上来讲，<strong>Mutex（互斥锁）属于sleep-waiting类型的锁</strong>。例如在一个双核的机器上有两个线程（线程A和线程B）,它们分别运行在Core0和Core1上。假设线程A想要通过pthread_mutex_lock操作去得到一个临界区的锁，而此时这个锁正被线程B所持有，那么线程A就会被阻塞，</p><p>Core0会在此时进行上下文切换(Context Switch)将线程A置于等待队列中，此时Core0就可以运行其它的任务而不必进行忙等待。而<strong>Spin lock（自旋锁）</strong>则不然，它属于<strong>busy-waiting类型的锁</strong>，如果线程A是使用pthread_spin_lock操作去请求锁，那么线程A就会一直在Core0上进行忙等待并不停的进行锁请求，直到得到这个锁为止。</p><p><strong>自旋锁（Spin lock）</strong></p><p>自旋锁与<a href="https://so.csdn.net/so/search?q=%E4%BA%92%E6%96%A5%E9%94%81&amp;spm=1001.2101.3001.7020">互斥锁</a>有点类似，只是自旋锁不会引起调用者睡眠，如果自旋锁已经被别的执行单元保持，调用者就一直循环在那里看是否该自旋锁的保持者已经释放了锁，<strong>“自旋锁”的作用是为了解决某项资源的互斥使用。因为自旋锁不会引起调用者睡眠，所以自旋锁的效率远高于互斥锁。</strong></p><p>自旋锁的不足之处：</p><p><strong>自旋锁一直占用着CPU，他在未获得锁的情况下，一直运行（自旋），所以占用着CPU，如果不能在很短的时间内获得锁，这无疑会使CPU效率降低。</strong></p><p>在用自旋锁时有可能造成死锁，当递归调用时有可能造成死锁，调用有些其他函数也可能造成死锁，如 copy_to_user()、copy_from_user()、kmalloc()等。</p><p>因此我们要慎重使用自旋锁，自旋锁只有在内核可抢占式或SMP的情况下才真正需要，在单CPU且不可抢占式的内核下，自旋锁的操作为空操作。自旋锁适用于锁使用者保持锁时间比较短的情况下。</p><h2 id="自旋锁-原理"><a href="#自旋锁-原理" class="headerlink" title="自旋锁-原理"></a>自旋锁-原理</h2><p>跟<a href="https://baike.so.com/doc/6150631-6363825.html">互斥锁</a>一样，一个执行单元要想访问被自旋锁保护的共享资源，必须<strong>先得到锁，在访问完共享资源后，必须释放锁</strong>。如果在获取自旋锁时，没有任何执行单元保持该锁，那么将立即得到锁;如果在获取自旋锁时锁已经有保持者，那么获取锁操作将自旋在那里，直到该自旋锁的保持者释放了锁。由此我们可以看出，自旋锁是一种比较低级的保护数据结构或代码片段的原始方式，这种锁可能存在两个问题:</p><p>1、<a href="https://baike.so.com/doc/414521-439063.html">死锁</a>。<strong>试图递归地获得自旋锁必然会引起死锁</strong>:递归程序的持有实例在第二个实例循环，以试图获得相同自旋锁时，不会释放此自旋锁。</p><p>在递归程序中使用自旋锁应遵守下列策略:</p><p>递归程序决不能在持有自旋锁时调用它自己，也决不能在<a href="https://baike.so.com/doc/6115126-6328268.html">递归调用</a>时试图获得相同的自旋锁。此外如果一个进程已经将资源锁定，那么，即使其它申请这个资源的进程不停地疯狂”自旋”,也无法获得资源，从而进入死循环。</p><p>2、过多占用cpu资源。如果不加限制，由于申请者一直在循环等待，因此自旋锁在锁定的时候,如果不成功,不会睡眠,会持续的尝试,单cpu的时候自旋锁会让其它process动不了. 因此，一般自旋锁实现会有一个参数限定最多持续尝试次数. 超出后, 自旋锁放弃当前time slice. 等下一次机会</p><p>由此可见，<strong>自旋锁</strong>比较<strong>适用于</strong>锁使用者<strong>保持锁时间比较短</strong>的情况。正是由于自旋锁使用者一般保持锁时间非常短，因此选择自旋而不是睡眠是非常必要的，自旋锁的效率远高于<a href="https://baike.so.com/doc/6150631-6363825.html">互斥锁</a>。<a href="https://baike.so.com/doc/6799211-7016022.html">信号量</a>和读写信号量适合于保持时间较长的情况，它们会导致调用者睡眠，因此只能在<a href="https://baike.so.com/doc/2315046-2448796.html">进程上下文</a>使用，而自旋锁适合于保持时间非常短的情况，它可以在任何上下文使用。如果被保护的共享资源只在进程上下文访问，使用信号量保护该共享资源非常合适，如果对共享资源的访问时间非常短，自旋锁也可以。但是如果被保护的共享资源需要在中断上下文访问(包括底半部即<a href="https://baike.so.com/doc/4973549-5196235.html">中断处理</a>句柄和顶半部即<a href="https://baike.so.com/doc/7715429-7989524.html">软中断</a>)，就必须使用自旋锁。<strong>自旋锁保持期间是抢占失效的，而信号量和读写信号量保持期间是可以被抢占的</strong>。自旋锁只有在<a href="https://baike.so.com/doc/665564-704577.html">内核</a>可抢占或<a href="https://baike.so.com/doc/4522250-4732301.html">SMP</a>(多处理器)的情况下才真正需要，在单CPU且不可抢占的内核下，自旋锁的所有操作都是空操作.</p><p><strong><strong>总结：</strong></strong></p><p><strong><strong>互斥锁与自旋锁的区别</strong></strong></p><p>(1)、互斥锁mutex：独占锁；开销大</p><p>pthread_mutex_lock(pthread_mutex_t *mutex);</p><p>pthread_mutex_unlock(pthread_mutex_t *mutex);</p><p>(2)、自旋锁spin lock：轻量级的锁，开销小；适用于短时间内对锁的使用。</p><p>如果自旋锁已经被其他的执行单元保持，调用者就一直循环在那里判断该自旋锁是否被释放</p><p>pthread_spin_lock(pthread_spinlock_t *lock);</p><p>pthread_spin_unlock(pthread_spinlock_t *lock);</p><p>注意：对于spin lock，如果递归调用过深，会导致死锁。</p>]]></content>
      
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>KMP</title>
      <link href="/2023/06/27/kmp/"/>
      <url>/2023/06/27/kmp/</url>
      
        <content type="html"><![CDATA[<h1 id="KMP"><a href="#KMP" class="headerlink" title="KMP"></a>KMP</h1><h1 id="什么是KMP"><a href="#什么是KMP" class="headerlink" title="什么是KMP"></a>什么是KMP</h1><p>说到KMP，先说一下KMP这个名字是怎么来的，为什么叫做KMP呢。</p><p>因为是由这三位学者发明的：Knuth，Morris和Pratt，所以取了三位学者名字的首字母。所以叫做KMP</p><h1 id="KMP有什么用"><a href="#KMP有什么用" class="headerlink" title="#KMP有什么用"></a><a href="https://www.programmercarl.com/0028.%E5%AE%9E%E7%8E%B0strStr.html#kmp%E6%9C%89%E4%BB%80%E4%B9%88%E7%94%A8">#</a>KMP有什么用</h1><p>KMP主要应用在字符串匹配上。</p><p>KMP的主要思想是<strong>当出现字符串不匹配时，可以知道一部分之前已经匹配的文本内容，可以利用这些信息避免从头再去做匹配了。</strong></p><p>所以如何记录已经匹配的文本内容，是KMP的重点，也是next数组肩负的重任。</p><p>其实KMP的代码不好理解，一些同学甚至直接把KMP代码的模板背下来。</p><p>没有彻底搞懂，懵懵懂懂就把代码背下来太容易忘了。</p><p>不仅面试的时候可能写不出来，如果面试官问：<strong>next数组里的数字表示的是什么，为什么这么表示？</strong></p><p>估计大多数候选人都是懵逼的。</p><p>下面Carl就带大家把KMP的精髓，next数组弄清楚。</p><h1 id="什么是前缀表"><a href="#什么是前缀表" class="headerlink" title="#什么是前缀表"></a><a href="https://www.programmercarl.com/0028.%E5%AE%9E%E7%8E%B0strStr.html#%E4%BB%80%E4%B9%88%E6%98%AF%E5%89%8D%E7%BC%80%E8%A1%A8">#</a>什么是前缀表</h1><p>写过KMP的同学，一定都写过next数组，那么这个next数组究竟是个啥呢？</p><p>next数组就是一个前缀表（prefix table）。</p><p>前缀表有什么作用呢？</p><p><strong>前缀表是用来回退的，它记录了模式串与主串(文本串)不匹配的时候，模式串应该从哪里开始重新匹配。</strong></p><p>为了清楚的了解前缀表的来历，我们来举一个例子：</p><p>要在文本串：aabaabaafa 中查找是否出现过一个模式串：aabaaf。</p><p>请记住文本串和模式串的作用，对于理解下文很重要，要不然容易看懵。所以说三遍：</p><p>要在文本串：aabaabaafa 中查找是否出现过一个模式串：aabaaf。</p><p>要在文本串：aabaabaafa 中查找是否出现过一个模式串：aabaaf。</p><p>要在文本串：aabaabaafa 中查找是否出现过一个模式串：aabaaf。</p><p>如动画所示：</p><p><img src="https://code-thinking.cdn.bcebos.com/gifs/KMP%E7%B2%BE%E8%AE%B21.gif" alt="KMP详解1"></p><p>动画里，我特意把 子串<code>aa</code> 标记上了，这是有原因的，大家先注意一下，后面还会说道。</p><p>可以看出，文本串中第六个字符b 和 模式串的第六个字符f，不匹配了。如果暴力匹配，会发现不匹配，此时就要从头匹配了。</p><p>但如果使用前缀表，就不会从头匹配，而是从上次已经匹配的内容开始匹配，找到了模式串中第三个字符b继续开始匹配。</p><p>此时就要问了<strong>前缀表是如何记录的呢？</strong></p><p>首先要知道前缀表的任务是当前位置匹配失败，找到之前已经匹配上的位置，再重新匹配，此也意味着在某个字符失配时，前缀表会告诉你下一步匹配中，模式串应该跳到哪个位置。</p><p>那么什么是前缀表：<strong>记录下标i之前（包括i）的字符串中，有多大长度的相同前缀后缀。</strong></p><h1 id="最长公共前后缀？"><a href="#最长公共前后缀？" class="headerlink" title="#最长公共前后缀？"></a><a href="https://www.programmercarl.com/0028.%E5%AE%9E%E7%8E%B0strStr.html#%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%89%8D%E5%90%8E%E7%BC%80">#</a>最长公共前后缀？</h1><p>文章中字符串的<strong>前缀是指不包含最后一个字符的所有以第一个字符开头的连续子串</strong>。</p><p><strong>后缀是指不包含第一个字符的所有以最后一个字符结尾的连续子串</strong>。</p><p><strong>正确理解什么是前缀什么是后缀很重要</strong>!</p><p>那么网上清一色都说 “kmp 最长公共前后缀” 又是什么回事呢？</p><p>我查了一遍 算法导论 和 算法4里KMP的章节，都没有提到 “最长公共前后缀”这个词，也不知道从哪里来了，我理解是用“最长相等前后缀” 更准确一些。</p><p><strong>因为前缀表要求的就是相同前后缀的长度。</strong></p><p>而最长公共前后缀里面的“公共”，更像是说前缀和后缀公共的长度。这其实并不是前缀表所需要的。</p><p>所以字符串a的最长相等前后缀为0。 字符串aa的最长相等前后缀为1。 字符串aaa的最长相等前后缀为2。 等等…..。</p><h1 id="为什么一定要用前缀表"><a href="#为什么一定要用前缀表" class="headerlink" title="#为什么一定要用前缀表"></a><a href="https://www.programmercarl.com/0028.%E5%AE%9E%E7%8E%B0strStr.html#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%80%E5%AE%9A%E8%A6%81%E7%94%A8%E5%89%8D%E7%BC%80%E8%A1%A8">#</a>为什么一定要用前缀表</h1><p>这就是前缀表，那为啥就能告诉我们 上次匹配的位置，并跳过去呢？</p><p>回顾一下，刚刚匹配的过程在下标5的地方遇到不匹配，模式串是指向f，如图： <img src="https://code-thinking.cdn.bcebos.com/pics/KMP%E7%B2%BE%E8%AE%B21.png" alt="KMP精讲1"></p><p>然后就找到了下标2，指向b，继续匹配：如图： <img src="https://code-thinking.cdn.bcebos.com/pics/KMP%E7%B2%BE%E8%AE%B22.png" alt="KMP精讲2"></p><p>以下这句话，对于理解为什么使用前缀表可以告诉我们匹配失败之后跳到哪里重新匹配 非常重要！</p><p><strong>下标5之前这部分的字符串（也就是字符串aabaa）的最长相等的前缀 和 后缀字符串是 子字符串aa ，因为找到了最长相等的前缀和后缀，匹配失败的位置是后缀子串的后面，那么我们找到与其相同的前缀的后面从新匹配就可以了。</strong></p><p>所以前缀表具有告诉我们当前位置匹配失败，跳到之前已经匹配过的地方的能力。</p><p><strong>很多介绍KMP的文章或者视频并没有把为什么要用前缀表？这个问题说清楚，而是直接默认使用前缀表。</strong></p><h1 id="如何计算前缀表"><a href="#如何计算前缀表" class="headerlink" title="#如何计算前缀表"></a><a href="https://www.programmercarl.com/0028.%E5%AE%9E%E7%8E%B0strStr.html#%E5%A6%82%E4%BD%95%E8%AE%A1%E7%AE%97%E5%89%8D%E7%BC%80%E8%A1%A8">#</a>如何计算前缀表</h1><p>接下来就要说一说怎么计算前缀表。</p><p>如图：</p><p><img src="https://code-thinking.cdn.bcebos.com/pics/KMP%E7%B2%BE%E8%AE%B25.png" alt="KMP精讲5"></p><p>长度为前1个字符的子串<code>a</code>，最长相同前后缀的长度为0。（注意字符串的<strong>前缀是指不包含最后一个字符的所有以第一个字符开头的连续子串</strong>；<strong>后缀是指不包含第一个字符的所有以最后一个字符结尾的连续子串</strong>。）</p><p><img src="https://code-thinking.cdn.bcebos.com/pics/KMP%E7%B2%BE%E8%AE%B26.png" alt="KMP精讲6"> 长度为前2个字符的子串<code>aa</code>，最长相同前后缀的长度为1。</p><p><img src="https://code-thinking.cdn.bcebos.com/pics/KMP%E7%B2%BE%E8%AE%B27.png" alt="KMP精讲7"> 长度为前3个字符的子串<code>aab</code>，最长相同前后缀的长度为0。</p><p>以此类推： 长度为前4个字符的子串<code>aaba</code>，最长相同前后缀的长度为1。 长度为前5个字符的子串<code>aabaa</code>，最长相同前后缀的长度为2。 长度为前6个字符的子串<code>aabaaf</code>，最长相同前后缀的长度为0。</p><p>那么把求得的最长相同前后缀的长度就是对应前缀表的元素，如图： <img src="https://code-thinking.cdn.bcebos.com/pics/KMP%E7%B2%BE%E8%AE%B28.png" alt="KMP精讲8"></p><p>可以看出模式串与前缀表对应位置的数字表示的就是：<strong>下标i之前（包括i）的字符串中，有多大长度的相同前缀后缀。</strong></p><p>再来看一下如何利用 前缀表找到 当字符不匹配的时候应该指针应该移动的位置。如动画所示：</p><p><img src="https://code-thinking.cdn.bcebos.com/gifs/KMP%E7%B2%BE%E8%AE%B22.gif" alt="KMP精讲2"></p><p>找到的不匹配的位置， 那么此时我们要看它的前一个字符的前缀表的数值是多少。</p><p>为什么要前一个字符的前缀表的数值呢，因为要找前面字符串的最长相同的前缀和后缀。</p><p>所以要看前一位的 前缀表的数值。</p><p>前一个字符的前缀表的数值是2， 所有把下标移动到下标2的位置继续比配。 可以再反复看一下上面的动画。</p><p>最后就在文本串中找到了和模式串匹配的子串了。</p><h1 id="前缀表与next数组"><a href="#前缀表与next数组" class="headerlink" title="#前缀表与next数组"></a><a href="https://www.programmercarl.com/0028.%E5%AE%9E%E7%8E%B0strStr.html#%E5%89%8D%E7%BC%80%E8%A1%A8%E4%B8%8Enext%E6%95%B0%E7%BB%84">#</a>前缀表与next数组</h1><p>很多KMP算法的时间都是使用next数组来做回退操作，那么next数组与前缀表有什么关系呢？</p><p>next数组就可以是前缀表，但是很多实现都是把前缀表统一减一（右移一位，初始位置为-1）之后作为next数组。</p><p>为什么这么做呢，其实也是很多文章视频没有解释清楚的地方。</p><p>其实<strong>这并不涉及到KMP的原理，而是具体实现，next数组即可以就是前缀表，也可以是前缀表统一减一（右移一位，初始位置为-1）。</strong></p><p>后面我会提供两种不同的实现代码，大家就明白了。</p><h1 id="使用next数组来匹配"><a href="#使用next数组来匹配" class="headerlink" title="#使用next数组来匹配"></a><a href="https://www.programmercarl.com/0028.%E5%AE%9E%E7%8E%B0strStr.html#%E4%BD%BF%E7%94%A8next%E6%95%B0%E7%BB%84%E6%9D%A5%E5%8C%B9%E9%85%8D">#</a>使用next数组来匹配</h1><p><strong>以下我们以前缀表统一减一之后的next数组来做演示</strong>。</p><p>有了next数组，就可以根据next数组来 匹配文本串s，和模式串t了。</p><p>注意next数组是新前缀表（旧前缀表统一减一了）。</p><p>匹配过程动画如下：</p><p><img src="https://code-thinking.cdn.bcebos.com/gifs/KMP%E7%B2%BE%E8%AE%B24.gif" alt="KMP精讲4"></p><h1 id="时间复杂度分析"><a href="#时间复杂度分析" class="headerlink" title="#时间复杂度分析"></a><a href="https://www.programmercarl.com/0028.%E5%AE%9E%E7%8E%B0strStr.html#%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90">#</a>时间复杂度分析</h1><p>其中n为文本串长度，m为模式串长度，因为在匹配的过程中，根据前缀表不断调整匹配的位置，可以看出匹配的过程是$O(n)$，之前还要单独生成next数组，时间复杂度是$O(m)$。所以整个KMP算法的时间复杂度是$O(n+m)$的。</p><p>暴力的解法显而易见是$O(n × m)$，所以<strong>KMP在字符串匹配中极大的提高的搜索的效率。</strong></p><p>为了和力扣题目28.实现strStr保持一致，方便大家理解，以下文章统称haystack为文本串, needle为模式串。</p><p>都知道使用KMP算法，一定要构造next数组。</p><h1 id="构造next数组"><a href="#构造next数组" class="headerlink" title="#构造next数组"></a><a href="https://www.programmercarl.com/0028.%E5%AE%9E%E7%8E%B0strStr.html#%E6%9E%84%E9%80%A0next%E6%95%B0%E7%BB%84">#</a>构造next数组</h1><p>我们定义一个函数getNext来构建next数组，函数参数为指向next数组的指针，和一个字符串。 代码如下：</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">void getNext(int* next, const string&amp; s)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>构造next数组其实就是计算模式串s，前缀表的过程。</strong> 主要有如下三步：</p><ol><li>初始化</li><li>处理前后缀不相同的情况</li><li>处理前后缀相同的情况</li></ol><p>接下来我们详解详解一下。</p><ol><li>初始化：</li></ol><p>定义两个指针i和j，j指向前缀起始位置，i指向后缀起始位置。</p><p>然后还要对next数组进行初始化赋值，如下：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>next<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> j<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>j 为什么要初始化为 -1呢，因为之前说过 前缀表要统一减一的操作仅仅是其中的一种实现，我们这里选择j初始化为-1，下文我还会给出j不初始化为-1的实现代码。</p><p>next[i] 表示 i（包括i）之前最长相等的前后缀长度（其实就是j）</p><p>所以初始化next[0] = j 。</p><ol><li>处理前后缀不相同的情况</li></ol><p>因为j初始化为-1，那么i就从1开始，进行s[i] 与 s[j+1]的比较。</p><p>所以遍历模式串s的循环下标i 要从 1开始，代码如下：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> s<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果 s[i] 与 s[j+1]不相同，也就是遇到 前后缀末尾不相同的情况，就要向前回退。</p><p>怎么回退呢？</p><p>next[j]就是记录着j（包括j）之前的子串的相同前后缀的长度。</p><p>那么 s[i] 与 s[j+1] 不相同，就要找 j+1前一个元素在next数组里的值（就是next[j]）。</p><p>所以，处理前后缀不相同的情况代码如下：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">while</span> <span class="token punctuation">(</span>j <span class="token operator">&gt;=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> s<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> s<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 前后缀不相同了</span>    j <span class="token operator">=</span> next<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 向前回退</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ol><li>处理前后缀相同的情况</li></ol><p>如果 s[i] 与 s[j + 1] 相同，那么就同时向后移动i 和j 说明找到了相同的前后缀，同时还要将j（前缀的长度）赋给next[i], 因为next[i]要记录相同前后缀的长度。</p><p>代码如下：</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">if (s[i] == s[j + 1]) { // 找到相同的前后缀    j++;}next[i] = j;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>最后整体构建next数组的函数代码如下：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">getNext</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span> next<span class="token punctuation">,</span> <span class="token keyword">const</span> string<span class="token operator">&amp;</span> s<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    next<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> j<span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> s<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 注意i从1开始</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>j <span class="token operator">&gt;=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> s<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> s<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 前后缀不相同了</span>            j <span class="token operator">=</span> next<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 向前回退</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> s<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 找到相同的前后缀</span>            j<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        next<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> j<span class="token punctuation">;</span> <span class="token comment">// 将j（前缀的长度）赋给next[i]</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>代码构造next数组的逻辑流程动画如下：</p><p><img src="https://code-thinking.cdn.bcebos.com/gifs/KMP%E7%B2%BE%E8%AE%B23.gif" alt="KMP精讲3"></p><p>得到了next数组之后，就要用这个来做匹配了。</p><h1 id="使用next数组来做匹配"><a href="#使用next数组来做匹配" class="headerlink" title="#使用next数组来做匹配"></a><a href="https://www.programmercarl.com/0028.%E5%AE%9E%E7%8E%B0strStr.html#%E4%BD%BF%E7%94%A8next%E6%95%B0%E7%BB%84%E6%9D%A5%E5%81%9A%E5%8C%B9%E9%85%8D">#</a>使用next数组来做匹配</h1><p>在文本串s里 找是否出现过模式串t。</p><p>定义两个下标j 指向模式串起始位置，i指向文本串起始位置。</p><p>那么j初始值依然为-1，为什么呢？ <strong>依然因为next数组里记录的起始位置为-1。</strong></p><p>i就从0开始，遍历文本串，代码如下：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> s<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>接下来就是 s[i] 与 t[j + 1] （因为j从-1开始的） 进行比较。</p><p>如果 s[i] 与 t[j + 1] 不相同，j就要从next数组里寻找下一个匹配的位置。</p><p>代码如下：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">while</span><span class="token punctuation">(</span>j <span class="token operator">&gt;=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> s<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> t<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    j <span class="token operator">=</span> next<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>如果 s[i] 与 t[j + 1] 相同，那么i 和 j 同时向后移动， 代码如下：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">if</span> <span class="token punctuation">(</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> t<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    j<span class="token operator">++</span><span class="token punctuation">;</span> <span class="token comment">// i的增加在for循环里</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>如何判断在文本串s里出现了模式串t呢，如果j指向了模式串t的末尾，那么就说明模式串t完全匹配文本串s里的某个子串了。</p><p>本题要在文本串字符串中找出模式串出现的第一个位置 (从0开始)，所以返回当前在文本串匹配模式串的位置i 减去 模式串的长度，就是文本串字符串中出现模式串的第一个位置。</p><p>代码如下：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">if</span> <span class="token punctuation">(</span>j <span class="token operator">==</span> <span class="token punctuation">(</span>t<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span>i <span class="token operator">-</span> t<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>那么使用next数组，用模式串匹配文本串的整体代码如下：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// 因为next数组里记录的起始位置为-1</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> s<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 注意i就从0开始</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>j <span class="token operator">&gt;=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> s<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> t<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 不匹配</span>        j <span class="token operator">=</span> next<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// j 寻找之前匹配的位置</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> t<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 匹配，j和i同时向后移动</span>        j<span class="token operator">++</span><span class="token punctuation">;</span> <span class="token comment">// i的增加在for循环里</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>j <span class="token operator">==</span> <span class="token punctuation">(</span>t<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 文本串s里出现了模式串t</span>        <span class="token keyword">return</span> <span class="token punctuation">(</span>i <span class="token operator">-</span> t<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>此时所有逻辑的代码都已经写出来了，力扣 28.实现strStr 题目的整体代码如下：</p><h1 id="前缀表统一减一-C-代码实现"><a href="#前缀表统一减一-C-代码实现" class="headerlink" title="#前缀表统一减一 C++代码实现"></a><a href="https://www.programmercarl.com/0028.%E5%AE%9E%E7%8E%B0strStr.html#%E5%89%8D%E7%BC%80%E8%A1%A8%E7%BB%9F%E4%B8%80%E5%87%8F%E4%B8%80-c-%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0">#</a>前缀表统一减一 C++代码实现</h1><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">void</span> <span class="token function">getNext</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span> next<span class="token punctuation">,</span> <span class="token keyword">const</span> string<span class="token operator">&amp;</span> s<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>        next<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> j<span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> s<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 注意i从1开始</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span>j <span class="token operator">&gt;=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> s<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> s<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 前后缀不相同了</span>                j <span class="token operator">=</span> next<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 向前回退</span>            <span class="token punctuation">}</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> s<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 找到相同的前后缀</span>                j<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            next<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> j<span class="token punctuation">;</span> <span class="token comment">// 将j（前缀的长度）赋给next[i]</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">int</span> <span class="token function">strStr</span><span class="token punctuation">(</span>string haystack<span class="token punctuation">,</span> string needle<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>needle<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">int</span> next<span class="token punctuation">[</span>needle<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token function">getNext</span><span class="token punctuation">(</span>next<span class="token punctuation">,</span> needle<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// // 因为next数组里记录的起始位置为-1</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> haystack<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 注意i就从0开始</span>            <span class="token keyword">while</span><span class="token punctuation">(</span>j <span class="token operator">&gt;=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> haystack<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> needle<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 不匹配</span>                j <span class="token operator">=</span> next<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// j 寻找之前匹配的位置</span>            <span class="token punctuation">}</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>haystack<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> needle<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 匹配，j和i同时向后移动</span>                j<span class="token operator">++</span><span class="token punctuation">;</span> <span class="token comment">// i的增加在for循环里</span>            <span class="token punctuation">}</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>j <span class="token operator">==</span> <span class="token punctuation">(</span>needle<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 文本串s里出现了模式串t</span>                <span class="token keyword">return</span> <span class="token punctuation">(</span>i <span class="token operator">-</span> needle<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="前缀表（不减一）C-实现"><a href="#前缀表（不减一）C-实现" class="headerlink" title="#前缀表（不减一）C++实现"></a><a href="https://www.programmercarl.com/0028.%E5%AE%9E%E7%8E%B0strStr.html#%E5%89%8D%E7%BC%80%E8%A1%A8-%E4%B8%8D%E5%87%8F%E4%B8%80-c-%E5%AE%9E%E7%8E%B0">#</a>前缀表（不减一）C++实现</h1><p>那么前缀表就不减一了，也不右移的，到底行不行呢？</p><p><strong>行！</strong></p><p>我之前说过，这仅仅是KMP算法实现上的问题，如果就直接使用前缀表可以换一种回退方式，找j=next[j-1] 来进行回退。</p><p>主要就是j=next[x]这一步最为关键！</p><p>我给出的getNext的实现为：（前缀表统一减一）</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">getNext</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span> next<span class="token punctuation">,</span> <span class="token keyword">const</span> string<span class="token operator">&amp;</span> s<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    next<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> j<span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> s<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 注意i从1开始</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>j <span class="token operator">&gt;=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> s<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> s<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 前后缀不相同了</span>            j <span class="token operator">=</span> next<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 向前回退</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> s<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 找到相同的前后缀</span>            j<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        next<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> j<span class="token punctuation">;</span> <span class="token comment">// 将j（前缀的长度）赋给next[i]</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>此时如果输入的模式串为aabaaf，对应的next为-1 0 -1 0 1 -1。</p><p>这里j和next[0]初始化为-1，整个next数组是以 前缀表减一之后的效果来构建的。</p><p>那么前缀表不减一来构建next数组，代码如下：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">getNext</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span> next<span class="token punctuation">,</span> <span class="token keyword">const</span> string<span class="token operator">&amp;</span> s<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    next<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> s<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>j <span class="token operator">&gt;</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> s<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> s<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// j要保证大于0，因为下面有取j-1作为数组下标的操作</span>            j <span class="token operator">=</span> next<span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 注意这里，是要找前一位的对应的回退位置了</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> s<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            j<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        next<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> j<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>此时如果输入的模式串为aabaaf，对应的next为 0 1 0 1 2 0，（其实这就是前缀表的数值了）。</p><p>那么用这样的next数组也可以用来做匹配，代码要有所改动。</p><p>实现代码如下：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">void</span> <span class="token function">getNext</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span> next<span class="token punctuation">,</span> <span class="token keyword">const</span> string<span class="token operator">&amp;</span> s<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        next<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> s<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span>j <span class="token operator">&gt;</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> s<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> s<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                j <span class="token operator">=</span> next<span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> s<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                j<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            next<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> j<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">int</span> <span class="token function">strStr</span><span class="token punctuation">(</span>string haystack<span class="token punctuation">,</span> string needle<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>needle<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">int</span> next<span class="token punctuation">[</span>needle<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token function">getNext</span><span class="token punctuation">(</span>next<span class="token punctuation">,</span> needle<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> haystack<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">while</span><span class="token punctuation">(</span>j <span class="token operator">&gt;</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> haystack<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> needle<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                j <span class="token operator">=</span> next<span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>haystack<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> needle<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                j<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>j <span class="token operator">==</span> needle<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">return</span> <span class="token punctuation">(</span>i <span class="token operator">-</span> needle<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IOmultiplexing</title>
      <link href="/2023/06/27/iomultiplexing/"/>
      <url>/2023/06/27/iomultiplexing/</url>
      
        <content type="html"><![CDATA[<h1 id="IO多路复用"><a href="#IO多路复用" class="headerlink" title="IO多路复用"></a>IO多路复用</h1><p>I/O多路复用就是通过一种机制，一个进程可以监视多个描述符，一旦某个描述符就绪（一般是读就绪或者写就绪），能够通知程序进行相应的读写操作。但select，poll，epoll本质上都是同步I/O，因为他们都需要在读写事件就绪后自己负责进行读写，也就是说这个读写过程是阻塞的，而异步I/O则无需自己负责进行读写，异步I/O的实现会负责把数据从内核拷贝到用户空间。</p><h2 id="1-select"><a href="#1-select" class="headerlink" title="1.select"></a>1.select</h2><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">select</span> <span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">,</span> fd_set <span class="token operator">*</span>readfds<span class="token punctuation">,</span> fd_set <span class="token operator">*</span>writefds<span class="token punctuation">,</span> fd_set <span class="token operator">*</span>exceptfds<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">timeval</span> <span class="token operator">*</span>timeout<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>Linux中基于socket的通信本质也是一种I/O，使用socket()函数创建的套接字默认都是阻塞的，这意味着当sockets API的调用不能立即完成时，线程一直处于等待状态，直到操作完成获得结果或者超时出错。会引起阻塞的socket API分为以下四种：</p><ul><li>输入操作： recv()、recvfrom()。以阻塞套接字为参数调用该函数接收数据时，如果套接字缓冲区内没有数据可读，则调用线程在数据到来前一直睡眠。</li><li>输出操作： send()、sendto()。以阻塞套接字为参数调用该函数发送数据时，如果套接字缓冲区没有可用空间，线程会一直睡眠，直到有空间。</li><li>接受连接：accept()。以阻塞套接字为参数调用该函数， 。如果此时没有连接请求，线程就会进入睡眠状态。</li><li>外出连接：connect()。对于TCP连接，客户端以阻塞套接字为参数，调用该函数向服务器发起连接。该函数在收到服务器的应答前，不会返回。这意味着TCP连接总会等待至少服务器的一次往返时间。</li></ul><p>使用阻塞模式的套接字编写网络程序比较简单，容易实现。但是在服务器端，通常要处理大量的套接字通信请求，如果线程阻塞于上述的某一个输入或输出调用时，将无法处理其他任何运算或响应其他网络请求，这么做无疑是十分低效的，当然可以采用多线程，但大量的线程占用很大的内存空间，并且线程切换会带来很大的开销。而I/O多路复用模型能处理多个connection的优点就使其<strong>能支持更多的并发连接请求</strong>。</p><p>Linux支持I/O多路复用的系统调用有select、poll、epoll，这些调用都是内核级别的。但select、poll、epoll本质上都是同步I/O，先是block住等待就绪的socket，再block住将数据从内核拷贝到用户内存空间。基于select调用的I/O复用模型如下：</p><p><img src="https://pic3.zhimg.com/80/v2-bae9d6368b741d17e09c791a664a43ba_1440w.jpg" alt="img"></p><p>select，poll，epoll之间的区别如下图：</p><p><img src="https://pic1.zhimg.com/80/v2-e6a869884585625dfc7eace1b90c3024_1440w.png" alt="img"></p><p>Linux提供的select相关函数接口如下：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/select.h&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/time.h&gt;</span></span><span class="token keyword">int</span> <span class="token function">select</span><span class="token punctuation">(</span>    <span class="token keyword">int</span> nfds<span class="token punctuation">,</span>    fd_set <span class="token operator">*</span>readfds<span class="token punctuation">,</span>    fd_set <span class="token operator">*</span>writefds<span class="token punctuation">,</span>    fd_set <span class="token operator">*</span>exceptfds<span class="token punctuation">,</span>    <span class="token keyword">struct</span> <span class="token class-name">timeval</span> <span class="token operator">*</span>timeout<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">FD_ZERO</span><span class="token punctuation">(</span><span class="token keyword">int</span> fd<span class="token punctuation">,</span> fd_set<span class="token operator">*</span> fds<span class="token punctuation">)</span>   <span class="token comment">//清空集合</span><span class="token function">FD_SET</span><span class="token punctuation">(</span><span class="token keyword">int</span> fd<span class="token punctuation">,</span> fd_set<span class="token operator">*</span> fds<span class="token punctuation">)</span>    <span class="token comment">//将给定的描述符加入集合</span><span class="token function">FD_ISSET</span><span class="token punctuation">(</span><span class="token keyword">int</span> fd<span class="token punctuation">,</span> fd_set<span class="token operator">*</span> fds<span class="token punctuation">)</span>  <span class="token comment">//将给定的描述符从文件中删除  </span><span class="token function">FD_CLR</span><span class="token punctuation">(</span><span class="token keyword">int</span> fd<span class="token punctuation">,</span> fd_set<span class="token operator">*</span> fds<span class="token punctuation">)</span>    <span class="token comment">//判断指定描述符是否在集合中</span><span class="token comment">// nfds:监控的文件描述符集里最大文件描述符加1</span><span class="token comment">// readfds：监控有读数据到达文件描述符集合，传入传出参数</span><span class="token comment">// writefds：监控写数据到达文件描述符集合，传入传出参数</span><span class="token comment">// exceptfds：监控异常发生达文件描述符集合, 传入传出参数</span><span class="token comment">// timeout：定时阻塞监控时间，3种情况</span><span class="token comment">//  1.NULL，永远等下去</span><span class="token comment">//  2.设置timeval，等待固定时间</span><span class="token comment">//  3.设置timeval里时间均为0，检查描述字后立即返回，轮询</span>select服务端伪码<span class="token comment">//首先一个线程不断接受客户端连接，并把socket文件描述符放到一个list里。</span><span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  connfd <span class="token operator">=</span> <span class="token function">accept</span><span class="token punctuation">(</span>listenfd<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">fcntl</span><span class="token punctuation">(</span>connfd<span class="token punctuation">,</span> F_SETFL<span class="token punctuation">,</span> O_NONBLOCK<span class="token punctuation">)</span><span class="token punctuation">;</span>  fdlist<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>connfd<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>select函数还是返回刚刚提交的list，应用程序依然list所有的fd，只不过操作系统会将准备就绪的文件描述符做上标识，用户层将不会再有无意义的系统调用开销。<span class="token keyword">struct</span> <span class="token class-name">timeval</span> timeout<span class="token punctuation">;</span><span class="token keyword">int</span> max <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token comment">// 用于记录最大的fd，在轮询中时刻更新即可</span><span class="token comment">// 初始化比特位</span><span class="token function">FD_ZERO</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>read_fd<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment">// 阻塞获取 每次需要把fd从用户态拷贝到内核态</span>    nfds <span class="token operator">=</span> <span class="token function">select</span><span class="token punctuation">(</span>max <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>read_fd<span class="token punctuation">,</span> <span class="token operator">&amp;</span>write_fd<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>timeout<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 每次需要遍历所有fd，判断有无读写事件发生</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> max <span class="token operator">&amp;&amp;</span> nfds<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">// 只读已就绪的文件描述符，不用过多遍历</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">==</span> listenfd<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment">// 这里处理accept事件</span>            <span class="token function">FD_SET</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> <span class="token operator">&amp;</span>read_fd<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//将客户端socket加入到集合中</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">FD_ISSET</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> <span class="token operator">&amp;</span>read_fd<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment">// 这里处理read事件</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol><li>select函数的返回值就绪描述符的数目，超时时返回0，出错返回-1。</li><li>第一个参数nfds指待测试的fd个数，它的值是待测试的最大文件描述符加1，文件描述符从0开始到nfds-1都将被测试。</li><li>中间三个参数readfds、writefds和exceptfds指定要让内核测试<strong>读、写</strong>和<strong>异常</strong>条件的fd集合，如果不需要测试的可以设置为NULL。</li></ol><p>基于select的I/O复用模型的是单进程执行，占用资源少，可以为多个客户端服务。但是select需要轮询每一个描述符，在高并发时仍然会存在效率问题，同时select能支持的最大连接数通常受限。</p><p>select 函数监视的文件描述符分3类，分别是writefds、readfds、和exceptfds，当用户process调用select的时候，select会将需要监控的readfds集合拷贝到内核空间（假设监控的仅仅是socket可读），然后遍历自己监控的socket sk，挨个调用sk的poll逻辑以便检查该sk是否有可读事件，遍历完所有的sk后，如果没有任何一个sk可读，那么select会调用schedule_timeout进入schedule循环，使得process进入睡眠。如果在timeout时间内某个sk上有数据可读了，或者等待timeout了，则调用select的process会被唤醒，接下来select就是遍历监控的sk集合，挨个收集可读事件并返回给用户了.</p><p>通过上面的select逻辑过程分析，相信大家都意识到，select存在三个问题：</p><p>[1] 每次调用select，都需要把被监控的fds集合从用户态空间拷贝到内核态空间，高并发场景下这样的拷贝会使得消耗的资源是很大的。<br>[2] 能监听端口的数量有限，单个进程所能打开的最大连接数有FD_SETSIZE宏定义，其大小是32个整数的大小（在32位的机器上，大小就是3232，同理64位机器上为3264），当然我们可以对宏FD_SETSIZE进行修改，然后重新编译内核，但是性能可能会受到影响，一般该数和系统内存关系很大，具体数目可以<code>cat /proc/sys/fs/file-max</code>察看。32位机默认1024个，64位默认2048。</p><p>[3] 被监控的fds集合中，只要有一个有数据可读，整个socket集合就会被遍历一次调用sk的poll函数收集可读事件：由于当初的需求是朴素，仅仅关心是否有数据可读这样一个事件，当事件通知来的时候，由于数据的到来是异步的，我们不知道事件来的时候，有多少个被监控的socket有数据可读了，于是，只能挨个遍历每个socket来收集可读事件le。</p><p>select本质上是通过设置或者检查存放fd标志位的数据结构来进行下一步处理。这样所带来的缺点是：</p><p>1、 单个进程可监视的fd数量被限制，即能监听端口的大小有限。</p><p>一般来说这个数目和系统内存关系很大，具体数目可以cat /proc/sys/fs/file-max察看。32位机默认是1024个。64位机默认是2048.</p><p>2、 对socket进行扫描时是线性扫描，即采用轮询的方法，效率较低：</p><p>当套接字比较多的时候，每次select()都要通过遍历FD_SETSIZE个Socket来完成调度,不管哪个Socket是活跃的,都遍历一遍。这会浪费很多CPU时间。如果能给套接字注册某个回调函数，当他们活跃时，自动完成相关操作，那就避免了轮询，这正是epoll与kqueue做的。</p><p>3、需要维护一个用来存放大量fd的数据结构，这样会使得用户空间和内核空间在传递该结构时复制开销大</p><h2 id="2-poll"><a href="#2-poll" class="headerlink" title="2.poll"></a>2.poll</h2><p>poll的机制与select类似，与select在本质上没有多大差别，管理多个描述符也是进行轮询，根据描述符的状态进行处理，但是poll没有最大文件描述符数量的限制。</p><p>poll的实现和select非常相似，只是描述fd集合的方式不同。针对select遗留的三个问题中（问题(2)是fd限制问题，问题(1)和(3)则是性能问题），poll只是使用pollfd结构而不是select的fd_set结构，这就解决了select的问题(2)fds集合大小1024限制问题。但poll和select同样存在一个性能缺点就是包含大量文件描述符的数组被整体复制于用户态和内核的地址空间之间，而不论这些文件描述符是否就绪，它的开销随着文件描述符数量的增加而线性增大。</p><p>Linux提供的poll函数接口如下：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;poll.h&gt;</span></span><span class="token keyword">int</span> <span class="token function">poll</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">pollfd</span> fds<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token class-name">nfds_t</span> nfds<span class="token punctuation">,</span> <span class="token keyword">int</span> timeout<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">pollfd</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> fd<span class="token punctuation">;</span>                         <span class="token comment">// 需要被检测或选择的文件描述符</span>        <span class="token keyword">short</span> events<span class="token punctuation">;</span>                   <span class="token comment">// 对文件描述符fd上感兴趣的事件</span>        <span class="token keyword">short</span> revents<span class="token punctuation">;</span>                  <span class="token comment">// 文件描述符fd上当前实际发生的事件*/</span><span class="token punctuation">}</span> <span class="token class-name">pollfd_t</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">poll</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">pollfd</span> <span class="token operator">*</span>fds<span class="token punctuation">,</span> nfds_tnfds<span class="token punctuation">,</span> <span class="token keyword">int</span> timeout<span class="token punctuation">)</span><span class="token punctuation">;</span>poll服务端实现伪码：<span class="token keyword">struct</span> <span class="token class-name">pollfd</span> fds<span class="token punctuation">[</span>POLL_LEN<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">unsigned</span> <span class="token keyword">int</span> nfds<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>fds<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>fd<span class="token operator">=</span>server_sockfd<span class="token punctuation">;</span>fds<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>events<span class="token operator">=</span>POLLIN<span class="token operator">|</span>POLLPRI<span class="token punctuation">;</span>nfds<span class="token operator">++</span><span class="token punctuation">;</span><span class="token keyword">while</span> <span class="token punctuation">{</span>    res<span class="token operator">=</span><span class="token function">poll</span><span class="token punctuation">(</span>fds<span class="token punctuation">,</span>nfds<span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>fds<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>revents<span class="token operator">&amp;</span><span class="token punctuation">(</span>POLLIN<span class="token operator">|</span>POLLPRI<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">//执行accept并加入fds中，nfds++</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">--</span>res<span class="token operator">&lt;=</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">continue</span>    <span class="token punctuation">}</span>    <span class="token comment">//循环之后的fds</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>fds<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>revents<span class="token operator">&amp;</span><span class="token punctuation">(</span>POLLIN<span class="token operator">|</span>POLLERR <span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">//读操作或处理异常等</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">--</span>res<span class="token operator">&lt;=</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">continue</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol><li>poll()函数返回fds集合中就绪的读、写，或出错的描述符数量，返回0表示超时，返回-1表示出错；</li><li>fds是一个struct pollfd类型的数组，用于存放需要检测其状态的socket描述符，并且调用poll函数之后fds数组不会被清空；</li><li>nfds记录数组fds中描述符的总数量；</li><li>timeout是调用poll函数阻塞的超时时间，单位毫秒；</li><li>一个pollfd结构体表示一个被监视的文件描述符，通过传递fds[]指示 poll() 监视多个文件描述符。其中，结构体的events域是监视该文件描述符的事件掩码，由用户来设置这个域，结构体的revents域是文件描述符的操作结果事件掩码，内核在调用返回时设置这个域。events域中请求的任何事件都可能在revents域中返回。</li></ol><p>合法的事件如下：</p><p>POLLIN 有数据可读</p><p>POLLRDNORM 有普通数据可读</p><p>POLLRDBAND 有优先数据可读</p><p>POLLPRI 有紧迫数据可读</p><p>POLLOUT 写数据不会导致阻塞</p><p>POLLWRNORM 写普通数据不会导致阻塞 POLLWRBAND 写优先数据不会导致阻塞 POLLMSGSIGPOLL 消息可用</p><p>当需要监听多个事件时，使用<strong>POLLIN | POLLRDNORM</strong>设置 events 域；当poll调用之后检测某事件是否发生时，<strong>fds[i].revents &amp; POLLIN</strong>进行判断。</p><p>poll和select同样存在一个缺点就是，包含大量文件描述符的数组被整体复制于用户态和内核的地址空间之间，而不论这些文件描述符是否就绪，它的开销随着文件描述符数量的增加而线性增大。</p><ul><li><p>它将用户传入的数组拷贝到内核空间</p></li><li><p>然后查询每个fd对应的设备状态：</p></li><li><ul><li>如果设备就绪 在设备等待队列中加入一项继续遍历</li><li>若遍历完所有fd后，都没发现就绪的设备 挂起当前进程，直到设备就绪或主动超时，被唤醒后它又再次遍历fd。这个过程经历多次无意义的遍历。</li></ul></li></ul><p><strong>它没有最大连接数的限制</strong>，原因是它是基于链表来存储的，但是同样有一个缺点：</p><p>1、大量的fd的数组被整体复制于用户态和内核地址空间之间，而不管这样的复制是不是有意义。</p><p>2、poll还有一个特点是“水平触发”，如果报告了fd后，没有被处理，那么下次poll时会再次报告该fd。</p><h2 id="3-epoll"><a href="#3-epoll" class="headerlink" title="3.epoll"></a>3.epoll</h2><p>在linux的网络编程中，很长的时间都在使用select来做事件触发。在linux新的内核中，有了一种替换它的机制，就是epoll。相比于select，epoll最大的好处在于它不会随着监听fd数目的增长而降低效率。如前面我们所说，在内核中的select实现中，它是采用轮询来处理的，轮询的fd数目越多，自然耗时越多。并且，在linux/posix_types.h头文件有这样的声明：<br>#define __FD_SETSIZE 1024<br>表示select最多同时监听1024个fd，当然，可以通过修改头文件再重编译内核来扩大这个数目，但这似乎并不治本。</p><p>创建一个epoll的句柄，size用来告诉内核这个监听的数目一共有多大。这个参数不同于select()中的第一个参数，给出最大监听的fd+1的值。需要注意的是，当创建好epoll句柄后，它就是会占用一个fd值，在linux下如果查看/proc/进程id/fd/，是能够看到这个fd的，所以在使用完epoll后，必须调用close()关闭，否则可能导致fd被耗尽。</p><p>epoll模型修改主动轮询为被动通知，当有事件发生时，被动接收通知。所以epoll模型注册套接字后，主程序可做其他事情，当事件发生时，接收到通知后再去处理。</p><p>可理解为<strong>event poll</strong>，epoll会把哪个流发生哪种I/O事件通知我们。所以epoll是事件驱动（每个事件关联fd），此时我们对这些流的操作都是有意义的。复杂度也降到O(1)。</p><p>epoll在Linux2.6内核正式提出，是基于事件驱动的I/O方式，相对于select和poll来说，epoll没有描述符个数限制，使用一个文件描述符管理多个描述符，将用户关心的文件描述符的事件存放到内核的一个事件表中，这样在用户空间和内核空间的copy只需一次。优点如下：</p><ol><li>没有最大并发连接的限制，能打开的fd上限远大于1024（1G的内存能监听约10万个端口）</li><li>采用回调的方式，效率提升。只有<strong>活跃可用</strong>的fd才会调用callback函数，也就是说 epoll 只管你“活跃”的连接，而跟连接总数无关，因此在实际的网络环境中，epoll的效率就会远远高于select和poll。</li><li>内存拷贝。使用mmap()文件映射内存来加速与内核空间的消息传递，减少复制开销。</li></ol><p>epoll对文件描述符的操作有两种模式：LT(level trigger，水平触发)和ET(edge trigger)。</p><p><strong>水平触发：</strong>默认工作模式，即当epoll_wait检测到某描述符事件就绪并通知应用程序时，应用程序可以不立即处理该事件；下次调用epoll_wait时，会再次通知此事件。</p><p><strong>边缘触发：</strong>当epoll_wait检测到某描述符事件就绪并通知应用程序时，应用程序必须立即处理该事件。如果不处理，下次调用epoll_wait时，不会再次通知此事件。（直到你做了某些操作导致该描述符变成未就绪状态了，也就是说边缘触发只在状态由未就绪变为就绪时通知一次）。</p><p>ET模式很大程度上减少了epoll事件的触发次数，因此效率比LT模式下高。</p><p>epoll有EPOLLLT和EPOLLET两种触发模式，LT是默认的模式，ET是“高速”模式。LT模式下，只要这个fd还有数据可读，每次 epoll_wait都会返回它的事件，提醒用户程序去操作，而在ET（边缘触发）模式中，它只会提示一次，直到下次再有数据流入之前都不会再提示了，无 论fd中是否还有数据可读。所以在ET模式下，read一个fd的时候一定要把它的buffer读光，也就是说一直读到read的返回值小于请求值，或者 遇到EAGAIN错误。还有一个特点是，epoll使用“事件”的就绪通知方式，通过epoll_ctl注册fd，一旦该fd就绪，内核就会采用类似callback的回调机制来激活该fd，epoll_wait便可以收到通知。</p><h3 id="epoll为什么要有EPOLLET触发模式？"><a href="#epoll为什么要有EPOLLET触发模式？" class="headerlink" title="epoll为什么要有EPOLLET触发模式？"></a><strong>epoll为什么要有EPOLLET触发模式？</strong></h3><p>如果采用EPOLLLT模式的话，系统中一旦有大量你不需要读写的就绪文件描述符，它们每次调用epoll_wait都会返回，这样会大大降低处理程序检索自己关心的就绪文件描述符的效率.。而采用EPOLLET这种边沿触发模式的话，当被监控的文件描述符上有可读写事件发生时，epoll_wait()会通知处理程序去读写。如果这次没有把数据全部读写完(如读写缓冲区太小)，那么下次调用epoll_wait()时，它不会通知你，也就是它只会通知你一次，直到该文件描述符上出现第二次可读写事件才会通知你！！！<strong>这种模式比水平触发效率高，系统不会充斥大量你不关心的就绪文件描述符</strong></p><p><strong>epoll的优点：</strong></p><p>1、<strong>没有最大并发连接的限制，能打开的FD的上限远大于1024（1G的内存上能监听约10万个端口）</strong>；<br><strong>2、效率提升，不是轮询的方式，不会随着FD数目的增加效率下降。只有活跃可用的FD才会调用callback函数；</strong><br><strong>即Epoll最大的优点就在于它只管你“活跃”的连接，而跟连接总数无关，因此在实际的网络环境中，Epoll的效率就会远远高于select和poll。</strong></p><p>3、 内存拷贝，利用mmap()文件映射内存加速与内核空间的消息传递；即epoll使用mmap减少复制开销。</p><p>epoll的接口非常简单，一共就三个函数：</p><ul><li>epoll_create：创建一个epoll句柄</li><li>epoll_ctl：向 epoll 对象中添加/修改/删除要管理的连接</li><li>epoll_wait：等待其管理的连接上的 IO 事件</li></ul><p>Linux中提供的epoll相关函数接口如下：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/epoll.h&gt;</span></span><span class="token keyword">int</span> <span class="token function">epoll_create</span><span class="token punctuation">(</span><span class="token keyword">int</span> size<span class="token punctuation">)</span><span class="token punctuation">;</span>功能：该函数生成一个 epoll 专用的文件描述符。参数size<span class="token operator">:</span> 用来告诉内核这个监听的数目一共有多大，参数 size 并不是限制了 epoll 所能监听的描述符最大个数，只是对内核初始分配内部数据结构的一个建议。自从 linux <span class="token number">2.6</span><span class="token number">.8</span> 之后，size 参数是被忽略的，也就是说可以填只有大于 <span class="token number">0</span> 的任意值。返回值：如果成功，返回poll 专用的文件描述符，否者失败，返回<span class="token operator">-</span><span class="token number">1</span>。<span class="token keyword">int</span> <span class="token function">epoll_ctl</span><span class="token punctuation">(</span><span class="token keyword">int</span> epfd<span class="token punctuation">,</span> <span class="token keyword">int</span> op<span class="token punctuation">,</span> <span class="token keyword">int</span> fd<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">epoll_event</span> <span class="token operator">*</span>event<span class="token punctuation">)</span><span class="token punctuation">;</span>功能：epoll 的事件注册函数，它不同于 <span class="token function">select</span><span class="token punctuation">(</span><span class="token punctuation">)</span> 是在监听事件时告诉内核要监听什么类型的事件，而是在这里先注册要监听的事件类型。参数epfd<span class="token operator">:</span> epoll 专用的文件描述符，<span class="token function">epoll_create</span><span class="token punctuation">(</span><span class="token punctuation">)</span>的返回值参数op<span class="token operator">:</span> 表示动作，用三个宏来表示：EPOLL_CTL_ADD：注册新的 fd 到 epfd 中；EPOLL_CTL_MOD：修改已经注册的fd的监听事件；EPOLL_CTL_DEL：从 epfd 中删除一个 fd；参数fd<span class="token operator">:</span> 需要监听的文件描述符参数event<span class="token operator">:</span> 告诉内核要监听什么事件，<span class="token keyword">struct</span> <span class="token class-name">epoll_event</span> 结构如<span class="token operator">:</span><span class="token keyword">struct</span> <span class="token class-name">epoll_event</span> <span class="token punctuation">{</span>    __uint32_t events<span class="token punctuation">;</span>  <span class="token comment">/* Epoll events */</span>    <span class="token class-name">epoll_data_t</span> data<span class="token punctuation">;</span>  <span class="token comment">/* User data variable */</span><span class="token punctuation">}</span><span class="token punctuation">;</span>events可以是以下几个宏的集合：EPOLLIN ：表示对应的文件描述符可以读（包括对端 SOCKET 正常关闭）；EPOLLOUT：表示对应的文件描述符可以写；EPOLLPRI：表示对应的文件描述符有紧急的数据可读（这里应该表示有带外数据到来）；EPOLLERR：表示对应的文件描述符发生错误；EPOLLRDHUP<span class="token operator">:</span>表示对端断开连接；对端正常关闭EPOLLHUP：表示对应的文件描述符被挂断；EPOLLET ：将 EPOLL 设为边缘触发<span class="token punctuation">(</span>Edge Trigger<span class="token punctuation">)</span>模式，这是相对于水平触发<span class="token punctuation">(</span>Level Trigger<span class="token punctuation">)</span>来说的。EPOLLONESHOT：只监听一次事件，当监听完这次事件之后，如果还需要继续监听这个 socket 的话，需要再次把这个 socket 加入到 EPOLL 队列里返回值：<span class="token number">0</span>表示成功，<span class="token operator">-</span><span class="token number">1</span>表示失败。<span class="token keyword">int</span> <span class="token function">epoll_wait</span><span class="token punctuation">(</span><span class="token keyword">int</span> epfd<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">epoll_event</span> <span class="token operator">*</span> events<span class="token punctuation">,</span> <span class="token keyword">int</span> maxevents<span class="token punctuation">,</span> <span class="token keyword">int</span> timeout<span class="token punctuation">)</span><span class="token punctuation">;</span>功能：等待事件的产生，收集在 epoll 监控的事件中已经发送的事件，类似于 <span class="token function">select</span><span class="token punctuation">(</span><span class="token punctuation">)</span> 调用。参数epfd<span class="token operator">:</span> epoll 专用的文件描述符，<span class="token function">epoll_create</span><span class="token punctuation">(</span><span class="token punctuation">)</span>的返回值参数events<span class="token operator">:</span> 分配好的 epoll_event 结构体数组，epoll 将会把发生的事件赋值到events 数组中（events 不可以是空指针，内核只负责把数据复制到这个 events 数组中，不会去帮助我们在用户态中分配内存）。参数maxevents<span class="token operator">:</span> maxevents 告之内核这个 events 有多少个 。参数timeout<span class="token operator">:</span> 超时时间，单位为毫秒，为 <span class="token operator">-</span><span class="token number">1</span> 时，函数为阻塞。返回值：如果成功，表示返回需要处理的事件数目如果返回<span class="token number">0</span>，表示已超时如果返回<span class="token operator">-</span><span class="token number">1</span>，表示失败<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol><li><p><strong>epoll_create</strong>函数创建一个epoll句柄，参数size表明内核要监听的描述符数量。调用成功时返回一个epoll句柄描述符，失败时返回-1。</p></li><li><p><strong>epoll_ct</strong>l函数注册要监听的事件类型。四个参数解释如下：<br><img src="https://www.zhihu.com/equation?tex=%5Ccirc+" alt="[公式]"> epfd表示epoll句柄；<br><img src="https://www.zhihu.com/equation?tex=%5Ccirc+" alt="[公式]"> op表示fd操作类型：<strong>EPOLL_CTL_ADD</strong>（注册新的fd到epfd中），<strong>EPOLL_CTL_MOD</strong>（修改已注册的fd的监听事件），<strong>EPOLL_CTL_DEL</strong>（从epfd中删除一个fd）<br><img src="https://www.zhihu.com/equation?tex=%5Ccirc+" alt="[公式]"> fd是要监听的描述符；<br><img src="https://www.zhihu.com/equation?tex=%5Ccirc+" alt="[公式]"> event表示要监听的事件<br>epoll_event结构体定义如下：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">epoll_event</span> <span class="token punctuation">{</span>    __uint32_t events<span class="token punctuation">;</span>  <span class="token comment">/* Epoll events */</span>    <span class="token class-name">epoll_data_t</span> data<span class="token punctuation">;</span>  <span class="token comment">/* User data variable */</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">typedef</span> <span class="token keyword">union</span> epoll_data <span class="token punctuation">{</span>    <span class="token keyword">void</span> <span class="token operator">*</span>ptr<span class="token punctuation">;</span>    <span class="token keyword">int</span> fd<span class="token punctuation">;</span>    __uint32_t u32<span class="token punctuation">;</span>    __uint64_t u64<span class="token punctuation">;</span><span class="token punctuation">}</span> <span class="token class-name">epoll_data_t</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><strong>epoll_wait</strong>函数等待事件的就绪，成功时返回就绪的事件数目，调用失败时返回 -1，等待超时返回 0。</p><p><img src="https://www.zhihu.com/equation?tex=%5Ccirc+" alt="[公式]"> epfd是epoll句柄<br><img src="https://www.zhihu.com/equation?tex=%5Ccirc+" alt="[公式]"> events表示从内核得到的就绪事件集合<br><img src="https://www.zhihu.com/equation?tex=%5Ccirc+" alt="[公式]"> maxevents告诉内核events的大小<br><img src="https://www.zhihu.com/equation?tex=%5Ccirc+" alt="[公式]"> timeout表示等待的超时事件</p></li></ol><p>epoll_create的源码实现：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token function">SYSCALL_DEFINE1</span><span class="token punctuation">(</span>epoll_create1<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">,</span> flags<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">struct</span> <span class="token class-name">eventpoll</span> <span class="token operator">*</span>ep <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    <span class="token comment">//创建一个 eventpoll 对象</span>    error <span class="token operator">=</span> <span class="token function">ep_alloc</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>ep<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">//struct eventpoll 的定义</span><span class="token comment">// file：fs/eventpoll.c</span><span class="token keyword">struct</span> <span class="token class-name">eventpoll</span> <span class="token punctuation">{</span>    <span class="token comment">//sys_epoll_wait用到的等待队列</span>    wait_queue_head_t wq<span class="token punctuation">;</span>    <span class="token comment">//接收就绪的描述符都会放到这里</span>    <span class="token keyword">struct</span> <span class="token class-name">list_head</span> rdllist<span class="token punctuation">;</span>    <span class="token comment">//每个epoll对象中都有一颗红黑树</span>    <span class="token keyword">struct</span> <span class="token class-name">rb_root</span> rbr<span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">ep_alloc</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">eventpoll</span> <span class="token operator">*</span><span class="token operator">*</span>pep<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">struct</span> <span class="token class-name">eventpoll</span> <span class="token operator">*</span>ep<span class="token punctuation">;</span>    <span class="token comment">//申请 epollevent 内存</span>    ep <span class="token operator">=</span> <span class="token function">kzalloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token operator">*</span>ep<span class="token punctuation">)</span><span class="token punctuation">,</span> GFP_KERNEL<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//初始化等待队列头</span>    <span class="token function">init_waitqueue_head</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>ep<span class="token operator">-&gt;</span>wq<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//初始化就绪列表</span>    <span class="token function">INIT_LIST_HEAD</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>ep<span class="token operator">-&gt;</span>rdllist<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//初始化红黑树指针</span>    ep<span class="token operator">-&gt;</span>rbr <span class="token operator">=</span> RB_ROOT<span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span>其中eventpoll 这个结构体中的几个成员的含义如下：<span class="token operator">-</span> <span class="token operator">*</span><span class="token operator">*</span>wq：<span class="token operator">*</span><span class="token operator">*</span> 等待队列链表。软中断数据就绪的时候会通过 wq 来找到阻塞在 epoll 对象上的用户进程。<span class="token operator">-</span> <span class="token operator">*</span><span class="token operator">*</span>rbr：<span class="token operator">*</span><span class="token operator">*</span> 红黑树。为了支持对海量连接的高效查找、插入和删除，eventpoll 内部使用的就是红黑树。通过红黑树来管理用户主进程accept添加进来的所有 socket 连接。<span class="token operator">-</span> <span class="token operator">*</span><span class="token operator">*</span>rdllist：<span class="token operator">*</span><span class="token operator">*</span> 就绪的描述符链表。当有连接就绪的时候，内核会把就绪的连接放到 rdllist 链表里。这样应用进程只需要判断链表就能找出就绪进程，而不用去遍历红黑树的所有节点了。c<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/socket.h&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;netinet/in.h&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;arpa/inet.h&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;errno.h&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;fcntl.h&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;cassert&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/epoll.h&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/types.h&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/stat.h&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string.h&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;iostream&gt;</span></span><span class="token keyword">const</span> <span class="token keyword">int</span> MAX_EVENT_NUMBER <span class="token operator">=</span> <span class="token number">10000</span><span class="token punctuation">;</span> <span class="token comment">//最大事件数</span><span class="token comment">// 设置句柄非阻塞</span><span class="token keyword">int</span> <span class="token function">setnonblocking</span><span class="token punctuation">(</span><span class="token keyword">int</span> fd<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> old_option <span class="token operator">=</span> <span class="token function">fcntl</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span> F_GETFL<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> new_option <span class="token operator">=</span> old_option <span class="token operator">|</span> O_NONBLOCK<span class="token punctuation">;</span>    <span class="token function">fcntl</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span> F_SETFL<span class="token punctuation">,</span> new_option<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> old_option<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment">// 创建套接字</span>    <span class="token keyword">int</span> nRet<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> m_listenfd <span class="token operator">=</span> <span class="token function">socket</span><span class="token punctuation">(</span>PF_INET<span class="token punctuation">,</span> SOCK_STREAM<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>m_listenfd<span class="token operator">&lt;</span><span class="token number">0</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"fail to socket!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">// </span>    <span class="token keyword">struct</span> <span class="token class-name">sockaddr_in</span> address<span class="token punctuation">;</span>    <span class="token function">bzero</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>address<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>address<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    address<span class="token punctuation">.</span>sin_family <span class="token operator">=</span> AF_INET<span class="token punctuation">;</span>    address<span class="token punctuation">.</span>sin_addr<span class="token punctuation">.</span>s_addr <span class="token operator">=</span> <span class="token function">htonl</span><span class="token punctuation">(</span>INADDR_ANY<span class="token punctuation">)</span><span class="token punctuation">;</span>    address<span class="token punctuation">.</span>sin_port <span class="token operator">=</span> <span class="token function">htons</span><span class="token punctuation">(</span><span class="token number">6666</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> flag <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token comment">// 设置ip可重用</span>    <span class="token function">setsockopt</span><span class="token punctuation">(</span>m_listenfd<span class="token punctuation">,</span> SOL_SOCKET<span class="token punctuation">,</span> SO_REUSEADDR<span class="token punctuation">,</span> <span class="token operator">&amp;</span>flag<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>flag<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 绑定端口号</span>    <span class="token keyword">int</span> ret <span class="token operator">=</span> <span class="token function">bind</span><span class="token punctuation">(</span>m_listenfd<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">sockaddr</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>address<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>address<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>ret<span class="token operator">&lt;</span><span class="token number">0</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"fail to bind!,errno :%d"</span><span class="token punctuation">,</span>errno<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> ret<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">// 监听连接fd</span>    ret <span class="token operator">=</span> <span class="token function">listen</span><span class="token punctuation">(</span>m_listenfd<span class="token punctuation">,</span> <span class="token number">200</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>ret<span class="token operator">&lt;</span><span class="token number">0</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"fail to listen!,errno :%d"</span><span class="token punctuation">,</span>errno<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> ret<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">// 初始化红黑树和事件链表结构rdlist结构</span>    epoll_event events<span class="token punctuation">[</span>MAX_EVENT_NUMBER<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> m_epollfd <span class="token operator">=</span> <span class="token function">epoll_create</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>m_epollfd<span class="token operator">==</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"fail to epoll create!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> m_epollfd<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">// 创建节点结构体将监听连接句柄</span>    epoll_event event<span class="token punctuation">;</span>    event<span class="token punctuation">.</span>data<span class="token punctuation">.</span>fd <span class="token operator">=</span> m_listenfd<span class="token punctuation">;</span>    <span class="token comment">//设置该句柄为边缘触发（数据没处理完后续不会再触发事件，水平触发是不管数据有没有触发都返回事件），</span>    event<span class="token punctuation">.</span>events <span class="token operator">=</span> EPOLLIN <span class="token operator">|</span> EPOLLET <span class="token operator">|</span> EPOLLRDHUP<span class="token punctuation">;</span>    <span class="token comment">// 添加监听连接句柄作为初始节点进入红黑树结构中，该节点后续处理连接的句柄</span>    <span class="token function">epoll_ctl</span><span class="token punctuation">(</span>m_epollfd<span class="token punctuation">,</span> EPOLL_CTL_ADD<span class="token punctuation">,</span> m_listenfd<span class="token punctuation">,</span> <span class="token operator">&amp;</span>event<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//进入服务器循环</span>    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">int</span> number <span class="token operator">=</span> <span class="token function">epoll_wait</span><span class="token punctuation">(</span>m_epollfd<span class="token punctuation">,</span> events<span class="token punctuation">,</span> MAX_EVENT_NUMBER<span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>number <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> errno <span class="token operator">!=</span> EINTR<span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token function">printf</span><span class="token punctuation">(</span> <span class="token string">"epoll failure"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> number<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token keyword">int</span> sockfd <span class="token operator">=</span> events<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>data<span class="token punctuation">.</span>fd<span class="token punctuation">;</span>            <span class="token comment">// 属于处理新到的客户连接</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>sockfd <span class="token operator">==</span> m_listenfd<span class="token punctuation">)</span>            <span class="token punctuation">{</span>                <span class="token keyword">struct</span> <span class="token class-name">sockaddr_in</span> client_address<span class="token punctuation">;</span>                socklen_t client_addrlength <span class="token operator">=</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>client_address<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">int</span> connfd <span class="token operator">=</span> <span class="token function">accept</span><span class="token punctuation">(</span>m_listenfd<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">sockaddr</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>client_address<span class="token punctuation">,</span> <span class="token operator">&amp;</span>client_addrlength<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>connfd <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>                <span class="token punctuation">{</span>                    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"errno is:%d accept error"</span><span class="token punctuation">,</span> errno<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                epoll_event event<span class="token punctuation">;</span>                event<span class="token punctuation">.</span>data<span class="token punctuation">.</span>fd <span class="token operator">=</span> connfd<span class="token punctuation">;</span>                <span class="token comment">//设置该句柄为边缘触发（数据没处理完后续不会再触发事件，水平触发是不管数据有没有触发都返回事件），</span>                event<span class="token punctuation">.</span>events <span class="token operator">=</span> EPOLLIN <span class="token operator">|</span> EPOLLRDHUP<span class="token punctuation">;</span>                <span class="token comment">// 添加监听连接句柄作为初始节点进入红黑树结构中，该节点后续处理连接的句柄</span>                <span class="token function">epoll_ctl</span><span class="token punctuation">(</span>m_epollfd<span class="token punctuation">,</span> EPOLL_CTL_ADD<span class="token punctuation">,</span> connfd<span class="token punctuation">,</span> <span class="token operator">&amp;</span>event<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token function">setnonblocking</span><span class="token punctuation">(</span>connfd<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>events<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>events <span class="token operator">&amp;</span> <span class="token punctuation">(</span>EPOLLRDHUP <span class="token operator">|</span> EPOLLHUP <span class="token operator">|</span> EPOLLERR<span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token punctuation">{</span>                <span class="token comment">//服务器端关闭连接，</span>                <span class="token function">epoll_ctl</span><span class="token punctuation">(</span>m_epollfd<span class="token punctuation">,</span> EPOLL_CTL_DEL<span class="token punctuation">,</span> sockfd<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token function">close</span><span class="token punctuation">(</span>sockfd<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token comment">//处理客户连接上接收到的数据</span>            <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>events<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>events <span class="token operator">&amp;</span> EPOLLIN<span class="token punctuation">)</span>            <span class="token punctuation">{</span>                <span class="token keyword">char</span> buf<span class="token punctuation">[</span><span class="token number">1024</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span>                <span class="token function">read</span><span class="token punctuation">(</span>sockfd<span class="token punctuation">,</span>buf<span class="token punctuation">,</span><span class="token number">1024</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"from client :%s"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment">// 将事件设置为写事件返回数据给客户端</span>                events<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>data<span class="token punctuation">.</span>fd <span class="token operator">=</span> sockfd<span class="token punctuation">;</span>                events<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>events <span class="token operator">=</span> EPOLLOUT <span class="token operator">|</span> EPOLLET <span class="token operator">|</span> EPOLLONESHOT <span class="token operator">|</span> EPOLLRDHUP<span class="token punctuation">;</span>                <span class="token function">epoll_ctl</span><span class="token punctuation">(</span>m_epollfd<span class="token punctuation">,</span> EPOLL_CTL_MOD<span class="token punctuation">,</span> sockfd<span class="token punctuation">,</span> <span class="token operator">&amp;</span>events<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>events<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>events <span class="token operator">&amp;</span> EPOLLOUT<span class="token punctuation">)</span>            <span class="token punctuation">{</span>                std<span class="token double-colon punctuation">::</span>string response <span class="token operator">=</span> <span class="token string">"server response \n"</span><span class="token punctuation">;</span>                <span class="token function">write</span><span class="token punctuation">(</span>sockfd<span class="token punctuation">,</span>response<span class="token punctuation">.</span><span class="token function">c_str</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>response<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment">// 将事件设置为读事件，继续监听客户端</span>                events<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>data<span class="token punctuation">.</span>fd <span class="token operator">=</span> sockfd<span class="token punctuation">;</span>                events<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>events <span class="token operator">=</span> EPOLLIN <span class="token operator">|</span> EPOLLRDHUP<span class="token punctuation">;</span>                <span class="token function">epoll_ctl</span><span class="token punctuation">(</span>m_epollfd<span class="token punctuation">,</span> EPOLL_CTL_MOD<span class="token punctuation">,</span> sockfd<span class="token punctuation">,</span> <span class="token operator">&amp;</span>events<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token comment">//else if 可以加管道，unix套接字等等数据</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4 总结"></a>4 总结</h2><p>select，poll，epoll都是IO多路复用机制，即可以监视多个描述符，一旦某个描述符就绪（读或写就绪），能够通知程序进行相应读写操作。 但select，poll，epoll本质上都是<strong>同步I/O</strong>，因为他们都需要在读写事件就绪后自己负责进行读写，也就是说这个读写过程是阻塞的，而异步I/O则无需自己负责进行读写，异步I/O的实现会负责把数据从内核拷贝到用户空间。</p><ul><li>select，poll实现需要自己不断轮询所有fd集合，直到设备就绪，期间可能要睡眠和唤醒多次交替。而epoll其实也需要调用epoll_wait不断轮询就绪链表，期间也可能多次睡眠和唤醒交替，但是它是设备就绪时，调用回调函数，把就绪fd放入就绪链表中，并唤醒在epoll_wait中进入睡眠的进程。虽然都要睡眠和交替，但是select和poll在“醒着”的时候要遍历整个fd集合，而epoll在“醒着”的时候只要判断一下就绪链表是否为空就行了，这节省了大量的CPU时间。这就是回调机制带来的性能提升。</li><li>select，poll每次调用都要把fd集合从用户态往内核态拷贝一次，并且要把current往设备等待队列中挂一次，而epoll只要一次拷贝，而且把current往等待队列上挂也只挂一次（在epoll_wait的开始，注意这里的等待队列并不是设备等待队列，只是一个epoll内部定义的等待队列）。这也能节省不少的开销。</li></ul><p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220311223126301.png" alt="image-20220311223126301"></p>]]></content>
      
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>gcc</title>
      <link href="/2023/06/27/gcc/"/>
      <url>/2023/06/27/gcc/</url>
      
        <content type="html"><![CDATA[<h3 id="GCC编译器在编译一个C语言程序时需要经过以下-4-步："><a href="#GCC编译器在编译一个C语言程序时需要经过以下-4-步：" class="headerlink" title="GCC编译器在编译一个C语言程序时需要经过以下 4 步："></a>GCC编译器在编译一个C语言程序时需要经过以下 4 步：</h3><ol><li>将C语言源程序预处理，生成.i文件。</li><li>预处理后的.i文件编译成为汇编语言，生成.s文件。</li><li>将汇编语言文件经过汇编，生成目标文件.o文件。</li><li>将各个模块的.o文件链接起来生成一个可执行程序文件。</li></ol><p>c文件生成可执行文件需要经过四个步骤预编译、汇编、编译、链接</p><h3 id="常用编译命令选项"><a href="#常用编译命令选项" class="headerlink" title="常用编译命令选项"></a>常用编译命令选项</h3><h3 id="常用编译命令选项-1"><a href="#常用编译命令选项-1" class="headerlink" title="常用编译命令选项"></a>常用编译命令选项</h3><p><strong>1. 无选项</strong></p><p>用法：#gcc test.c</p><p>作用：将test.c预处理、汇编、编译并链接形成<strong>可执行文件</strong>。</p><p>这里未指定输出文件，默认输出为a.out。</p><p><strong>2. 选项 -o</strong></p><p>用法：#gcc test.c -o test</p><p>作用：将test.c预处理、汇编、编译并链接形成可执行文件test。</p><p>-o选项用来指定输出文件的文件名。</p><p><strong>3. 选项 –E &nbsp;预处理指定的源文件，不进行编译。将C语言源文件进行预处理，但是并不编译该程序。对于一般的预处理问题，可以使用这个选项进行查看，例如，宏的展开问题、文件的包含问题等。</strong></p><p>用法：#gcc -E test.c -o test.i</p><p>作用：将test.c预处理输出test.i文件。</p><p><strong>4. 选项 –S &nbsp;将C语言源文件编译为汇编语言，但是并不汇编该程序。</strong></p><p>用法：#gcc -S test.i</p><p>作用：将预处理输出文件test.i汇编成test.s文件。</p><p><strong>5. 选项 –c &nbsp;编译、汇编指定的源文件，但是不进行链接</strong></p><p>用法：#gcc -c test.s</p><p>作用：将汇编输出文件test.s编译输出test.o文件。</p><p><strong>6. 选项 -o</strong></p><p>用法：#gcc test.o -o test</p><p>作用：将编译输出文件test.o链接成最终可执行文件test。</p><p><strong>7. 选项-O</strong></p><p>用法：#gcc -O1 test.c -o test</p><p>作用：使用编译优化级别1编译程序。级别为1~3，级别越大优化效果越好，但编译时间越长。</p><p><strong>8. 选项-I directory</strong></p><p>用法：指定 include 包含文件的搜索目录</p><p><strong>9 选项-g 生成调试信息，该程序可以被调试器调试</strong></p><p><strong>10. 选项 –L directory 指定库文件目录</strong></p><h3 id="多源文件的编译方法"><a href="#多源文件的编译方法" class="headerlink" title="多源文件的编译方法"></a>多源文件的编译方法</h3><p>如果有多个源文件，基本上有两种编译方法：</p><p>[假设有两个源文件为test.c和testfun.c]</p><p><strong>1. 多个文件一起编译</strong></p><p>用法：#gcc testfun.c test.c -o test</p><p>作用：将testfun.c和test.c分别编译后链接成test可执行文件。</p><p><strong>2. 分别编译各个源文件，之后对编译后输出的目标文件链接。</strong></p><p>用法：</p><p>#gcc -c testfun.c //将testfun.c编译成testfun.o</p><p>#gcc -c test.c&nbsp;&nbsp; //将test.c编译成test.o</p><p>#gcc  testfun.o test.o -o test //将testfun.o和test.o链接成test</p><p>以上两种方法相比较，第一中方法编译时需要所有文件重新编译，而第二种方法可以只重新编译修改的文件，未修改的文件不用重新编译。</p><p><strong>3. 库文件连接</strong></p><p>开发软件时，完全不使用第三方函数库的情况是比较少见的，通常来讲都需要借助许多函数库的支持才能够完成相应的功能。从程序员的角度看，函数库实际上就是一些头文件（.h）和库文件（so、或lib、dll）的集合。。虽然Linux下的大多数函数都默认将头文件放到/usr/include/目录下，而库文件则放到/usr/lib/目录下；Windows所使用的库文件主要放在Visual Stido的目录下的include和lib，以及系统文件夹下。但也有的时候，我们要用的库不再这些目录下，所以GCC在编译时必须用自己的办法来查找所需要的头文件和库文件。</p><p>例如我们的程序test.c是在linux上使用c连接mysql，这个时候我们需要去mysql官网下载MySQL Connectors的C库，下载下来解压之后，有一个include文件夹，里面包含mysql connectors的头文件，还有一个lib文件夹，里面包含二进制so文件libmysqlclient.so</p><p>其中inclulde文件夹的路径是/usr/dev/mysql/include,lib文件夹是/usr/dev/mysql/lib</p><p>3.1编译成可执行文件</p><p>首先我们要进行编译test.c为目标文件，这个时候需要执行</p><p>gcc –c –I /usr/dev/mysql/include test.c –o test.o</p><p>3.2链接</p><p>最后我们把所有目标文件链接成可执行文件:</p><p>gcc –L /usr/dev/mysql/lib –lmysqlclient test.o –o test</p><p>Linux下的库文件分为两大类分别是动态链接库（通常以.so结尾）和静态链接库（通常以.a结尾），二者的区别仅在于程序执行时所需的代码是在运行时动态加载的，还是在编译时静态加载的。</p><p>3.3强制链接时使用静态链接库</p><p>默认情况下， GCC在链接时优先使用动态链接库，只有当动态链接库不存在时才考虑使用静态链接库，如果需要的话可以在编译时加上-static选项，强制使用静态链接库。</p><p>在/usr/dev/mysql/lib目录下有链接时所需要的库文件libmysqlclient.so和libmysqlclient.a，为了让GCC在链接时只用到静态链接库，可以使用下面的命令:</p><p>gcc –L /usr/dev/mysql/lib –static –lmysqlclient test.o –o test</p><p><strong>静态库链接时搜索路径顺序：</strong></p><ol><li><p>ld会去找GCC命令中的参数-L</p></li><li><p>再找gcc的环境变量LIBRARY_PATH</p></li><li><p>再找内定目录 /lib /usr/lib /usr/local/lib 这是当初compile gcc时写在程序内的</p></li></ol><p><strong>动态链接时、执行时搜索路径顺序:</strong></p><ol><li><p>编译目标代码时指定的动态库搜索路径</p></li><li><p>环境变量LD_LIBRARY_PATH指定的动态库搜索路径</p></li><li><p>配置文件/etc/ld.so.conf中指定的动态库搜索路径</p></li><li><p>默认的动态库搜索路径/lib</p></li><li><p>默认的动态库搜索路径/usr/lib</p></li></ol><p><strong>有关环境变量：</strong></p><p>LIBRARY_PATH环境变量：指定程序静态链接库文件搜索路径</p><p>LD_LIBRARY_PATH环境变量：指定程序动态链接库文件搜索路径</p><p><strong>搜索路径</strong></p><p>首先要理解 #include&lt;file.h&gt;和#include”file.h”的区别:<br>#include&lt;file.h&gt;只在默认的系统包含路径搜索头文件<br>#include”file.h”首先在当前目录搜索头文件, 若头文件不位于当前目录, 则到系统默认的包含路径搜索头文件.</p><p><strong>UNIX类系统默认的系统路径为：</strong></p><p>头文件，包含路径：　/usr/local/include/ or /usr/include/<br>库文件，连接路径：　/usr/local/lib/&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; or /usr/lib/</p><p><strong>命令行设置　&gt; 环境变量设置　&gt; 系统默认</strong></p><p>外部库有两种：(1)静态连接库lib.a<br>                     (2)共享连接库lib.so<br>两者的共同点：<br>    .a, .so都是.o目标文件的集合，这些目标文件中含有一些函数的定义（机器码），而这些函数将在</p><p>连接时会被最终的可执行文件用到。</p><p>两者的区别：<br>    静态库.a : 当程序与静态库连接时，库中目标文件所含的所有将被程序使用的函数的机器码被copy到最终的可执行文件中. 静态库有个缺点: 占用磁盘和内存空间. 静态库会被添加到和它连接的每个程序中, 而且这些程序运行时, 都会被加载到内存中. 无形中又多消耗了更多的内存空间.</p><p>&nbsp;&nbsp;&nbsp;&nbsp;共享库.so : 与共享库连接的可执行文件只包含它需要的函数的引用表，而不是所有的函数代码，只有在程序执行时, 那些需要的函数代码才被拷贝到内存中, 这样就使可执行文件比较小, 节省磁盘空间(更进一步，操作系统使用虚拟内存，使得一份共享库驻留在内存中被多个程序使用).共享库还有个优点:</p><p>若库本身被更新, 不需要重新编译与它连接的源程序。</p><h1 id="1-生成静态库-libSwap-a"><a href="#1-生成静态库-libSwap-a" class="headerlink" title="1.生成静态库 libSwap.a"></a>1.生成静态库 libSwap.a</h1><h2 id="静态库的制作过程"><a href="#静态库的制作过程" class="headerlink" title="静态库的制作过程"></a>静态库的制作过程</h2><ol><li>gcc -c 编译获得<code>.o</code>文件;</li><li>将<code>.o</code>文件打包，使用<code>ar（archive）</code>工具</li></ol><p>打包命令：<br><code>ar rcs libxxx.a xx.o xx.o</code><br>r - 将文件插入备存文件<br>c - 建立备存文件<br>s - 索引</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">g++ <span class="token parameter variable">-c</span> swap.o swap.cppar rcs libswap.a swap.o<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="静态库的使用"><a href="#静态库的使用" class="headerlink" title="静态库的使用"></a>静态库的使用</h2><p>通过使用头文件建立函的声明，在编译主函数时，使用以下命令</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">gcc <span class="token parameter variable">-o</span> app main.c <span class="token parameter variable">-I</span> ./头文件路径 <span class="token parameter variable">-l</span> 静态库名 <span class="token parameter variable">-L</span> ./静态库路径<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h1 id="2-生成动态库-swap-so"><a href="#2-生成动态库-swap-so" class="headerlink" title="2.生成动态库 swap.so"></a>2.生成动态库 swap.so</h1><h2 id="动态库制作过程"><a href="#动态库制作过程" class="headerlink" title="动态库制作过程"></a>动态库制作过程</h2><p>1.gcc -c 编译获得.o文件，得到和位置无关的代码，这将改变编译器生成特定操作的代码的方式，包括变量（全局、静态）、常量的访问以及获取函数的地址，这些改变可以让代码运行时放置到任意一个虚拟地址处。动态库在链接阶段不会打包到可执行程序中，而是把动态库的一些信息加载到可执行文件中。 </p><p>gcc -c -fpic/fPIC xx.c xxx.c </p><p>2.得到动态库 gcc -shared xx.o xxx.o -o libxxx.so</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">g++ swap.cpp <span class="token parameter variable">-Iinclude</span> <span class="token parameter variable">-fPIC</span> <span class="token parameter variable">-shared</span> <span class="token parameter variable">-o</span> libswap.so<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>&nbsp;-fpic&nbsp; （ pic:position independent code位置无关码）用于编译阶段，产生的代码没有绝对地址，全部用相对地址，满足了共享库的要求，共享库被加载时地址不是固定的。</p><h2 id="动态库的使用"><a href="#动态库的使用" class="headerlink" title="动态库的使用"></a>动态库的使用</h2><p>通过使用头文件建立函的声明，在编译主函数时，使用以下命令<br><code>gcc -o app main.c -I ./头文件路径 -l 动态库名 -L ./动态库路径</code></p><h2 id="动态库的加载"><a href="#动态库的加载" class="headerlink" title="动态库的加载"></a>动态库的加载</h2><p>通过ldd（list dynamic dependencies）命令可以查看动态库的依赖关系（小知识） 系统加载可执行代码时，需要依赖库的名字以及其绝对路径。系统会通过动态加载器来获取绝对路径。对于 elf （二进制文件）格式的可执行程序，它是由 ld-linux.so 来完成的，他先后搜索 elf 文件的 DT_RPATRH段（位于程序进程的虚拟地址空间中） -&gt; 环境变量（LD_LIBRARY_PATH） -&gt; /etc/ld.so.cache文件列表 -&gt; /lib 或者/usr/lib目录，寻找库文件并将其载入内存。</p><h2 id="配置环境变量"><a href="#配置环境变量" class="headerlink" title="配置环境变量"></a>配置环境变量</h2><p>1.临时配置环境变量 </p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">export</span> <span class="token assign-left variable">LD_LIBRARY_PATH</span><span class="token operator">=</span><span class="token variable">$LD_LIBRARY_PATH</span>:我的环境变量绝对路径，<span class="token variable">$LD_LIBRARY</span>是当然的环境变量。<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>2.用户级别环境变量配置 </p><p>在用户目录下打开.bashrc文件，在最后追加</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">export</span> <span class="token assign-left variable">LD_LIBRARY_PATH</span><span class="token operator">=</span><span class="token variable">$LD_LIBRARY_PATH</span>:我的环境变量绝对路径<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>并通过source .bashrc 或者 . .bashrc 刷新文件</p><p>3.系统级别环境变量配置</p><p>sudo vim /etc/profile 打开配置文件；  添加</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">export</span> <span class="token assign-left variable">LD_LIBRARY_PATH</span><span class="token operator">=</span><span class="token variable">$LD_LIBRARY_PATH</span>:我的环境变量绝对路径<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>使用 source /etc/profile 或者 . /etc/profile 刷新文件</p><p>4.修改 /etc/ld.so.cache 文件</p><p>sudo vim /etc/ld.so.conf  添加</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">export</span> <span class="token assign-left variable">LD_LIBRARY_PATH</span><span class="token operator">=</span><span class="token variable">$LD_LIBRARY_PATH</span>:我的环境变量绝对路径<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>sudo ldconfig</p><p>5.把<code>.so</code>文件放入/lib 或者 /usr/lib 文件中，但不建议这么做</p>]]></content>
      
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>memoryleak</title>
      <link href="/2023/06/27/memoryleak/"/>
      <url>/2023/06/27/memoryleak/</url>
      
        <content type="html"><![CDATA[<h1 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h1><p>是虚拟内存</p><p>内存泄漏，是由用户空间的堆上的数据</p><h2 id="原因："><a href="#原因：" class="headerlink" title="原因："></a>原因：</h2><ol><li><h3 id="malloc-new，没有与之匹配的free与delete。"><a href="#malloc-new，没有与之匹配的free与delete。" class="headerlink" title="malloc/new，没有与之匹配的free与delete。"></a>malloc/new，没有与之匹配的free与delete。</h3></li><li><h3 id="malloc-free"><a href="#malloc-free" class="headerlink" title="malloc()/free();"></a>malloc()/free();</h3></li><li></li></ol><p>定位到哪一行调用malloc，确定哪个指针没有释放，定位哪一行代码</p><p>1.如何确定内存泄漏，htop/top（猜测，大概率）</p><p>2.确定在哪一行内存泄漏</p><p>malloc时创建相应的文件， free时unlink(unix系统函数)</p><p>malloc –&gt; create file(filename :%p.mem)  编译器选项(<strong><strong><strong>FILE</strong></strong></strong>,  ____<strong>LINE</strong>)哪一个文件的哪一行</p><p>free–&gt; unlink()</p><p>线上内存泄漏，如何解决？</p><p>1.内存机制做好</p><p>2.热更新，conf, flag = 1</p><p>bpf–&gt;内核版本需要在4.19以上</p><p>bpftrace</p><p>mtrace</p><p>工具:</p><p>cppcheck</p><p>windows:</p><p>msvc debug</p><p>linux:</p><p>valgrind</p>]]></content>
      
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTTPS</title>
      <link href="/2023/06/27/https/"/>
      <url>/2023/06/27/https/</url>
      
        <content type="html"><![CDATA[<h1 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h1><h2 id="一、HTTP-和-HTTPS-的基本概念"><a href="#一、HTTP-和-HTTPS-的基本概念" class="headerlink" title="一、HTTP 和 HTTPS 的基本概念"></a>一、HTTP 和 HTTPS 的基本概念</h2><p>HTTP：超文本传输协议（HTTP，HyperText Transfer Protocol）是互联网上应用最为广泛的一种网络协议。设计 HTTP 最初的目的是为了提供一种发布和接收 HTML 页面的方法。它可以使浏览器更加高效。HTTP 协议是以明文方式发送信息的，如果黑客截取了 Web 浏览器和服务器之间的传输报文，就可以直接获得其中的信息。</p><h3 id="HTTP-原理："><a href="#HTTP-原理：" class="headerlink" title="HTTP 原理："></a>HTTP 原理：</h3><p>①  客户端的浏览器首先要通过网络与服务器建立连接，该连接是通过 TCP 来完成的，一般 TCP 连接的端口号是80。 建立连接后，客户机发送一个请求给服务器，请求方式的格式为：统一资源标识符（URI）、协议版本号，后边是 MIME 信息包括请求修饰符、客户机信息和许可内容。</p><p>②  服务器接到请求后，给予相应的响应信息，其格式为一个状态行，包括信息的协议版本号、一个成功或错误的代码，后边是 MIME 信息包括服务器信息、实体信息和可能的内容。</p><h3 id="HTTPS："><a href="#HTTPS：" class="headerlink" title="HTTPS："></a>HTTPS：</h3><p>是以安全为目标的 HTTP 通道，是 HTTP 的安全版。HTTPS 的安全基础是 SSL。SSL 协议位于 TCP/IP 协议与各种应用层协议之间，为数据通讯提供安全支持。SSL 协议可分为两层：<strong>SSL 记录协议</strong>（SSL Record Protocol），它建立在可靠的传输协议（如TCP）之上，为高层协议提供数据封装、压缩、加密等基本功能的支持。<strong>SSL 握手协议</strong>（SSL Handshake Protocol），它建立在 SSL 记录协议之上，用于在实际的数据传输开始前，通讯双方进行身份认证、协商加密算法、交换加密密钥等。</p><p><img src="https://img-blog.csdnimg.cn/20200707084720409.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4Mjg5ODE1,size_16,color_FFFFFF,t_70" alt="img"></p><h3 id="HTTPS-设计目标："><a href="#HTTPS-设计目标：" class="headerlink" title="HTTPS 设计目标："></a>HTTPS 设计目标：</h3><p>(1) <strong>数据保密性</strong>：保证数据内容在传输的过程中不会被第三方查看。就像快递员传递包裹一样，都进行了封装，别人无法获知里面装了什么  。</p><p>(2) <strong>数据完整性</strong>：及时发现被第三方篡改的传输内容。就像快递员虽然不知道包裹里装了什么东西，但他有可能中途掉包，数据完整性就是指如果被掉包，我们能轻松发现并拒收 。</p><p>(3) <strong>身份校验安全性</strong>：保证数据到达用户期望的目的地。就像我们邮寄包裹时，虽然是一个封装好的未掉包的包裹，但必须确定这个包裹不会送错地方，通过身份校验来确保送对了地方  。</p><h2 id="二、HTTP-与-HTTPS-的区别"><a href="#二、HTTP-与-HTTPS-的区别" class="headerlink" title="二、HTTP 与 HTTPS  的区别"></a>二、HTTP 与 HTTPS  的区别</h2><p>1、HTTPS  协议需要到 CA （Certificate Authority，证书颁发机构）申请证书，一般免费证书较少，因而需要一定费用。(以前的网易官网是http，而网易邮箱是 https 。)</p><p>2、HTTP 是超文本传输协议，信息是明文传输，HTTPS 则是具有安全性的 SSL 加密传输协议。</p><p>3、HTTP 和 HTTPS 使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。</p><p>4、HTTP 的连接很简单，是无状态的。HTTPS 协议是由 SSL+HTTP 协议构建的可进行加密传输、身份认证的网络协议，比 HTTP 协议安全。(无状态的意思是其数据包的发送、传输和接收都是相互独立的。无连接的意思是指通信双方都不长久的维持对方的任何信息。)</p><h2 id="三、HTTPS-相对于-HTTP-的改进"><a href="#三、HTTPS-相对于-HTTP-的改进" class="headerlink" title="三、HTTPS 相对于 HTTP 的改进"></a>三、HTTPS 相对于 HTTP 的改进</h2><h3 id="双向的身份认证"><a href="#双向的身份认证" class="headerlink" title="双向的身份认证"></a>双向的身份认证</h3><p>客户端和服务端在传输数据之前，会通过基于X.509证书对双方进行身份认证 。具体过程如下：</p><ol><li><p>客户端发起 SSL 握手消息给服务端要求连接。</p></li><li><p>服务端将证书发送给客户端。</p></li><li><p>客户端检查服务端证书，确认是否由自己信任的证书签发机构签发(客户端内置了所有受信任 CA 的证书)。 如果不是，将是否继续通讯的决定权交给用户选择 ( 注意，这里将是一个安全缺陷 )。如果检查无误或者用户选择继续，则客户端认可服务端的身份。</p></li><li><p>服务端要求客户端发送证书，并检查是否通过验证。失败则关闭连接，认证成功则从客户端证书中获得客户端的公钥，一般为 1024 位或者 2048 位。到此，服务器客户端双方的身份认证结束，双方确保身份都是真实可靠的。</p></li></ol><p><strong>注意</strong>：</p><ol><li><p>采用 HTTPS 协议的服务器必须要有一套数字证书，可以自己制作，也可以向组织申请。区别就是自己颁发的证书需要客户端验证通过，才可以继续访问。这套证书其实就是一对公钥和私钥。</p></li><li><p>互联网有太多的服务需要使用证书来验证身份，以至于客户端（操作系统或浏览器等）无法内置所有证书，需要通过服务端将证书发送给客户端。</p></li><li><p>客户端内置的是 CA 的根证书(Root Certificate)，HTTPS 协议中服务器会发送证书链（Certificate Chain）给客户端。</p></li></ol><h3 id="数据传输的机密性"><a href="#数据传输的机密性" class="headerlink" title="数据传输的机密性"></a>数据传输的机密性</h3><p>客户端和服务端在开始传输数据之前，会协商传输过程需要使用的加密算法。 客户端发送协商请求给服务端, 其中包含自己支持的非对成加密的密钥交换算法 ( 一般是RSA)，数据签名摘要算法 ( 一般是SHA或者MD5) ，加密传输数据的对称加密算法 ( 一般是DES)，以及加密密钥的长度。 服务端接收到消息之后，选中安全性最高的算法，并将选中的算法发送给客户端，完成协商。客户端生成随机的字符串，通过协商好的非对称加密算法，使用服务端的公钥对该字符串进行加密，发送给服务端。 服务端接收到之后，使用自己的私钥解密得到该字符串。在随后的数据传输当中，使用这个字符串作为密钥进行对称加密。</p><h3 id="防止重放攻击"><a href="#防止重放攻击" class="headerlink" title="防止重放攻击"></a>防止重放攻击</h3><p>SSL 使用序列号来保护通讯方免受报文重放攻击。这个序列号被加密后作为数据包的负载。在整个 SSL 握手中，都有一个唯一的随机数来标记 SSL 握手。 这样防止了攻击者嗅探整个登录过程，获取到加密的登录数据之后，不对数据进行解密，而直接重传登录数据包的攻击手法。</p><p>可以看到，鉴于电子商务等安全上的需求，HTTPS 对比 HTTP 协议，在安全方面已经取得了极大的增强。总结来说，HTTPS 的改进点在于创造性的使用了非对称加密算法，在不安全的网路上，安全的传输了用来进行非对称加密的密钥，综合利用了非对称加密的安全性和对称加密的快速性。</p><h2 id="四、HTTPS-的优点"><a href="#四、HTTPS-的优点" class="headerlink" title="四、HTTPS 的优点"></a>四、HTTPS 的优点</h2><ol><li><p>使用 HTTPS 协议可认证用户和服务器，确保数据发送到正确的客户机和服务器。</p></li><li><p>HTTPS 协议是由SSL+HTTP 协议构建的可进行加密传输、身份认证的网络协议，要比 HTTP 协议安全，可防止数据在传输过程中不被窃取、修改，确保数据的完整性。</p></li><li><p>HTTPS 是现行架构下最安全的解决方案，虽然不是绝对安全，但它大幅增加了中间人攻击的成本。</p></li></ol><h2 id="五、HTTPS-的缺点（对比优点）"><a href="#五、HTTPS-的缺点（对比优点）" class="headerlink" title="五、HTTPS 的缺点（对比优点）"></a>五、HTTPS 的缺点（对比优点）</h2><ol><li><p>HTTPS 协议握手阶段比较费时，会使页面的加载时间延长近。</p></li><li><p>HTTPS 连接缓存不如 HTTP 高效，会增加数据开销，甚至已有的安全措施也会因此而受到影响。</p></li><li><p>HTTPS 协议的安全是有范围的，在黑客攻击、拒绝服务攻击和服务器劫持等方面几乎起不到什么作用。</p></li><li><p>SSL 证书通常需要绑定 IP，不能在同一 IP 上绑定多个域名，IPv4 资源不可能支撑这个消耗。</p></li><li><p>成本增加。部署 HTTPS 后，因为 HTTPS 协议的工作要增加额外的计算资源消耗，例如 SSL 协议加密算法和 SSL 交互次数将占用一定的计算资源和服务器成本。</p></li><li><p>HTTPS 协议的加密范围也比较有限。最关键的，SSL 证书的信用链体系并不安全，特别是在某些国家可以控制 CA 根证书的情况下，中间人攻击一样可行。</p></li></ol><h2 id="六、HTTPS-的连接过程-四次握手"><a href="#六、HTTPS-的连接过程-四次握手" class="headerlink" title="六、HTTPS 的连接过程(四次握手)"></a>六、HTTPS 的连接过程(四次握手)</h2><p><img src="https://img-blog.csdn.net/20160908113751341" alt="img"></p><p><img src="https://img-blog.csdn.net/20180709141944471?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4Mjg5ODE1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p><p>图片中的过程是按 8 个步骤分的，但是网上有更详细的步骤，所以我把详细的过程和这个图片配在一起。</p><p>① 客户端的浏览器向服务器发送请求，并传送客户端 SSL 协议的版本号，加密算法的种类，产生的随机数，以及其他服务器和客户端之间通讯所需要的各种信息。</p><p>② 服务器向客户端传送 SSL 协议的版本号，加密算法的种类，随机数以及其他相关信息，同时服务器还将向客户端传送自己的证书。</p><p>③ 客户端利用服务器传过来的信息验证服务器的合法性，服务器的合法性包括：证书是否过期，发行服务器证书的 CA 是否可靠，发行者证书的公钥能否正确解开服务器证书的 “发行者的数字签名”，服务器证书上的域名是否和服务器的实际域名相匹配。如果合法性验证没有通过，通讯将断开；如果合法性验证通过，将继续进行第四步。</p><p>④ 用户端随机产生一个用于通讯的 “对称密码”，然后用服务器的公钥（服务器的公钥从步骤②中的服务器的证书中获得）对其加密，然后将加密后的“预主密码”传给服务器。</p><p>⑤ 如果服务器要求客户的身份认证（在握手过程中为可选），用户可以建立一个随机数然后对其进行数据签名，将这个含有签名的随机数和客户自己的证书以及加密过的密钥一起传给服务器。</p><p>⑥ 如果服务器要求客户的身份认证，服务器必须检验客户证书和签名随机数的合法性，具体的合法性验证过程包括：客户的证书使用日期是否有效，为客户提供证书的 CA  是否可靠，发行 CA 的公钥能否正确解开客户证书的发行 CA 的数字签名，检查客户的证书是否在证书废止列表（CRL）中。检验如果没有通过，通讯立刻中断；如果验证通过，服务器将用自己的私钥解开加密的私钥，然后执行一系列步骤来产生主通讯密码（客户端也将通过同样的方法产生相同的主通讯密码）。</p><p>⑦ 服务器和客户端用相同的对称加密密钥，对称密钥用于 SSL 协议的安全数据通讯的加解密通讯。同时在 SSL 通讯过程中还要完成数据通讯的完整性，防止数据通讯中的任何变化。</p><p>⑧ 客户端向服务器端发出信息，指明后面的数据通讯将使用的步骤 ⑦ 中的主密码为对称密钥，同时通知服务器客户端的握手过程结束。</p><p>⑨ 服务器向客户端发出信息，指明后面的数据通讯将使用的步骤 ⑦ 中的主密码为对称密钥，同时通知客户端服务器端的握手过程结束。</p><p>⑩ SSL 的握手部分结束，SSL 安全通道的数据通讯开始，客户和服务器开始使用相同的对称密钥进行数据通讯，同时进行通讯完整性的检验。</p><h3 id="上述的过程需要弄懂的核心思想"><a href="#上述的过程需要弄懂的核心思想" class="headerlink" title="上述的过程需要弄懂的核心思想"></a><strong>上述的过程需要弄懂的核心思想</strong></h3><p><strong>客户端解析证书</strong></p><p>这部分工作是由客户端的 TLS 来完成的，首先会验证公钥是否有效，比如颁发机构，过期时间等等，如果发现异常，则会弹出一个警告框，提示证书存在问题。如果证书没有问题，那么就生成一个对称加密密钥，然后用公钥对该密钥进行非对称加密。</p><p><strong>传送加密信息</strong></p><p>这部分传送的是用公钥加密后的对称加密密钥，目的就是让服务端得到这个密钥，以后客户端和服务端的通信就可以通过这个密钥来进行加密解密了。</p><p><strong>服务端解密信息</strong></p><p>服务端用非对称加密算法里的私钥解密后，得到了客户端传过来的对称加密算法的私钥，然后把之后传输的内容通过该值进行对称加密。</p><p><strong>为什么用非对称加密协商对称加密密钥</strong></p><p>对称加密的特点：对称密码体制中只有一种密钥，并且是非公开的。如果要解密就得让对方知道密钥，所以想要保证其安全性就要保证密钥的安全。</p><p>非对称加密的特点：算法强度复杂、安全性依赖于算法与密钥但是由于其算法复杂，而使得加密解密速度没有对称加密解密的速度快。非对称密钥体制有两种密钥，其中一个是公开的，这样就可以不需要像对称密码那样传输对方的密钥了，这样安全性就大了很多。</p><p>非对称加密公钥和私钥的使用方法：</p><p>(1) 公钥加密私钥解密。</p><p>(2) 私钥做数字签名，公钥验证。</p><h3 id="补充："><a href="#补充：" class="headerlink" title="补充："></a>补充：</h3><p><strong>SSL 提供服务</strong></p><ol><li><p>认证用户和服务器，确保数据发送到正确的客户机和服务器；</p></li><li><p>加密数据以防止数据中途被窃取；</p></li><li><p>维护数据的完整性，确保数据在传输过程中不被改变。</p></li></ol><p><strong>SSL 工作流程</strong><br><strong>服务器认证阶段：</strong></p><ol><li><p>客户端向服务器发送一个开始信息 “Hello” 以便开始一个新的会话连接；</p></li><li><p>服务器根据客户的信息确定是否需要生成新的主密钥，如需要则服务器在响应客户的 “Hello” 信息时将包含生成主密钥所需的信息；</p></li><li><p>客户根据收到的服务器响应信息，产生一个主密钥，并用服务器的公开密钥加密后传给服务器；</p></li><li><p>服务器回复该主密钥，并返回给客户一个用主密钥认证的信息，以此让客户认证服务器。</p></li></ol><p><strong>用户认证阶段：</strong></p><p>在此之前，服务器已经通过了客户认证，这一阶段主要完成对客户的认证。经认证的服务器发送一个提问给客户，客户则返回（数字）签名后的提问和其公开密钥，从而向服务器提供认证。</p><p><strong>SSL 协议提供的安全通道有以下三个特性：</strong></p><p><strong>机密性</strong>：SSL 协议使用密钥加密通信数据。</p><p><strong>可靠性</strong>：服务器和客户都会被认证，客户的认证是可选的。</p><p><strong>完整性</strong>：SSL 协议会对传送的数据进行完整性检查。</p><p>服务器证书(server certificates)是 SSL 数字证书的一种形式，意指通过提交数字证书来证明您的身份或表明您有权访问在线服务。再者简单来说，通过使用服务器证书可为不同站点提供身份鉴定并保证该站点拥有高强度加密安全。是组成 Web 服务器的 SSL 安全功能的唯一的数字标识。通过相互信任的第三方组织获得，并为用户提供验证您 Web 站点身份的手段。服务器证书包含详细的身份验证信息，如服务器内容附属的组织、颁发证书的组织以及称为公开密钥的唯一的身份验证文件。</p>]]></content>
      
      
      
        <tags>
            
            <tag> HTTPS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++</title>
      <link href="/2023/06/27/c/"/>
      <url>/2023/06/27/c/</url>
      
        <content type="html"><![CDATA[<h1 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h1><p>对于一个空类，编译器默认生成四个成员函数：默认构造函数、析构函数、拷贝构造函数、赋值函数。</p><p>全局对象和静态对象的构造函数在main()函数执行之前就被调用，局部静态对象的构造函数是当程序第一次执行到相应语句时才被调用。</p><p>默认的析构函数不能删除new运算符在自由存储器中分配的对象或对象成员。如果类成员占用的空间是在构造函数中动态分配的，我们就必须自定义析构函数，然后显式使用delete运算符来释放构造函数使用new运算符分配的内存，就像销毁普通变量一样</p><p>当用一个已初始化过了的对象去初始化另一个新构造的对象的时候，拷贝构造函数就会被自动调用。也就是说，当类的对象需要拷贝时，拷贝构造函数将会被调用。以下情况都会调用拷贝构造函数：</p><p>​     一个对象以值传递的方式传入函数体</p><p>​     一个对象以值传递的方式从函数返回</p><p>​     一个对象需要通过另外一个对象进行初始化。</p><p>浅拷贝和深拷贝</p><p>　 在某些状况下，类内成员变量需要动态开辟堆内存，如果实行位拷贝，也就是把对象里的值完全复制给另一个对象，如A=B。这时，如果B中有一个成员变量指针已经申请了内存，那A中的那个成员变量也指向同一块内存。这就出现了问题：当B把内存释放了（如：析构），这时A内的指针就是野指针了，出现运行错误。</p><p>　　深拷贝和浅拷贝可以简单理解为：如果一个类拥有资源，当这个类的对象发生复制过程的时候，资源重新分配，这个过程就是深拷贝，反之，没有重新分配资源，就是浅拷贝。</p><p>拷贝构造函数和赋值函数非常容易混淆，常导致错写、错用。拷贝构造函数是在对象被创建时调用的，而赋值函数只能被已经存在了的对象调用</p><p>常量左值引用既可以操作左值，也可以操作右值。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> num <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span><span class="token keyword">int</span> num <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token operator">&amp;</span>b <span class="token operator">=</span> num<span class="token punctuation">;</span> <span class="token comment">//正确</span><span class="token keyword">int</span> <span class="token operator">&amp;</span>c <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span> <span class="token comment">//错误</span><span class="token keyword">const</span> <span class="token keyword">int</span> <span class="token operator">&amp;</span>b <span class="token operator">=</span> num<span class="token punctuation">;</span><span class="token keyword">const</span> <span class="token keyword">int</span> <span class="token operator">&amp;</span>c <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>需要对右值进行修改（实现移动语义时就需要），显然左值引用的方式是行不通的。</p><p>和声明左值引用一样，右值引用也必须立即进行初始化操作，且只能使用右值进行初始化，</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> num <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span><span class="token comment">//int &amp;&amp; a = num;  //右值引用不能初始化为左值</span><span class="token keyword">int</span> <span class="token operator">&amp;&amp;</span> a <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>和常量左值引用不同的是，右值引用还可以对右值进行修改。</p><p>支持定义常量右值引用的。</p><p>但这种定义出来的右值引用并无实际用处。一方面，右值引用主要用于移动语义和完美转发，其中前者需要有修改右值的权限；其次，常量右值引用的作用就是引用一个不可修改的右值，这项工作完全可以交给常量左值引用完成。</p><p>move语义，将某个左值强制转化为右值。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">move</span><span class="token punctuation">(</span> arg <span class="token punctuation">)</span> <span class="token comment">//其中，arg 表示指定的左值对象。该函数会返回 arg 对象的右值形式。</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol><li><p>智能指针发生内存泄露的情况</p><p>  当两个对象同时使用一个shared_ptr成员变量指向对方，会造成循环引用，使引用计数失效，从而导致内存泄露。</p></li><li><p>智能指针的内存泄漏如何解决？ 为了解决循环引用导致的内存泄漏，引入了弱指针weak_ptr，weak_ptr的构造函数不会修改引用计数的值，从而不会对对象的内存进行管理，其类似一个普通指针，但是不会指向引用计数的共享内存，但是可以检测到所管理的对象是否已经被释放，从而避免非法访问。</p></li></ol><p><strong>weak_ptr 设计的目的是为配合 shared_ptr 而引入的一种智能指针来协助 shared_ptr 工作，它只可以从一个 shared_ptr 或另一个 weak_ptr 对象构造,</strong> <strong>它的构造和析构不会引起引用记数的增加或减少。</strong></p><p><strong>互斥锁用lock_guard类模板，它的内部结构很简单，只有构造函数和析构函数，所以也很容里理解它的工作原理，在实例化对象时通过构造函数实现了lock，在析构函数中实现了unlock的操作。这样就可以避免忘记unlock的情况这样就在每次循环一次后会自动的构建互斥锁对象，循环完了就会析构掉这个互斥锁。当然为了使用的更灵活方便，我们可以通过大括号来规定实现的范围。</strong></p>]]></content>
      
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>gta</title>
      <link href="/2023/06/24/gta/"/>
      <url>/2023/06/24/gta/</url>
      
        <content type="html"><![CDATA[<h1 id="GTA精彩分享"><a href="#GTA精彩分享" class="headerlink" title="GTA精彩分享"></a>GTA精彩分享</h1><h2 id="精彩采集图片"><a href="#精彩采集图片" class="headerlink" title="精彩采集图片"></a>精彩采集图片</h2><p><img src="https://img1.mydrivers.com/img/20180626/489364e6875a465f883dc906fc93c7d0.jpg"></p><h1 id="GTA视频"><a href="#GTA视频" class="headerlink" title="GTA视频"></a>GTA视频</h1><iframe src="//player.bilibili.com/player.html?aid=257749269&amp;bvid=BV1HY411N7Rj&amp;cid=750796847&amp;page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe><h1 id="GTA游戏视频"><a href="#GTA游戏视频" class="headerlink" title="GTA游戏视频"></a>GTA游戏视频</h1><iframe src="//player.bilibili.com/player.html?aid=519951669&amp;bvid=BV1Ng411s76P&amp;cid=956824098&amp;page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe>]]></content>
      
      
      
        <tags>
            
            <tag> game </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2023/06/23/hello-world/"/>
      <url>/2023/06/23/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo server<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo generate<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo deploy<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> web </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
