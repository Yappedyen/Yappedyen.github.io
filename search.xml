<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>HTTPS</title>
      <link href="/2023/06/27/https/"/>
      <url>/2023/06/27/https/</url>
      
        <content type="html"><![CDATA[<h1 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h1><h2 id="一、HTTP-和-HTTPS-的基本概念"><a href="#一、HTTP-和-HTTPS-的基本概念" class="headerlink" title="一、HTTP 和 HTTPS 的基本概念"></a>一、HTTP 和 HTTPS 的基本概念</h2><p>HTTP：超文本传输协议（HTTP，HyperText Transfer Protocol）是互联网上应用最为广泛的一种网络协议。设计 HTTP 最初的目的是为了提供一种发布和接收 HTML 页面的方法。它可以使浏览器更加高效。HTTP 协议是以明文方式发送信息的，如果黑客截取了 Web 浏览器和服务器之间的传输报文，就可以直接获得其中的信息。</p><h3 id="HTTP-原理："><a href="#HTTP-原理：" class="headerlink" title="HTTP 原理："></a>HTTP 原理：</h3><p>①  客户端的浏览器首先要通过网络与服务器建立连接，该连接是通过 TCP 来完成的，一般 TCP 连接的端口号是80。 建立连接后，客户机发送一个请求给服务器，请求方式的格式为：统一资源标识符（URI）、协议版本号，后边是 MIME 信息包括请求修饰符、客户机信息和许可内容。</p><p>②  服务器接到请求后，给予相应的响应信息，其格式为一个状态行，包括信息的协议版本号、一个成功或错误的代码，后边是 MIME 信息包括服务器信息、实体信息和可能的内容。</p><h3 id="HTTPS："><a href="#HTTPS：" class="headerlink" title="HTTPS："></a>HTTPS：</h3><p>是以安全为目标的 HTTP 通道，是 HTTP 的安全版。HTTPS 的安全基础是 SSL。SSL 协议位于 TCP/IP 协议与各种应用层协议之间，为数据通讯提供安全支持。SSL 协议可分为两层：<strong>SSL 记录协议</strong>（SSL Record Protocol），它建立在可靠的传输协议（如TCP）之上，为高层协议提供数据封装、压缩、加密等基本功能的支持。<strong>SSL 握手协议</strong>（SSL Handshake Protocol），它建立在 SSL 记录协议之上，用于在实际的数据传输开始前，通讯双方进行身份认证、协商加密算法、交换加密密钥等。</p><p><img src="https://img-blog.csdnimg.cn/20200707084720409.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4Mjg5ODE1,size_16,color_FFFFFF,t_70" alt="img"></p><h3 id="HTTPS-设计目标："><a href="#HTTPS-设计目标：" class="headerlink" title="HTTPS 设计目标："></a>HTTPS 设计目标：</h3><p>(1) <strong>数据保密性</strong>：保证数据内容在传输的过程中不会被第三方查看。就像快递员传递包裹一样，都进行了封装，别人无法获知里面装了什么  。</p><p>(2) <strong>数据完整性</strong>：及时发现被第三方篡改的传输内容。就像快递员虽然不知道包裹里装了什么东西，但他有可能中途掉包，数据完整性就是指如果被掉包，我们能轻松发现并拒收 。</p><p>(3) <strong>身份校验安全性</strong>：保证数据到达用户期望的目的地。就像我们邮寄包裹时，虽然是一个封装好的未掉包的包裹，但必须确定这个包裹不会送错地方，通过身份校验来确保送对了地方  。</p><h2 id="二、HTTP-与-HTTPS-的区别"><a href="#二、HTTP-与-HTTPS-的区别" class="headerlink" title="二、HTTP 与 HTTPS  的区别"></a>二、HTTP 与 HTTPS  的区别</h2><p>1、HTTPS  协议需要到 CA （Certificate Authority，证书颁发机构）申请证书，一般免费证书较少，因而需要一定费用。(以前的网易官网是http，而网易邮箱是 https 。)</p><p>2、HTTP 是超文本传输协议，信息是明文传输，HTTPS 则是具有安全性的 SSL 加密传输协议。</p><p>3、HTTP 和 HTTPS 使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。</p><p>4、HTTP 的连接很简单，是无状态的。HTTPS 协议是由 SSL+HTTP 协议构建的可进行加密传输、身份认证的网络协议，比 HTTP 协议安全。(无状态的意思是其数据包的发送、传输和接收都是相互独立的。无连接的意思是指通信双方都不长久的维持对方的任何信息。)</p><h2 id="三、HTTPS-相对于-HTTP-的改进"><a href="#三、HTTPS-相对于-HTTP-的改进" class="headerlink" title="三、HTTPS 相对于 HTTP 的改进"></a>三、HTTPS 相对于 HTTP 的改进</h2><h3 id="双向的身份认证"><a href="#双向的身份认证" class="headerlink" title="双向的身份认证"></a>双向的身份认证</h3><p>客户端和服务端在传输数据之前，会通过基于X.509证书对双方进行身份认证 。具体过程如下：</p><ol><li><p>客户端发起 SSL 握手消息给服务端要求连接。</p></li><li><p>服务端将证书发送给客户端。</p></li><li><p>客户端检查服务端证书，确认是否由自己信任的证书签发机构签发(客户端内置了所有受信任 CA 的证书)。 如果不是，将是否继续通讯的决定权交给用户选择 ( 注意，这里将是一个安全缺陷 )。如果检查无误或者用户选择继续，则客户端认可服务端的身份。</p></li><li><p>服务端要求客户端发送证书，并检查是否通过验证。失败则关闭连接，认证成功则从客户端证书中获得客户端的公钥，一般为 1024 位或者 2048 位。到此，服务器客户端双方的身份认证结束，双方确保身份都是真实可靠的。</p></li></ol><p><strong>注意</strong>：</p><ol><li><p>采用 HTTPS 协议的服务器必须要有一套数字证书，可以自己制作，也可以向组织申请。区别就是自己颁发的证书需要客户端验证通过，才可以继续访问。这套证书其实就是一对公钥和私钥。</p></li><li><p>互联网有太多的服务需要使用证书来验证身份，以至于客户端（操作系统或浏览器等）无法内置所有证书，需要通过服务端将证书发送给客户端。</p></li><li><p>客户端内置的是 CA 的根证书(Root Certificate)，HTTPS 协议中服务器会发送证书链（Certificate Chain）给客户端。</p></li></ol><h3 id="数据传输的机密性"><a href="#数据传输的机密性" class="headerlink" title="数据传输的机密性"></a>数据传输的机密性</h3><p>客户端和服务端在开始传输数据之前，会协商传输过程需要使用的加密算法。 客户端发送协商请求给服务端, 其中包含自己支持的非对成加密的密钥交换算法 ( 一般是RSA)，数据签名摘要算法 ( 一般是SHA或者MD5) ，加密传输数据的对称加密算法 ( 一般是DES)，以及加密密钥的长度。 服务端接收到消息之后，选中安全性最高的算法，并将选中的算法发送给客户端，完成协商。客户端生成随机的字符串，通过协商好的非对称加密算法，使用服务端的公钥对该字符串进行加密，发送给服务端。 服务端接收到之后，使用自己的私钥解密得到该字符串。在随后的数据传输当中，使用这个字符串作为密钥进行对称加密。</p><h3 id="防止重放攻击"><a href="#防止重放攻击" class="headerlink" title="防止重放攻击"></a>防止重放攻击</h3><p>SSL 使用序列号来保护通讯方免受报文重放攻击。这个序列号被加密后作为数据包的负载。在整个 SSL 握手中，都有一个唯一的随机数来标记 SSL 握手。 这样防止了攻击者嗅探整个登录过程，获取到加密的登录数据之后，不对数据进行解密，而直接重传登录数据包的攻击手法。</p><p>可以看到，鉴于电子商务等安全上的需求，HTTPS 对比 HTTP 协议，在安全方面已经取得了极大的增强。总结来说，HTTPS 的改进点在于创造性的使用了非对称加密算法，在不安全的网路上，安全的传输了用来进行非对称加密的密钥，综合利用了非对称加密的安全性和对称加密的快速性。</p><h2 id="四、HTTPS-的优点"><a href="#四、HTTPS-的优点" class="headerlink" title="四、HTTPS 的优点"></a>四、HTTPS 的优点</h2><ol><li><p>使用 HTTPS 协议可认证用户和服务器，确保数据发送到正确的客户机和服务器。</p></li><li><p>HTTPS 协议是由SSL+HTTP 协议构建的可进行加密传输、身份认证的网络协议，要比 HTTP 协议安全，可防止数据在传输过程中不被窃取、修改，确保数据的完整性。</p></li><li><p>HTTPS 是现行架构下最安全的解决方案，虽然不是绝对安全，但它大幅增加了中间人攻击的成本。</p></li></ol><h2 id="五、HTTPS-的缺点（对比优点）"><a href="#五、HTTPS-的缺点（对比优点）" class="headerlink" title="五、HTTPS 的缺点（对比优点）"></a>五、HTTPS 的缺点（对比优点）</h2><ol><li><p>HTTPS 协议握手阶段比较费时，会使页面的加载时间延长近。</p></li><li><p>HTTPS 连接缓存不如 HTTP 高效，会增加数据开销，甚至已有的安全措施也会因此而受到影响。</p></li><li><p>HTTPS 协议的安全是有范围的，在黑客攻击、拒绝服务攻击和服务器劫持等方面几乎起不到什么作用。</p></li><li><p>SSL 证书通常需要绑定 IP，不能在同一 IP 上绑定多个域名，IPv4 资源不可能支撑这个消耗。</p></li><li><p>成本增加。部署 HTTPS 后，因为 HTTPS 协议的工作要增加额外的计算资源消耗，例如 SSL 协议加密算法和 SSL 交互次数将占用一定的计算资源和服务器成本。</p></li><li><p>HTTPS 协议的加密范围也比较有限。最关键的，SSL 证书的信用链体系并不安全，特别是在某些国家可以控制 CA 根证书的情况下，中间人攻击一样可行。</p></li></ol><h2 id="六、HTTPS-的连接过程-四次握手"><a href="#六、HTTPS-的连接过程-四次握手" class="headerlink" title="六、HTTPS 的连接过程(四次握手)"></a>六、HTTPS 的连接过程(四次握手)</h2><p><img src="https://img-blog.csdn.net/20160908113751341" alt="img"></p><p><img src="https://img-blog.csdn.net/20180709141944471?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4Mjg5ODE1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p><p>图片中的过程是按 8 个步骤分的，但是网上有更详细的步骤，所以我把详细的过程和这个图片配在一起。</p><p>① 客户端的浏览器向服务器发送请求，并传送客户端 SSL 协议的版本号，加密算法的种类，产生的随机数，以及其他服务器和客户端之间通讯所需要的各种信息。</p><p>② 服务器向客户端传送 SSL 协议的版本号，加密算法的种类，随机数以及其他相关信息，同时服务器还将向客户端传送自己的证书。</p><p>③ 客户端利用服务器传过来的信息验证服务器的合法性，服务器的合法性包括：证书是否过期，发行服务器证书的 CA 是否可靠，发行者证书的公钥能否正确解开服务器证书的 “发行者的数字签名”，服务器证书上的域名是否和服务器的实际域名相匹配。如果合法性验证没有通过，通讯将断开；如果合法性验证通过，将继续进行第四步。</p><p>④ 用户端随机产生一个用于通讯的 “对称密码”，然后用服务器的公钥（服务器的公钥从步骤②中的服务器的证书中获得）对其加密，然后将加密后的“预主密码”传给服务器。</p><p>⑤ 如果服务器要求客户的身份认证（在握手过程中为可选），用户可以建立一个随机数然后对其进行数据签名，将这个含有签名的随机数和客户自己的证书以及加密过的密钥一起传给服务器。</p><p>⑥ 如果服务器要求客户的身份认证，服务器必须检验客户证书和签名随机数的合法性，具体的合法性验证过程包括：客户的证书使用日期是否有效，为客户提供证书的 CA  是否可靠，发行 CA 的公钥能否正确解开客户证书的发行 CA 的数字签名，检查客户的证书是否在证书废止列表（CRL）中。检验如果没有通过，通讯立刻中断；如果验证通过，服务器将用自己的私钥解开加密的私钥，然后执行一系列步骤来产生主通讯密码（客户端也将通过同样的方法产生相同的主通讯密码）。</p><p>⑦ 服务器和客户端用相同的对称加密密钥，对称密钥用于 SSL 协议的安全数据通讯的加解密通讯。同时在 SSL 通讯过程中还要完成数据通讯的完整性，防止数据通讯中的任何变化。</p><p>⑧ 客户端向服务器端发出信息，指明后面的数据通讯将使用的步骤 ⑦ 中的主密码为对称密钥，同时通知服务器客户端的握手过程结束。</p><p>⑨ 服务器向客户端发出信息，指明后面的数据通讯将使用的步骤 ⑦ 中的主密码为对称密钥，同时通知客户端服务器端的握手过程结束。</p><p>⑩ SSL 的握手部分结束，SSL 安全通道的数据通讯开始，客户和服务器开始使用相同的对称密钥进行数据通讯，同时进行通讯完整性的检验。</p><h3 id="上述的过程需要弄懂的核心思想"><a href="#上述的过程需要弄懂的核心思想" class="headerlink" title="上述的过程需要弄懂的核心思想"></a><strong>上述的过程需要弄懂的核心思想</strong></h3><p><strong>客户端解析证书</strong></p><p>这部分工作是由客户端的 TLS 来完成的，首先会验证公钥是否有效，比如颁发机构，过期时间等等，如果发现异常，则会弹出一个警告框，提示证书存在问题。如果证书没有问题，那么就生成一个对称加密密钥，然后用公钥对该密钥进行非对称加密。</p><p><strong>传送加密信息</strong></p><p>这部分传送的是用公钥加密后的对称加密密钥，目的就是让服务端得到这个密钥，以后客户端和服务端的通信就可以通过这个密钥来进行加密解密了。</p><p><strong>服务端解密信息</strong></p><p>服务端用非对称加密算法里的私钥解密后，得到了客户端传过来的对称加密算法的私钥，然后把之后传输的内容通过该值进行对称加密。</p><p><strong>为什么用非对称加密协商对称加密密钥</strong></p><p>对称加密的特点：对称密码体制中只有一种密钥，并且是非公开的。如果要解密就得让对方知道密钥，所以想要保证其安全性就要保证密钥的安全。</p><p>非对称加密的特点：算法强度复杂、安全性依赖于算法与密钥但是由于其算法复杂，而使得加密解密速度没有对称加密解密的速度快。非对称密钥体制有两种密钥，其中一个是公开的，这样就可以不需要像对称密码那样传输对方的密钥了，这样安全性就大了很多。</p><p>非对称加密公钥和私钥的使用方法：</p><p>(1) 公钥加密私钥解密。</p><p>(2) 私钥做数字签名，公钥验证。</p><h3 id="补充："><a href="#补充：" class="headerlink" title="补充："></a>补充：</h3><p><strong>SSL 提供服务</strong></p><ol><li><p>认证用户和服务器，确保数据发送到正确的客户机和服务器；</p></li><li><p>加密数据以防止数据中途被窃取；</p></li><li><p>维护数据的完整性，确保数据在传输过程中不被改变。</p></li></ol><p><strong>SSL 工作流程</strong><br><strong>服务器认证阶段：</strong></p><ol><li><p>客户端向服务器发送一个开始信息 “Hello” 以便开始一个新的会话连接；</p></li><li><p>服务器根据客户的信息确定是否需要生成新的主密钥，如需要则服务器在响应客户的 “Hello” 信息时将包含生成主密钥所需的信息；</p></li><li><p>客户根据收到的服务器响应信息，产生一个主密钥，并用服务器的公开密钥加密后传给服务器；</p></li><li><p>服务器回复该主密钥，并返回给客户一个用主密钥认证的信息，以此让客户认证服务器。</p></li></ol><p><strong>用户认证阶段：</strong></p><p>在此之前，服务器已经通过了客户认证，这一阶段主要完成对客户的认证。经认证的服务器发送一个提问给客户，客户则返回（数字）签名后的提问和其公开密钥，从而向服务器提供认证。</p><p><strong>SSL 协议提供的安全通道有以下三个特性：</strong></p><p><strong>机密性</strong>：SSL 协议使用密钥加密通信数据。</p><p><strong>可靠性</strong>：服务器和客户都会被认证，客户的认证是可选的。</p><p><strong>完整性</strong>：SSL 协议会对传送的数据进行完整性检查。</p><p>服务器证书(server certificates)是 SSL 数字证书的一种形式，意指通过提交数字证书来证明您的身份或表明您有权访问在线服务。再者简单来说，通过使用服务器证书可为不同站点提供身份鉴定并保证该站点拥有高强度加密安全。是组成 Web 服务器的 SSL 安全功能的唯一的数字标识。通过相互信任的第三方组织获得，并为用户提供验证您 Web 站点身份的手段。服务器证书包含详细的身份验证信息，如服务器内容附属的组织、颁发证书的组织以及称为公开密钥的唯一的身份验证文件。</p>]]></content>
      
      
      
        <tags>
            
            <tag> HTTPS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++</title>
      <link href="/2023/06/27/c/"/>
      <url>/2023/06/27/c/</url>
      
        <content type="html"><![CDATA[<h1 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h1><p>对于一个空类，编译器默认生成四个成员函数：默认构造函数、析构函数、拷贝构造函数、赋值函数。</p><p>全局对象和静态对象的构造函数在main()函数执行之前就被调用，局部静态对象的构造函数是当程序第一次执行到相应语句时才被调用。</p><p>默认的析构函数不能删除new运算符在自由存储器中分配的对象或对象成员。如果类成员占用的空间是在构造函数中动态分配的，我们就必须自定义析构函数，然后显式使用delete运算符来释放构造函数使用new运算符分配的内存，就像销毁普通变量一样</p><p>当用一个已初始化过了的对象去初始化另一个新构造的对象的时候，拷贝构造函数就会被自动调用。也就是说，当类的对象需要拷贝时，拷贝构造函数将会被调用。以下情况都会调用拷贝构造函数：</p><p>​     一个对象以值传递的方式传入函数体</p><p>​     一个对象以值传递的方式从函数返回</p><p>​     一个对象需要通过另外一个对象进行初始化。</p><p>浅拷贝和深拷贝</p><p>　 在某些状况下，类内成员变量需要动态开辟堆内存，如果实行位拷贝，也就是把对象里的值完全复制给另一个对象，如A=B。这时，如果B中有一个成员变量指针已经申请了内存，那A中的那个成员变量也指向同一块内存。这就出现了问题：当B把内存释放了（如：析构），这时A内的指针就是野指针了，出现运行错误。</p><p>　　深拷贝和浅拷贝可以简单理解为：如果一个类拥有资源，当这个类的对象发生复制过程的时候，资源重新分配，这个过程就是深拷贝，反之，没有重新分配资源，就是浅拷贝。</p><p>拷贝构造函数和赋值函数非常容易混淆，常导致错写、错用。拷贝构造函数是在对象被创建时调用的，而赋值函数只能被已经存在了的对象调用</p><p>常量左值引用既可以操作左值，也可以操作右值。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> num <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span><span class="token keyword">int</span> num <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token operator">&amp;</span>b <span class="token operator">=</span> num<span class="token punctuation">;</span> <span class="token comment">//正确</span><span class="token keyword">int</span> <span class="token operator">&amp;</span>c <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span> <span class="token comment">//错误</span><span class="token keyword">const</span> <span class="token keyword">int</span> <span class="token operator">&amp;</span>b <span class="token operator">=</span> num<span class="token punctuation">;</span><span class="token keyword">const</span> <span class="token keyword">int</span> <span class="token operator">&amp;</span>c <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>需要对右值进行修改（实现移动语义时就需要），显然左值引用的方式是行不通的。</p><p>和声明左值引用一样，右值引用也必须立即进行初始化操作，且只能使用右值进行初始化，</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> num <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span><span class="token comment">//int &amp;&amp; a = num;  //右值引用不能初始化为左值</span><span class="token keyword">int</span> <span class="token operator">&amp;&amp;</span> a <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>和常量左值引用不同的是，右值引用还可以对右值进行修改。</p><p>支持定义常量右值引用的。</p><p>但这种定义出来的右值引用并无实际用处。一方面，右值引用主要用于移动语义和完美转发，其中前者需要有修改右值的权限；其次，常量右值引用的作用就是引用一个不可修改的右值，这项工作完全可以交给常量左值引用完成。</p><p>move语义，将某个左值强制转化为右值。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">move</span><span class="token punctuation">(</span> arg <span class="token punctuation">)</span> <span class="token comment">//其中，arg 表示指定的左值对象。该函数会返回 arg 对象的右值形式。</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol><li><p>智能指针发生内存泄露的情况</p><p>  当两个对象同时使用一个shared_ptr成员变量指向对方，会造成循环引用，使引用计数失效，从而导致内存泄露。</p></li><li><p>智能指针的内存泄漏如何解决？ 为了解决循环引用导致的内存泄漏，引入了弱指针weak_ptr，weak_ptr的构造函数不会修改引用计数的值，从而不会对对象的内存进行管理，其类似一个普通指针，但是不会指向引用计数的共享内存，但是可以检测到所管理的对象是否已经被释放，从而避免非法访问。</p></li></ol><p><strong>weak_ptr 设计的目的是为配合 shared_ptr 而引入的一种智能指针来协助 shared_ptr 工作，它只可以从一个 shared_ptr 或另一个 weak_ptr 对象构造,</strong> <strong>它的构造和析构不会引起引用记数的增加或减少。</strong></p><p><strong>互斥锁用lock_guard类模板，它的内部结构很简单，只有构造函数和析构函数，所以也很容里理解它的工作原理，在实例化对象时通过构造函数实现了lock，在析构函数中实现了unlock的操作。这样就可以避免忘记unlock的情况这样就在每次循环一次后会自动的构建互斥锁对象，循环完了就会析构掉这个互斥锁。当然为了使用的更灵活方便，我们可以通过大括号来规定实现的范围。</strong></p>]]></content>
      
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>gta</title>
      <link href="/2023/06/24/gta/"/>
      <url>/2023/06/24/gta/</url>
      
        <content type="html"><![CDATA[<h1 id="GTA精彩分享"><a href="#GTA精彩分享" class="headerlink" title="GTA精彩分享"></a>GTA精彩分享</h1><h2 id="精彩采集图片"><a href="#精彩采集图片" class="headerlink" title="精彩采集图片"></a>精彩采集图片</h2><p><img src="https://img1.mydrivers.com/img/20180626/489364e6875a465f883dc906fc93c7d0.jpg"></p><h1 id="GTA视频"><a href="#GTA视频" class="headerlink" title="GTA视频"></a>GTA视频</h1><iframe src="//player.bilibili.com/player.html?aid=257749269&amp;bvid=BV1HY411N7Rj&amp;cid=750796847&amp;page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe><h1 id="GTA游戏视频"><a href="#GTA游戏视频" class="headerlink" title="GTA游戏视频"></a>GTA游戏视频</h1><iframe src="//player.bilibili.com/player.html?aid=519951669&amp;bvid=BV1Ng411s76P&amp;cid=956824098&amp;page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe>]]></content>
      
      
      
        <tags>
            
            <tag> game </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2023/06/23/hello-world/"/>
      <url>/2023/06/23/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo server<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo generate<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo deploy<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> web </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
