<!DOCTYPE HTML>
<html lang="zh-CN">


<head>
    <meta charset="utf-8">
    <meta name="keywords" content="Pyenne">
    <meta name="description" content="MYSQLMySql下大数据量级别（1000万+）优化查询和操作方法1、应尽量避免在 where 子句中使用!=或&amp;lt;&amp;gt;操作符，否则将引擎放弃使用索引而进行全表扫描。
2、对查询进行优化，应尽量避免全表扫描，首先应考虑在 wher">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="referrer" content="no-referrer-when-downgrade">
    <!-- Global site tag (gtag.js) - Google Analytics -->


    <title>Pyenne</title>
    <link rel="icon" type="image/png" href="/favicon.png">
    


    <!-- bg-cover style     -->



<link rel="stylesheet" type="text/css" href="/libs/awesome/css/all.min.css">
<link rel="stylesheet" type="text/css" href="/libs/materialize/materialize.min.css">
<link rel="stylesheet" type="text/css" href="/libs/aos/aos.css">
<link rel="stylesheet" type="text/css" href="/libs/animate/animate.min.css">
<link rel="stylesheet" type="text/css" href="/libs/lightGallery/css/lightgallery.min.css">
<link rel="stylesheet" type="text/css" href="/css/matery.css">
<link rel="stylesheet" type="text/css" href="/css/my.css">
<link rel="stylesheet" type="text/css" href="/css/dark.css" media="none" onload="if(media!='all')media='all'">




    <link rel="stylesheet" href="/libs/tocbot/tocbot.css">
    <link rel="stylesheet" href="/css/post.css">




    



    <script src="/libs/jquery/jquery-3.6.0.min.js"></script>

<meta name="generator" content="Hexo 5.4.2">
<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
<link rel="alternate" href="/atom.xml" title="Pyenne" type="application/atom+xml">
</head>


<body>
    <header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="nav-wrapper container">
            <div class="brand-logo">
                <a href="/" class="waves-effect waves-light">
                    
                    <img src="/medias/logo.png" class="logo-img" alt="LOGO">
                    
                    <span class="logo-span">Pyenne</span>
                </a>
            </div>
            

<a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fas fa-bars"></i></a>
<ul class="right nav-menu">
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/" class="waves-effect waves-light">
      
      <i class="fas fa-home" style="zoom: 0.6;"></i>
      
      <span>首页</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/tags" class="waves-effect waves-light">
      
      <i class="fas fa-tags" style="zoom: 0.6;"></i>
      
      <span>标签</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/categories" class="waves-effect waves-light">
      
      <i class="fas fa-bookmark" style="zoom: 0.6;"></i>
      
      <span>分类</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/archives" class="waves-effect waves-light">
      
      <i class="fas fa-archive" style="zoom: 0.6;"></i>
      
      <span>归档</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/about" class="waves-effect waves-light">
      
      <i class="fas fa-user-circle" style="zoom: 0.6;"></i>
      
      <span>关于</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/contact" class="waves-effect waves-light">
      
      <i class="fas fa-comments" style="zoom: 0.6;"></i>
      
      <span>留言板</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/friends" class="waves-effect waves-light">
      
      <i class="fas fa-address-book" style="zoom: 0.6;"></i>
      
      <span>友情链接</span>
    </a>
    
  </li>
  
  <li>
    <a href="#searchModal" class="modal-trigger waves-effect waves-light">
      <i id="searchIcon" class="fas fa-search" title="搜索" style="zoom: 0.85;"></i>
    </a>
  </li>
  <li>
    <a href="javascript:;" class="waves-effect waves-light" onclick="switchNightMode()" title="深色/浅色模式" >
      <i id="sum-moon-icon" class="fas fa-sun" style="zoom: 0.85;"></i>
    </a>
  </li>
</ul>


<div id="mobile-nav" class="side-nav sidenav">

    <div class="mobile-head bg-color">
        
        <img src="/medias/logo.png" class="logo-img circle responsive-img">
        
        <div class="logo-name">Pyenne</div>
        <div class="logo-desc">
            
            Never really desperate, only the lost of the soul.
            
        </div>
    </div>

    <ul class="menu-list mobile-menu-list">
        
        <li class="m-nav-item">
	  
		<a href="/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-home"></i>
			
			首页
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/tags" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-tags"></i>
			
			标签
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/categories" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-bookmark"></i>
			
			分类
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/archives" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-archive"></i>
			
			归档
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/about" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-user-circle"></i>
			
			关于
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/contact" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-comments"></i>
			
			留言板
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/friends" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-address-book"></i>
			
			友情链接
		</a>
          
        </li>
        
        
        <li><div class="divider"></div></li>
        <li>
            <a href="https://github.com/blinkfox/hexo-theme-matery" class="waves-effect waves-light" target="_blank">
                <i class="fab fa-github-square fa-fw"></i>Fork Me
            </a>
        </li>
        
    </ul>
</div>


        </div>

        
            <style>
    .nav-transparent .github-corner {
        display: none !important;
    }

    .github-corner {
        position: absolute;
        z-index: 10;
        top: 0;
        right: 0;
        border: 0;
        transform: scale(1.1);
    }

    .github-corner svg {
        color: #0f9d58;
        fill: #fff;
        height: 64px;
        width: 64px;
    }

    .github-corner:hover .octo-arm {
        animation: a 0.56s ease-in-out;
    }

    .github-corner .octo-arm {
        animation: none;
    }

    @keyframes a {
        0%,
        to {
            transform: rotate(0);
        }
        20%,
        60% {
            transform: rotate(-25deg);
        }
        40%,
        80% {
            transform: rotate(10deg);
        }
    }
</style>

<a href="https://github.com/blinkfox/hexo-theme-matery" class="github-corner tooltipped hide-on-med-and-down" target="_blank"
   data-tooltip="Fork Me" data-position="left" data-delay="50">
    <svg viewBox="0 0 250 250" aria-hidden="true">
        <path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path>
        <path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2"
              fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path>
        <path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z"
              fill="currentColor" class="octo-body"></path>
    </svg>
</a>
        
    </nav>

</header>

    



<div class="bg-cover pd-header post-cover" style="background-image: url('/medias/featureimages/0.jpg')">
    <div class="container" style="right: 0px;left: 0px;">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <h1 class="description center-align post-title"></h1>
                </div>
            </div>
        </div>
    </div>
</div>




<main class="post-container content">

    
    <div class="row">
    <div id="main-content" class="col s12 m12 l9">
        <!-- 文章内容详情 -->
<div id="artDetail">
    <div class="card">
        <div class="card-content article-info">
            <div class="row tag-cate">
                <div class="col s7">
                    
                          <div class="article-tag">
                            <span class="chip bg-color">无标签</span>
                          </div>
                    
                </div>
                <div class="col s5 right-align">
                    
                </div>
            </div>

            <div class="post-info">
                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-minus fa-fw"></i>发布日期:&nbsp;&nbsp;
                    2023-06-27
                </div>
                

                

                

                

                
            </div>
        </div>
        <hr class="clearfix">

        
        <!-- 是否加载使用自带的 prismjs. -->
        <link rel="stylesheet" href="/libs/prism/prism.min.css">
        

        

        <div class="card-content article-card-content">
            <div id="articleContent">
                <h1 id="MYSQL"><a href="#MYSQL" class="headerlink" title="MYSQL"></a>MYSQL</h1><h1 id="MySql下大数据量级别（1000万-）优化查询和操作方法"><a href="#MySql下大数据量级别（1000万-）优化查询和操作方法" class="headerlink" title="MySql下大数据量级别（1000万+）优化查询和操作方法"></a>MySql下大数据量级别（1000万+）优化查询和操作方法</h1><p>1、应尽量避免在 where 子句中使用!=或&lt;&gt;操作符，否则将引擎放弃使用索引而进行全表扫描。</p>
<p>2、对查询进行优化，应尽量避免全表扫描，首先应考虑在 where 及 order by 涉及的列上建立索引。</p>
<p>3、应尽量避免在 where 子句中对字段进行 null 值判断，否则将导致引擎放弃使用索引而进行全表扫描</p>
<p>4、尽量避免在 where 子句中使用 or 来连接条件，否则将导致引擎放弃使用索引而进行全表扫描</p>
<p>5、下面的查询也将导致全表扫描：(不能前置百分号)</p>
<pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp"><span class="token keyword">select</span> id <span class="token keyword">from</span> t <span class="token keyword">where</span> <span class="token class-name">name</span> like ‘�c<span class="token operator">%</span>’<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>若要提高效率，可以考虑全文检索。</p>
<p>6、in 和 not in 也要慎用，否则会导致全表扫描</p>
<p>对于连续的数值，能用 between 就不要用 in 了</p>
<p>7、如果在 where 子句中使用参数，也会导致全表扫描。因为SQL只有在运行时才会解析局部变量，但优化程序不能将访问计划的选择推迟到运行时；它必须在编译时进行选择。然 而，如果在编译时建立访问计划，变量的值还是未知的，因而无法作为索引选择的输入项。如下面语句将进行全表扫描：</p>
<pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp"><span class="token keyword">select</span> id <span class="token keyword">from</span> t <span class="token keyword">where</span> <span class="token class-name">num</span><span class="token operator">=</span>@num<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>可以改为强制查询使用索引：</p>
<pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp"><span class="token keyword">select</span> id <span class="token keyword">from</span> <span class="token return-type class-name">t</span> <span class="token function">with</span><span class="token punctuation">(</span><span class="token function">index</span><span class="token punctuation">(</span>索引名<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">where</span> <span class="token class-name">num</span><span class="token operator">=</span>@num<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>8、应尽量避免在 where 子句中对字段进行表达式操作，这将导致引擎放弃使用索引而进行全表扫描。</p>
<p>9、应尽量避免在where子句中对字段进行函数操作，这将导致引擎放弃使用索引而进行全表扫描。</p>
<p>10、不要在 where 子句中的“=”左边进行函数、算术运算或其他表达式运算，否则系统将可能无法正确使用索引。</p>
<p>11、在使用索引字段作为条件时，如果该索引是复合索引，那么必须使用到该索引中的第一个字段作为条件时才能保证系统使用该索引，否则该索引将不会被使 用，并且应尽可能的让字段顺序与索引顺序相一致。</p>
<p>12、不要写一些没有意义的查询，如需要生成一个空表结构</p>
<p>13、很多时候用 exists 代替 in 是一个好的选择。</p>
<pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp"><span class="token keyword">select</span> num <span class="token keyword">from</span> a <span class="token keyword">where</span> <span class="token class-name">num</span> <span class="token keyword">in</span><span class="token punctuation">(</span><span class="token keyword">select</span> num <span class="token keyword">from</span> b<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>用下面的语句替换：</p>
<pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp"><span class="token keyword">select</span> num <span class="token keyword">from</span> a <span class="token keyword">where</span> <span class="token class-name">exists</span><span class="token punctuation">(</span><span class="token keyword">select</span> <span class="token number">1</span> <span class="token keyword">from</span> b <span class="token keyword">where</span> <span class="token class-name">num</span><span class="token operator">=</span>a<span class="token punctuation">.</span>num<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>14、并不是所有索引对查询都有效，SQL是根据表中数据来进行查询优化的，当索引列有大量数据重复时，SQL查询可能不会去利用索引，如一表中有字段 sex，male、female几乎各一半，那么即使在sex上建了索引也对查询效率起不了作用。</p>
<p>15、索引并不是越多越好，索引固然可以提高相应的 select 的效率，但同时也降低了 insert 及 update 的效率，因为 insert 或 update 时有可能会重建索引，所以怎样建索引需要慎重考虑，视具体情况而定。一个表的索引数最好不要超过6个，若太多则应考虑一些不常使用到的列上建的索引是否有 必要。</p>
<p>16.应尽可能的避免更新 clustered 索引数据列，因为 clustered 索引数据列的顺序就是表记录的物理存储顺序，一旦该列值改变将导致整个表记录的顺序的调整，会耗费相当大的资源。若应用系统需要频繁更新 clustered 索引数据列，那么需要考虑是否应将该索引建为 clustered 索引。</p>
<p>17、尽量使用数字型字段，若只含数值信息的字段尽量不要设计为字符型，这会降低查询和连接的性能，并会增加存储开销。这是因为引擎在处理查询和连接时会 逐个比较字符串中每一个字符，而对于数字型而言只需要比较一次就够了。</p>
<p>18、尽可能的使用 varchar/nvarchar 代替 char/nchar ，因为首先变长字段存储空间小，可以节省存储空间，其次对于查询来说，在一个相对较小的字段内搜索效率显然要高些。</p>
<p>19、任何地方都不要使用 select * from t ，用具体的字段列表代替“*”，不要返回用不到的任何字段。</p>
<p>20、尽量使用表变量来代替临时表。如果表变量包含大量数据，请注意索引非常有限（只有主键索引）。</p>
<p>21、避免频繁创建和删除临时表，以减少系统表资源的消耗。</p>
<p>22、临时表并不是不可使用，适当地使用它们可以使某些例程更有效，例如，当需要重复引用大型表或常用表中的某个数据集时。但是，对于一次性事件，最好使 用导出表。</p>
<p>23、在新建临时表时，如果一次性插入数据量很大，那么可以使用 select into 代替 create table，避免造成大量 log ，以提高速度；如果数据量不大，为了缓和系统表的资源，应先create table，然后insert。</p>
<p>24、如果使用到了临时表，在存储过程的最后务必将所有的临时表显式删除，先 truncate table ，然后 drop table ，这样可以避免系统表的较长时间锁定。</p>
<p>25、尽量避免使用游标，因为游标的效率较差，如果游标操作的数据超过1万行，那么就应该考虑改写。</p>
<p>26、使用基于游标的方法或临时表方法之前，应先寻找基于集的解决方案来解决问题，基于集的方法通常更有效。</p>
<p>27、与临时表一样，游标并不是不可使用。对小型数据集使用 FAST_FORWARD 游标通常要优于其他逐行处理方法，尤其是在必须引用几个表才能获得所需的数据时。在结果集中包括“合计”的例程通常要比使用游标执行的速度快。如果开发时 间允许，基于游标的方法和基于集的方法都可以尝试一下，看哪一种方法的效果更好。</p>
<p>28、在所有的存储过程和触发器的开始处设置 SET NOCOUNT ON ，在结束时设置 SET NOCOUNT OFF 。无需在执行存储过程和触发器的每个语句后向客户端发送 DONE_IN_PROC 消息。</p>
<p>29、尽量避免向客户端返回大数据量，若数据量过大，应该考虑相应需求是否合理。</p>
<p>30、尽量避免大事务操作，提高系统并发能力。</p>
<h2 id="1-DDL-数据定义语言"><a href="#1-DDL-数据定义语言" class="headerlink" title="1.DDL(数据定义语言)"></a>1.DDL(数据定义语言)</h2><h3 id="1-数据库操作"><a href="#1-数据库操作" class="headerlink" title="(1)数据库操作"></a>(1)数据库操作</h3><h4 id="A-查询"><a href="#A-查询" class="headerlink" title="A.查询"></a>A.查询</h4><p>​    查询所有数据库</p>
<p>​    SHOW DATABASES;  </p>
<p>​    查询当前数据库</p>
<p>​    SELECT DATABASES();</p>
<h4 id="B-创建"><a href="#B-创建" class="headerlink" title="B.创建"></a>B.创建</h4><p>​    CREATE DATABASE [IF NOT EXISTS] 数据库名 [DEFAULT CHARSET 字符集] [COLLATE 排序规则];</p>
<h4 id="C-删除"><a href="#C-删除" class="headerlink" title="C.删除"></a>C.删除</h4><p>​    DROP DATABASE [IF EXISTS] 数据库名;</p>
<h4 id="D-使用"><a href="#D-使用" class="headerlink" title="D.使用"></a>D.使用</h4><p>​    USE 数据库名;</p>
<h3 id="2-表操作"><a href="#2-表操作" class="headerlink" title="(2)表操作"></a>(2)表操作</h3><h4 id="A-查询-1"><a href="#A-查询-1" class="headerlink" title="A.查询"></a>A.查询</h4><p>​    查询当前数据库所有表</p>
<p>​    SHOW TABLES;</p>
<p>​    查询表结构</p>
<p>​    DESC 表名;</p>
<p>​    查询指定表的建表语句</p>
<p>​    SHOW CREATE TABLE 表名;</p>
<h4 id="B-创建-1"><a href="#B-创建-1" class="headerlink" title="B.创建"></a>B.创建</h4><p>​    CREATE TABLE 表名(</p>
<p>​    字段1 字段1类型 约束 [COMMENT 字段1注释],</p>
<p>​    字段2 字段2类型 约束 [COMMENT 字段2注释],</p>
<p>​    字段3 字段3类型 约束 [COMMENT 字段3注释],</p>
<p>​    …</p>
<p>​    字段n 字段n类型 约束 [COMMENT 字段n注释]</p>
<p>​    )[COMMENT 表注释];</p>
<h3 id="3-数据类型"><a href="#3-数据类型" class="headerlink" title="(3)数据类型"></a>(3)数据类型</h3><h4 id="A-数值类型"><a href="#A-数值类型" class="headerlink" title="A.数值类型"></a>A.数值类型</h4><p>​    TINYINT    1byte    (-128, 127)    (0, 255)    小整数值</p>
<p>​    SMALLINT    2bytes    (-32768, 32767)    (0, 65535)    大整数值</p>
<p>​    MEDIUMINT    3bytes    (-8388608, 8388607)    (0, 16777215)    大整数值</p>
<p>​    INT or INTEGER    4bytes    (-2147483648, 2147483647)    (0, 4294967295)    大整数值</p>
<p>​    BIGINT    8bytes    (-2^63, 2^63-1)    (0, 2^64-1)    极大整数值</p>
<p>​    FLOAT    4bytes    (-3.402823466E+38, 3.402823466351E+38)    0 和 (1.175494351E-38, 3.402823466E+38)    单精度浮点数值</p>
<p>​    DOUBLE    8bytes    (-1.7976931348623157E+308, 1.7976931348623157E+308)    0和(2.2250738585072014E-3.8, 1.7976931348623157E+308)    双精度浮点数值</p>
<p>​    DECIMAL        依赖于M(精度)和D(标度)的值    依赖于M(精度)和D(标度)的值    小数值(精确定点数)</p>
<h4 id="B-字符串类型"><a href="#B-字符串类型" class="headerlink" title="B.字符串类型"></a>B.字符串类型</h4><p>​    CHAR    0-255bytes    定长字符串</p>
<p>​    VARCHAR    0-65535bytes    变长字符串</p>
<p>​    TINYBLOB    0-255bytes    不超过255个字符的二进制数据</p>
<p>​    TINYTEXT    0-255bytes    短文本字符串</p>
<p>​    BLOB    0-65535bytes    二进制形式的长文本数据</p>
<p>​    TEXT    0-65535bytes    长文本数据</p>
<p>​    MEDIUMBLOB    0-16777215bytes    二进制形式的中等长度文本数据</p>
<p>​    LONGBLOB    0-4294967295bytes    二进制形式的极大文本数据</p>
<p>​    LONGTEXT    0-4294967295bytes    极大文本数据</p>
<h4 id="C-日期时间类型"><a href="#C-日期时间类型" class="headerlink" title="C.日期时间类型"></a>C.日期时间类型</h4><p>​    DATE    3bytes    1000-01-01至9999-12-31    YYYY-MM-DD    日期值</p>
<p>​    TIME    3bytes    -838:59:59至838:59:59    HH:MM:SS    日期值或持续时间</p>
<p>​    YEAR    1bytes    1901至2155    YYYY    年份值</p>
<p>​    DATATIME    8bytes    1000-01-01 00:00:00至9999-12-31 23:59:59    YYYY-MM-DD HH:MM:SS    混合日期和时间值</p>
<p>​    TIMESTAMP    4bytes    1970-01-01 00:00:01至2038-01-19 03:14:07     YYYY-MM-DD HH:MM:SS    混合日期和时间值，时间戳</p>
<h3 id="4-修改"><a href="#4-修改" class="headerlink" title="(4)修改"></a>(4)修改</h3><p>​    添加字段</p>
<p>​    ALTER TABLE 表名 ADD 字段名 类型(长度) [COMMENT 注释] [约束];</p>
<p>​    修改字段名和字段类型</p>
<p>​    ALTER TABLE 表名 CHANGE 旧字段名 新字段名 类型(长度) [COMMENT 注释] [约束];</p>
<p>​    删除字段</p>
<p>​    ALTER TABLE 表名 DROP 字段名;</p>
<p>​    修改表名</p>
<p>​    ALTER TABLE 表名 RENAME TO 新表名;</p>
<h3 id="5-删除"><a href="#5-删除" class="headerlink" title="(5)删除"></a>(5)删除</h3><p>​    删除表</p>
<p>​    DROP TABLE [IF EXISTS] 表名;</p>
<p>​    删除指定表，并重新创建该表</p>
<p>​    TRUNCATE TABLE 表名;</p>
<h2 id="2-DML-数据操作语言"><a href="#2-DML-数据操作语言" class="headerlink" title="2.DML(数据操作语言)"></a>2.DML(数据操作语言)</h2><h3 id="1-添加数据"><a href="#1-添加数据" class="headerlink" title="(1)添加数据"></a>(1)添加数据</h3><p>​    给指定字段添加数据</p>
<p>​    INSERT INTO 表名 (字段名, 字段名2,…) VALUES (值1,值2,…);</p>
<p>​    给全部字段添加数据</p>
<p>​    INSERT INTO 表名 VALUES (值1, 值2,…);</p>
<p>​    批量添加数据</p>
<p>​    INSERT INTO 表名 (字段名1, 字段名2, …) VALUES (值1, 值2,…), (值1, 值2,…), (值1, 值2,…);</p>
<p>​    INSERT INTO 表名 VALUES  (值1, 值2,…), (值1, 值2,…), (值1, 值2,…);</p>
<h3 id="2-修改数据"><a href="#2-修改数据" class="headerlink" title="(2)修改数据"></a>(2)修改数据</h3><p>​    UPDATE 表名 SET 字段名1=值1,字段名2=值2,…[WHERE 条件];</p>
<h3 id="3-删除数据"><a href="#3-删除数据" class="headerlink" title="(3)删除数据"></a>(3)删除数据</h3><p>​    DELETE FROM 表名 [WHERE 条件];</p>
<h2 id="3-DQL-数据查询语言"><a href="#3-DQL-数据查询语言" class="headerlink" title="3.DQL(数据查询语言)"></a>3.DQL(数据查询语言)</h2><p>SELECT 字段列表 FROM 表名列表 WHERE 条件列表 GROUP BY 分组字段列表 HAVING 分组后条件列表 ORDER BY 排序字段列表 LIMIT 分页参数</p>
<h3 id="DQL-执行顺序"><a href="#DQL-执行顺序" class="headerlink" title="DQL 执行顺序"></a>DQL 执行顺序</h3><p>FROM 表名列表 WHERE 条件列表 GROUP BY 分组字段列表 HAVING 分组后条件列表 SELECT 字段列表 ORDER BY 排序字段列表 LIMIT 分页参数</p>
<h3 id="1-基本查询"><a href="#1-基本查询" class="headerlink" title="(1)基本查询"></a>(1)基本查询</h3><p>​    查询多个字段</p>
<p>​    SELECT 字段1,字段2,字段3,… FROM 表名;</p>
<p>​    SELECT * FROM 表名;</p>
<p>​    设置别名</p>
<p>​    SELECT 字段1[AS 别名1], 字段2[AS 别名2] … FROM 表名;</p>
<p>​    去除重复记录</p>
<p>​    SELECT DISTINCT 字段列表 FROM 表名;</p>
<h3 id="2-条件查询-WHERE"><a href="#2-条件查询-WHERE" class="headerlink" title="(2)条件查询(WHERE)"></a>(2)条件查询(WHERE)</h3><p>​    SELECT 字段列表 FROM 表名 WHERE 条件列表;</p>
<p>​    条件</p>
<p>A.比较运算符</p>
<p>= &lt; &lt;= = </p>
<p>&lt;&gt;或!= 不等于</p>
<p>BETWEEN…AND… 在某个范围之内(含最小、最大值)</p>
<p>IN(…) 在IN之后的列表中的值，多选一</p>
<p>LIKE 占位符 模糊匹配(_匹配单个字符，%匹配任意个字符)</p>
<p>IS NULL 是NULL</p>
<p>B.逻辑运算符</p>
<p>AND 或 &amp;&amp; 并且(多个条件同时成立)</p>
<p>OR 或 || 或者(多个条件任意一个成立)</p>
<p>NOT 或 ! 非，不是</p>
<h3 id="3-聚合函数-COUNT-MAX-MIN-AVG-SUM"><a href="#3-聚合函数-COUNT-MAX-MIN-AVG-SUM" class="headerlink" title="(3)聚合函数(COUNT,MAX,MIN,AVG,SUM)"></a>(3)聚合函数(COUNT,MAX,MIN,AVG,SUM)</h3><p>将数据作为整体，进行纵向计算。</p>
<p>count    统计数量</p>
<p>max    最大值</p>
<p>min    最小值</p>
<p>avg    平均值</p>
<p>sum    求和</p>
<p>SELECT 聚合函数(字段列表) FROM 表名;</p>
<h3 id="4-分组查询-GROUP-BY"><a href="#4-分组查询-GROUP-BY" class="headerlink" title="(4)分组查询(GROUP BY)"></a>(4)分组查询(GROUP BY)</h3><p>SELECT 字段列表 FROM 表名 [WHERE 条件] GROUP BY 分组字段名 [HAVING 分组后过滤条件];</p>
<p>​    where与having区别</p>
<p>​    执行时机不同：where是分组之前进行过滤，不满足where条件，不参与分组;而having是分组之后对结果进行过滤。</p>
<p>​    判断条件不同：where不能对聚合函数进行判断，而having可以。</p>
<p>执行顺序：where&gt;聚合函数&gt;having</p>
<h3 id="5-排序查询-ORDER-BY"><a href="#5-排序查询-ORDER-BY" class="headerlink" title="(5)排序查询(ORDER BY)"></a>(5)排序查询(ORDER BY)</h3><p>SELECT 字段列表 FROM 表名 RODER BY 字段1 排序方式1,字段2 排序方式2;</p>
<p>排序方式</p>
<p>ASC:升序(默认值)</p>
<p>DESC:降序</p>
<h3 id="6-分页查询-LIMIT"><a href="#6-分页查询-LIMIT" class="headerlink" title="(6)分页查询(LIMIT)"></a>(6)分页查询(LIMIT)</h3><p>SELECT 字段列表 FROM 表名 LIMIT 起始索引,查询记录数;</p>
<p>起始索引从0开始，起始索引=(查询页码-1) * 每页显示记录数</p>
<h2 id="4-DCL"><a href="#4-DCL" class="headerlink" title="4.DCL"></a>4.DCL</h2><h3 id="1-管理用户"><a href="#1-管理用户" class="headerlink" title="(1)管理用户"></a>(1)管理用户</h3><p>​    查询用户</p>
<p>​    USE mysql;</p>
<p>​    SELECT * FROM user;</p>
<p>​    创建用户</p>
<p>​    CREATE USER ‘用户名‘@’主机名’ IDENTIFIED BY ‘密码’;</p>
<p>​    修改用户密码</p>
<p>​    ALTER USER ‘用户名‘@’主机名’ IDENTIFIED WITH mysql_native_password BY ‘新密码’;</p>
<p>​    删除用户</p>
<p>​    DROP USER ‘用户名‘@’主机名’;</p>
<h3 id="2-权限控制"><a href="#2-权限控制" class="headerlink" title="(2)权限控制"></a>(2)权限控制</h3><p>ALL,ALL PRIVILEGES    所有权限</p>
<p>SELECT    查询数据</p>
<p>INSERT    插入数据</p>
<p>UPDATE    修改数据</p>
<p>DELETE    删除数据</p>
<p>ALTER    修改表</p>
<p>DROP    删除数据库/表/视图</p>
<p>CREATE    创建数据库/表</p>
<p>​    查询权限</p>
<p>​    SHOW GRANTS FOR ‘用户名‘@’主机名’;</p>
<p>​    授予权限</p>
<p>​    GRANT 权限列表 ON 数据库名.表名 TO ‘用户名‘@’主机名’;</p>
<p>​    撤销权限</p>
<p>​    REVOKE 权限列表 ON 数据库名.表名 FROM ‘用户名‘@’主机名’;</p>
<h2 id="5-函数"><a href="#5-函数" class="headerlink" title="5.函数"></a>5.函数</h2><h3 id="1-字符串函数"><a href="#1-字符串函数" class="headerlink" title="(1)字符串函数"></a>(1)字符串函数</h3><p>CONCAT(S1,S2,…Sn)    字符串拼接，将S1,S2,..Sn拼接成一个字符串</p>
<p>LOWER(str)    将字符串str全部转为小写</p>
<p>UPPER(str)    将字符串str全部转为大写</p>
<p>LPAD(str,n,pad)    左填充，用字符串pad对str的左边进行填充，达到n个字符串长度</p>
<p>RPAD(str,n,pad)    左填充，用字符串pad对str的右边进行填充，达到n个字符串长度</p>
<p>TRIM(str)    去掉字符串头部和尾部的空格</p>
<p>SUBSTRING(str,start,len)    返回从字符串str从start位置起的len个长度的字符串</p>
<h3 id="3-数值函数"><a href="#3-数值函数" class="headerlink" title="(3)数值函数"></a>(3)数值函数</h3><p>CEIL(x)    向上取整</p>
<p>FLOOR(x)    向下取整</p>
<p>MOD(x,y)    返回x/y的模</p>
<p>RAND()    返回0-1内的随机数</p>
<p>ROUND(x,y)    求参数x的四舍五入的值，保留y位小数</p>
<h3 id="4-日期函数"><a href="#4-日期函数" class="headerlink" title="(4)日期函数"></a>(4)日期函数</h3><p>CURDATE()    返回当前日期</p>
<p>CURTIM()    返回当前时间</p>
<p>NOW()    返回当前日期和时间</p>
<p>YEAR(date)    获取指定date的年份</p>
<p>MONTH(date)    获取指定date的月份</p>
<p>DAY(date)    获取指定date的日期</p>
<p>DATE_ADD(date,INTERVAL expr type)    返回一个日期/时间值加上一个时间间隔expr后的时间值</p>
<p>DATEDIFF(date1,date2)    返回起始时间date1和结束时间date2之间的天数</p>
<h3 id="5-流程控制"><a href="#5-流程控制" class="headerlink" title="(5)流程控制"></a>(5)流程控制</h3><p>IF(value,t,f)    如果value为true,则返回t,否则返回f</p>
<p>IFNULL(value1,value2)    如果value1不为空，返回value1,否则返回value2</p>
<p>CASE WHEN [val1] THEN [res1] … ELSE [default] END    如果val1为true,返回res1,…否则返回default默认值</p>
<p>CASE [expr] WHEN [val1] THEN [res1] …ELSE [default] END    如果expr的值等于val1，返回res1,…否则返回default默认值</p>
<h2 id="6-约束"><a href="#6-约束" class="headerlink" title="6.约束"></a>6.约束</h2><p>非空约束    限制该字段的数据不能为null    NOT NULL</p>
<p>唯一约束    保证该字段的所有数据都是唯一、不重复的    UNIQUE</p>
<p>主键约束    主键是一行数据的唯一标识，要求非空且唯一    PRIMARY KEY</p>
<p>默认约束    保存数据时，如果未指定该字段的值，则采用默认值    DEFAULT</p>
<p>检查约束    保证字段值满足某一个条件    CHECK</p>
<p>外键约束    用来让两张表的数据之间建立连接，保证数据的一致性和完整性</p>
<h4 id="外键约束"><a href="#外键约束" class="headerlink" title="外键约束"></a>外键约束</h4><p>​    添加外键 </p>
<p>​    CREATE TABLE 表名(</p>
<p>​    字段名 数据类型,</p>
<p>​    …</p>
<p>​    [CONSTRAINT] [外键名称] FOREIGN KEY (外键字段名) REFERENCES 主表(主表列名)</p>
<p>​    );</p>
<p>​    ALTER TABLE 表名 ADD CONSTRAINT 外键名称 FOREIGN KEY(外键字段名) REFERENCES 主表(主表列名);</p>
<p>​    删除/更新行为</p>
<p>​    NO ACTION    当在父表中删除/更新对应记录时，首先检查该记录是否有对应外键，如果有则不允许删除/更新。(与RESTRICT一致)</p>
<p>​    RESTRICT    当在父表中删除/更新对应记录时，首先检查该记录是否有对应外键，如果有则不允许删除/更新。(与NO ACTION一致)</p>
<p>​    CASCADE    当在父表中删除/更新对应记录时，首先检查该记录是否有对应外键，如果有，则也则删除/更新外键在子表中的记录。</p>
<p>​    SET NULL    当在父表中删除对应记录时，首先检查该记录是否有对应外键，如果有则设置子表中该外键为null(这就要求该外键允许取null)。</p>
<p>​    SET DEFAULT    父表有变更时，子表将外键列设置成一个默认的值(Innodb不支持)</p>
<p>ALTER TABLE 表名 ADD CONSTRAINT 外键名称 FOREIGN KEY (外键字段) REFERENCES 主表名(主表字段名) ON UPDATE CASCADE ON DELETE CASCADE;</p>
<h2 id="7-多表查询"><a href="#7-多表查询" class="headerlink" title="7.多表查询"></a>7.多表查询</h2><h3 id="1-多表关系"><a href="#1-多表关系" class="headerlink" title="(1)多表关系"></a>(1)多表关系</h3><h4 id="A-一对多-多对一"><a href="#A-一对多-多对一" class="headerlink" title="A.一对多(多对一)"></a>A.一对多(多对一)</h4><h4 id="B-多对多"><a href="#B-多对多" class="headerlink" title="B.多对多"></a>B.多对多</h4><p>建立中间表，至少包含两个外键，分别关联两方主键</p>
<h4 id="C-一对一"><a href="#C-一对一" class="headerlink" title="C.一对一"></a>C.一对一</h4><p>任意一方加入外键，关联另一方的主键，并且设置外键为唯一的</p>
<h3 id="2-多表查询概述"><a href="#2-多表查询概述" class="headerlink" title="(2)多表查询概述"></a>(2)多表查询概述</h3><p>笛卡尔积：两个集合A和B的所有组合情况(在多表查询时，需要消除无效的笛卡尔积)</p>
<h3 id="3-多表查询分类"><a href="#3-多表查询分类" class="headerlink" title="(3)多表查询分类"></a>(3)多表查询分类</h3><h4 id="A-连接查询"><a href="#A-连接查询" class="headerlink" title="A.连接查询"></a>A.连接查询</h4><h5 id="1-内连接：相当于查询A、B交集部分数据"><a href="#1-内连接：相当于查询A、B交集部分数据" class="headerlink" title="(1)内连接：相当于查询A、B交集部分数据"></a>(1)内连接：相当于查询A、B交集部分数据</h5><p>​    隐式内连接</p>
<p>​    SELECT 字段列表 FROM 表1,表2 WHERE 条件 …;</p>
<p>​    显示内连接</p>
<p>​    SELECT 字段列表 FROM 表1 [INNER] JOIN 表2 ON 连接条件…;</p>
<h5 id="2-外连接："><a href="#2-外连接：" class="headerlink" title="(2)外连接："></a>(2)外连接：</h5><h6 id="左外连接：查询左表所有数据，以及两张表交集部分的数据"><a href="#左外连接：查询左表所有数据，以及两张表交集部分的数据" class="headerlink" title="左外连接：查询左表所有数据，以及两张表交集部分的数据"></a>左外连接：查询左表所有数据，以及两张表交集部分的数据</h6><p>​    SELECT 字段列表 FROM 表1 LEFT [OUTER] JOIN 表2 ON 连接条件…;</p>
<h6 id="右外连接：查询右表所有数据，以及两张表交集部分数据"><a href="#右外连接：查询右表所有数据，以及两张表交集部分数据" class="headerlink" title="右外连接：查询右表所有数据，以及两张表交集部分数据"></a>右外连接：查询右表所有数据，以及两张表交集部分数据</h6><p>​    SELECT 字段列表 FROM 表1 RIGHT [OUTER] JOIN 表2 ON 连接条件…;</p>
<h5 id="3-自连接：当前表与自身的连接查询，自连接必须使用表别名"><a href="#3-自连接：当前表与自身的连接查询，自连接必须使用表别名" class="headerlink" title="(3)自连接：当前表与自身的连接查询，自连接必须使用表别名"></a>(3)自连接：当前表与自身的连接查询，自连接必须使用表别名</h5><p>​    SELECT 字段列表 FROM 表1 别名A,表2 别名B WHERE 条件 …;</p>
<p>​    SELECT 字段列表 FROM 表A 别名A JOIN 表A 别名B ON 条件 …;</p>
<h4 id="B-联合查询-union-union-all"><a href="#B-联合查询-union-union-all" class="headerlink" title="B.联合查询  union, union all"></a>B.联合查询  union, union all</h4><p>把多次查询的结果合并起来，形成一个新的查询结果集。</p>
<p>SELECT 字段列表 FROM 表A …</p>
<p>UNION [ALL]</p>
<p>SELECT 字段列表 FROM 表B …;</p>
<p>对于联合查询的多张表的列数必须保持一致，字段类型也需要保持一致。</p>
<p>union all 会将全部的数据直接合并在一起，union会对合并之后的数据去重</p>
<h4 id="C-子查询"><a href="#C-子查询" class="headerlink" title="C.子查询"></a>C.子查询</h4><p>SQL语句中嵌套SELECT语句，称为嵌套查询，又称子查询。外部的语句可以是INSERT/UPDATE/DELETE/SELECT中任何一个。</p>
<p>SELECT * FROM t1 WHERE column1 = (SELECT column1 FROM t2);</p>
<p>根据子查询结果不同，分为：</p>
<p>标量子查询（子查询结果为单个值）</p>
<p>列子查询（子查询结果为一列）</p>
<p>行子查询（子查询结果为一行）</p>
<p>表子查询（子查询结果为多行多列）</p>
<h2 id="8-事务"><a href="#8-事务" class="headerlink" title="8.事务"></a>8.事务</h2><p>事务是一组操作的集合，是一个不可分割的工作单位，事务会把所有的操作作为一个整体一起向系统提交或撤销操作请求，即这些操作要么同时成功，要么同时失败,整个事务回滚（rollback）到最初的状态。</p>
<h3 id="1-事务操作"><a href="#1-事务操作" class="headerlink" title="(1)事务操作"></a>(1)事务操作</h3><h4 id="1-显式事务"><a href="#1-显式事务" class="headerlink" title="1.显式事务"></a>1.显式事务</h4><h5 id="1-事务完成过程"><a href="#1-事务完成过程" class="headerlink" title="1.事务完成过程"></a>1.事务完成过程</h5><p>1.开启事务</p>
<p>start transaction 或 BEGIN</p>
<p>start transaction 后面可以跟：read only/ read write(默认)/with consistent snapshot(启动一致性读)</p>
<p>2.一系列的DML操作</p>
<p>3.事务结束的状态：提交事务(COMMIT)、中止事务(ROLLBACK/ROLLBACK TO [SAVEPOINT]) </p>
<p>SAVEPOINT相关操作：</p>
<p>在事务中创建保存点，方便后续针对保存点进行回滚</p>
<p>SAVEPOINT    保存点名称；</p>
<p>删除某个保存点</p>
<p>RELEASE SAVEPOINT 保存点名称；</p>
<h4 id="2-隐式事务"><a href="#2-隐式事务" class="headerlink" title="2.隐式事务"></a>2.隐式事务</h4><p>系统变量 @@autocommit:</p>
<p>查看/设置事务提交方式</p>
<p>SELECT @@autocommit;     //为1自动提交</p>
<p>SET @@autocommit = 0;    //设置手动提交 </p>
<p>关闭自动提交</p>
<p>方式1：</p>
<p>SET autocommit = FALSE;    针对于DML操作是有效的，对DDL操作是无效的。</p>
<p>方式2：</p>
<p>在autocommit为true的情况下，使用start transaction或begin开启事务，那么DML操作就不会自动提交数据；</p>
<p>默认情况下（autocommit为true），没有开启事务，DML操作也会自动提交数据。</p>
<p>提交事务</p>
<p>COMMIT;</p>
<p>回滚事务</p>
<p>ROLLBACK;</p>
<p>开启事务</p>
<p>START TRANSACTION 或 BEGIN</p>
<p>提交事务</p>
<p>COMMIT;</p>
<p>回滚事务</p>
<p>ROLLBACK;</p>
<h4 id="3-隐式提交数据的情况"><a href="#3-隐式提交数据的情况" class="headerlink" title="3.隐式提交数据的情况"></a>3.隐式提交数据的情况</h4><p>1.数据定义语言(DDL)</p>
<p>2.隐式使用或修改mysql数据库中的表</p>
<p>3.事务控制或关于锁定的语句</p>
<p>​    1.在一个事务还没提交或者回滚时就又用START TRANSACTION或者BEGIN语句开启了另一个事务时，会隐式的提交上一个事务。</p>
<p>​    2.当前的autocommit系统变量的值为OFF，我们手动把它调为ON时，也会隐式的提交前边语句所属的事务。</p>
<p>​    3.使用LOCK TABLES、UNLOCK TABLES等关于锁定的语句也会隐式的提交前边语句所属的事务。</p>
<p>4.加载数据的语句</p>
<p>使用LOAD DATA 语句来批量往数据库中导入数据时，也会隐式的提交前边语句所属的事务。</p>
<p>5.关于MYSQL复制的一些语句</p>
<p>使用START SLAVE、STOP ALAVE、RESET SLAVE、CHANGE MASTER TO 等语句时会隐式的提交前边语句所属的事务。</p>
<p>6.其他的一些语句</p>
<p>使用ANALYZE TABLE、CHAHE INDEX、CHECK TABLE、FLUSH、LOAD INDEX INFO CACHE、OPTIMIZE TABLE、REPAIR TABLE、RESET等语句也会隐式的提交前边语句所属的事务。</p>
<h3 id="2-事务四大特性-ACID"><a href="#2-事务四大特性-ACID" class="headerlink" title="(2)事务四大特性(ACID)"></a>(2)事务四大特性(ACID)</h3><h4 id="原子性-Atomicity-：事务是不可分割的最小操作单元，要么全部成功，要么全部失败。"><a href="#原子性-Atomicity-：事务是不可分割的最小操作单元，要么全部成功，要么全部失败。" class="headerlink" title="原子性(Atomicity)：事务是不可分割的最小操作单元，要么全部成功，要么全部失败。"></a>原子性(Atomicity)：事务是不可分割的最小操作单元，要么全部成功，要么全部失败。</h4><h4 id="一致性-Consistency-：事务完成时，必须使所有的数据都保持一致状态。"><a href="#一致性-Consistency-：事务完成时，必须使所有的数据都保持一致状态。" class="headerlink" title="一致性(Consistency)：事务完成时，必须使所有的数据都保持一致状态。"></a>一致性(Consistency)：事务完成时，必须使所有的数据都保持一致状态。</h4><p>定义：一致性是指事务执行前后，数据从一个合法性状态变换到另一个合法性状态，这种状态是语义上的而不是语法上的，跟具体业务有关。</p>
<h4 id="隔离性-Isolation-：数据库系统提供的隔离机制，保证事务在不受外部并发操作影响的独立环境下运行。"><a href="#隔离性-Isolation-：数据库系统提供的隔离机制，保证事务在不受外部并发操作影响的独立环境下运行。" class="headerlink" title="隔离性(Isolation)：数据库系统提供的隔离机制，保证事务在不受外部并发操作影响的独立环境下运行。"></a>隔离性(Isolation)：数据库系统提供的隔离机制，保证事务在不受外部并发操作影响的独立环境下运行。</h4><p>事务的隔离性是指一个事务的执行不能被其他事务干扰，即一个事务内部的操作及使用的数据对并发的其他事务是隔离的，并发执行的各个事务之间不能互相干扰。</p>
<h4 id="持久性-Durability-：事务一旦提交或回滚，它对数据库中的数据的改变就是永久的。"><a href="#持久性-Durability-：事务一旦提交或回滚，它对数据库中的数据的改变就是永久的。" class="headerlink" title="持久性(Durability)：事务一旦提交或回滚，它对数据库中的数据的改变就是永久的。"></a>持久性(Durability)：事务一旦提交或回滚，它对数据库中的数据的改变就是永久的。</h4><p>持久性是指一个事务一旦被提交，它对数据库中数据的改变就是永久性的，接下来的其他操作和数据库故障不应该对其有任何影响。</p>
<p>持久性是通过事务日志来保证的。日志包括了重做日志和回滚日志。当我们通过事务对数据进行修改的时候，首先会将数据库的变化信息记录到重做日志中，然后再对数据库中对应的行进行修改。这样做的好处是，即使数据库系统崩溃，数据库重启后也能找到没有更新到数据库系统中的重做日志，重新执行，从而使事务具有持久性。</p>
<p>总结：</p>
<p>ACID是事务的四大特性，在这四个特性中，原子性是基础，隔离性是手段，一致性是约束条件，而持久性是我们的目的。</p>
<p>数据库事务，其实就是数据库设计者为了方便起见，把需要保证原子性、隔离性、一致性和持久性的一个或多个数据库操作称为一个事务。</p>
<h3 id="3-事务的状态"><a href="#3-事务的状态" class="headerlink" title="(3)事务的状态"></a>(3)事务的状态</h3><p>事务是一个抽象的概念，对应着一个或多个数据库操作，mysql根据这些操作所执行的不同阶段把事务大致划分成几个状态：</p>
<p>1.活动的（active）</p>
<p>事务对应的数据库操作正在执行过程中时，该事务处于活动的状态的。</p>
<p>2.部分提交的（partially committed）</p>
<p>当事务中的最后一个操作执行完成，但由于操作都在内存中执行，所造成的影响并没有刷新到磁盘时，我们就说该事务处在部分提交的状态。</p>
<p>3.失败的（failed）</p>
<p>当事务处在活动的或者部分提交的状态时，可能遇到了某些错误（数据库自身的错误、操作系统错误或者直接断电等）而无法继续执行，或者人为的停止当前事务的执行，我们就说该事务处于失败的状态。</p>
<p>4.中止的（aborted）</p>
<p>如果事务执行了一部分而变为失败的状态，那么就需要把已经修改的事务中的操作还原到事务执行前的状态。换句话说，就是要撤销失败事务对当前数据库造成的影响。我们把这个撤销的过程称之为回滚。当回滚操作执行完毕时，也就是数据库恢复到了执行事务之前的状态，我们就说该事务处在了中止的状态。</p>
<p>5.提交的（committed）</p>
<p>当一个处在部分提交的状态的事务将修改过的数据都同步到磁盘上之后，我们就可以说该事物处在了提交的状态。</p>
<p>一个基本的状态转换图如下所示：<br><img src="/images/20230628215905.png" alt="状态转换图"></p>
<p>图中可见，只有当事务处于提交的或者中止的状态时，一个事务的生命周期才算是结束了。对于已经提交的事务来说，该事务对数据库所做的修改将永久生效，对于处于中止状态的事务，该事务对数据库所做的所有修改都会被回滚到没执行该事务之前的状态。</p>
<h3 id="4-数据并发问题"><a href="#4-数据并发问题" class="headerlink" title="(4)数据并发问题"></a>(4)数据并发问题</h3><p>访问相同数据的事务在不保证串行执行的情况下可能出现的问题：</p>
<p>1.脏写（dirty write）</p>
<p>对于两个事务Session A、Session B，如果事务Session A修改了另一个未提交事务Session B修改过的数据，那就意味着发生了脏写。</p>
<p><img src="/images/20230628220448.png" alt="脏写"><br>session A和Session B各开启了一个事务，Session B中的事务先将studentno列为1的记录的name列更新为‘李四’，然后Session A中的事务接着又把这条studentno列为1的记录的name列更新为‘张三’。如果之后Session B中的事务进行了回滚，那么Session A中的更新也将不复存在，这种现象就称之为脏写。这时Session A中的事务就没有效果了，明明把数据更新了，最后也提交事务了，最后看到的数据什么变化也没有。这里大家对事务的隔离级别比较了解的话，会发现在默认隔离级别下，上面Session A中的更新语句会处于等待状态，这里只是跟大家说明一下会出现这样现象。<br>2.脏读（dirty read）</p>
<p>对于两个事务Session A、Session B，Session A读取了已经被Session B更新但还没有被提交的字段。之后若Session B回滚，Session A读取的内容就是临时且无效的。</p>
<p><img src="/images/20230628221432.png" alt="脏读"><br>Session A和session B各开启了一个事务，Session B中的事务先将studentno列为1的记录的name列更新为’张三’，然后Session A中的事务再去查询这条studentno为1的记录，如果读到列name的值为’张三’，而Session B中的事务稍后进行了回滚，那么Session A中的事务相当于读到了一个不存在的数据，这种现象就称之为脏读。</p>
<p>3.不可重复读（non-repeatable read）</p>
<p>对于两个事务Session A、Session B，Session A读取了一个字段，然后Session B更新了该字段。之后Session A再次读取同一个字段，值就不同了。那就意味着发生了不可重复读。</p>
<p><img src="/images/20230628221732.png" alt="不可重复读"><br>我们在Session B中提交了几个隐式事务(注意是隐式事务，意味着语句结束事务就提交了)，这些事务都修改了studentno列为1的记录的列name的值，每次事务提交之后，如果Session A中的事务都可以查看到最新的值，这种现象也被称之为不可重复读。</p>
<p>4.幻读（Phantom）</p>
<p>对于两个事务Session A、Session B，Session A从一个表中读取了一个字段，然后Session B在该表中插入了一些新的行。之后，如果Session A再次读取同一个表，就会多出几行。那就意味着发生了幻读。</p>
<p><img src="/images/20230628222027.png" alt="幻读"><br>Session A中的事务先根据条件studentno&gt;o这个条件查询表student，得到了name列值为张三’的记录;之后Session B中提交了一个隐式事务，该事务向表student中插入了一条新记录;之后Session A中的事务再根据相同的条件studentno&gt;o查询表student，得到的结果集中包含Session B中的事务新插入的那条记录，这种现象也被称之为幻读。我们把新插入的那些记录称之为幻影记录。</p>
<p>注意：对于Session B中删除了一些符合的记录而不是插入新记录，那Session A之后根据条件读取的记录变少了，这种不算幻读，幻读强调的是一个事务按照某个相同条件多次读取记录时，后读取时读到了之前没有读到的记录。</p>
<p><strong>脏读</strong>    一个事务读到另外一个事务还没有提交的数据。</p>
<p><strong>不可重复读</strong>    一个事务先后读取同一条记录，但两次读取的数据不同，称之为不可重复读。</p>
<p><strong>幻读</strong>    一个事务按照条件查询数据时，没有对应的数据行，但是在插入数据时，又发现这行数据已经存在，好像出现了“幻影”。</p>
<p>严重性排序：</p>
<p>脏写 &gt; 脏读 &gt; 不可重复读 &gt; 幻读</p>
<h3 id="5-事务隔离级别"><a href="#5-事务隔离级别" class="headerlink" title="(5)事务隔离级别"></a>(5)事务隔离级别</h3><p>1.SQL四种隔离级别：</p>
<ol>
<li>READ UNCOMMITTED：读未提交，在该隔离级别，所有事务都可以看到其它未提交事务的执行结果。不能避免脏读、不可重复读、幻读</li>
<li>READ COMMITTED：读已提交，它满足了隔离的简单定义：一个事务只能看见已经提交事务所做的改变。这是大多数数据库系统的默认隔离级别（但不是MySQL默认的）。可以避免脏读，但不可重复读、幻读问题仍然存在。</li>
<li>REPEATABLE READ：可重复读，事务A在读到一条数据后，此时事务B对该数据进行了修改并提交，那么事务A再读该数据，读到的还是原来的内容。可以避免脏读、不可重复读，但幻读问题仍然存在。这是MySQL的默认隔离级别。</li>
<li>SERIALIZABLE：可串行化，确保事务可以从一个表中读取相同的行。在这个事务持续期间，禁止其他事务对该表执行插入、更新和删除操作。所有的并发问题都可以避免，但性能十分低下。能避免脏读、不可重复读和幻读。</li>
</ol>
<p><img src="/images/20230628222336.png" alt="隔离级别"></p>
<p>MySQL中隔离级别</p>
<p>隔离级别                                脏读                不可重复读                幻读</p>
<p>Read uncommitted                √                            √                            √</p>
<p>Read committed                    ×                            √                            √</p>
<p>Repeatable Read(默认)        ×                                ×                            √</p>
<p>Serializable                            ×                                ×                            ×</p>
<p><img src="/images/20230628222451.png" alt="隔离级别与并发性能"></p>
<p>查看事务隔离级别</p>
<p>SELECT @@TRANSACTION_ISOLATION;</p>
<p>设置事务隔离级别</p>
<p>SET [SESSION | GLOBAL] TRANSACTION ISOLATION LEVEL {READ UNCOMMITTED | READ COMMITTED | REPEATABLE READ | SERIALIZABLE}</p>
<p>设置时使用GLOBAL或SESSION的影响：</p>
<p>1.使用GLOBAL关键字（在全局范围影响）：</p>
<p>​    1.当前已经存在的会话无效</p>
<p>​    2.只对执行完该语句之后产生的会话起作用</p>
<p>2.使用SESSION关键字（在会话范围影响）：</p>
<p>​    1.对当前会话的所有后续的事务有效</p>
<p>​    2.如果在事务之间执行，则对后续的事务有效</p>
<p>​    3.该语句可以在已经开始的事务中间执行，但不会影响当前正在执行的事务。</p>
<p><strong>幻读的解决方案</strong></p>
<p><img src="/images/20230628224934.png"></p>
<h2 id="9-MYSQL事务日志"><a href="#9-MYSQL事务日志" class="headerlink" title="9.MYSQL事务日志"></a>9.MYSQL事务日志</h2><p>事务的四种特性：原子性、一致性、隔离性和持久性。四种特性基于什么机制实现？</p>
<p>1.事务的隔离性由锁机制实现</p>
<p>2.事务的原子性、一致性、持久性由事务的redo日志和undo日志来保证。</p>
<p>​    REDO LOG称为重做日志，提供再写入操作，恢复提交事务修改的页操作，用来保证事务的持久性。</p>
<p>​    UNDO LOG称为回滚日志，回滚行记录到某个特定的版本，用来保证事务的原子性、一致性。</p>
<p>REDO和UNDO都可以视为是一种恢复操作，但是：</p>
<p>1.redo log：是存储引擎（innodb）生成的日志，记录的是“物理级别”上的页修改操作，比如页号xxx、偏移量yyy写入了’zzz’数据。主要为了保证数据的可靠性。</p>
<p>2.undo log：是存储引擎层（innodb）生成的日志，记录的是逻辑操作日志，比如对某一行数据进行了INSERT语句操作，那么undo log就记录一条与之相反的DELETE操作。主要用于事务的回滚（undo log记录的是每个修改操作的逆操作）和一致性非锁定读（undo log回滚行记录到某种特定的版本–MVCC，即多版本并发控制）。</p>
<h3 id="1-redo-日志"><a href="#1-redo-日志" class="headerlink" title="1.redo 日志"></a>1.redo 日志</h3><h4 id="1-为什么需要redo-日志"><a href="#1-为什么需要redo-日志" class="headerlink" title="1.为什么需要redo 日志"></a>1.为什么需要redo 日志</h4><p>在事务提交完成之前把该事务所修改的所有页面都刷新到磁盘，但是这个做法有些问题：</p>
<p>1.修改量与刷新磁盘工作量严重不成比例</p>
<p>2.随机IO刷新较慢</p>
<p>InnoDB引擎的事务采用了WAL技术，这种技术的思想就是先写日志，再写磁盘，只有日志写入成功，才算事务提交成功，这里的日志就是redo log。当发生宕机且数据未刷到磁盘的时候，可以通过redo log来恢复，保证ACID中的持久性。</p>
<h4 id="2-redo日志的好处、特点"><a href="#2-redo日志的好处、特点" class="headerlink" title="2.redo日志的好处、特点"></a>2.redo日志的好处、特点</h4><h5 id="1-好处"><a href="#1-好处" class="headerlink" title="1.好处"></a>1.好处</h5><p>redo日志降低了刷盘频率</p>
<p>redo日志占用的空间非常小</p>
<p>存储表空间ID、页号、偏移量以及需要更新的值，所需要的存储空间是很小的，刷盘快。</p>
<h5 id="2-特点"><a href="#2-特点" class="headerlink" title="2.特点"></a>2.特点</h5><p>1.redo日志是顺序写入磁盘的</p>
<p>2.事务执行过程中，redo log不断记录</p>
<p>redo log和bin log的区别，redo log是存储引擎层产生的，而bin log是数据库产生的。假设一个事务，对表做10万行的记录插入，在这个过程中，一直不断的往redo log顺序记录，而bin log不会记录，直到这个事务提交，才会一次写入到bin log文件中。</p>
<h4 id="3-redo日志的组成"><a href="#3-redo日志的组成" class="headerlink" title="3.redo日志的组成"></a>3.redo日志的组成</h4><p>redo log分为两个部分：</p>
<p>1.重做日志的缓冲（redo log buffer)，保存在内存中，是易失的。</p>
<p>在服务器启动时就向操作系统申请了一大片称之为redo log buffer的连续内存空间，就是redo日志缓冲区。这片内存空间被划分成若干个连续的redo log block。一个redo log block占用512字节大小。</p>
<p>参数设置：innodb_log_buffer_size:</p>
<p>redo log buffer大小，默认16M，最大值是4096M，最小值为1M。</p>
<p>2.重做日志文件（redo log file），保存在硬盘中，是持久的。</p>
<p>ib_logfile0/ib_logfile1</p>
<h4 id="4-redo-整体流程"><a href="#4-redo-整体流程" class="headerlink" title="4.redo 整体流程"></a>4.redo 整体流程</h4><p><img src="/images/20230628225614.png" alt="整体流程"></p>
<h4 id="5-redo-log-的刷盘策略"><a href="#5-redo-log-的刷盘策略" class="headerlink" title="5.redo log 的刷盘策略"></a>5.redo log 的刷盘策略</h4><p>redo log的写入并不是直接写入磁盘的，InnoDB引擎会在写redo log的时候先写redo log的时候先写redo lg buffer，之后以一定的频率刷入都真正的redo log file中。这里的一定频率怎么看待呢？这就是我们要说的刷盘策略。</p>
<p><img src="/images/20230628225725.png" alt="刷盘策略"></p>
<p>注意，redo log buffer刷盘到redo log file的过程并不是真正的刷到磁盘中去，只是刷入到文件系统缓存(page cache)中去（这是现代操作系统为了提高文件写入效率做的一个优化），真正的写入会交给系统自己来决定（比如page cache足够大了）。那么对于InnoDB来说就存在一个问题，如果交给系统来同步，同样如果系统宕机，那么数据也丢失了（虽然整个系统宕机的概率还是比较小的）。</p>
<p>针对这种情况，InnoDB给出了innodb_flush_log_at_trx_commit参数，该参数控制commit提交事务时，如何将redo log buffer中的日志刷新到redo log file中。它支持三种策略：</p>
<p>1.设置为0：表示每次事务提交时不进行刷盘操作。（系统默认master thread每隔1s进行一次重做日志的同步）</p>
<p>2.设置为1：表示每次事务提交时都将进行同步，刷盘操作（默认值）</p>
<p>3.设置为2：表示每次事务提交时都只把redo log buffer内容写入page cache，不进行同步。由os自己决定什么时候同步到磁盘文件。</p>
<p>另外，InnoDB存储引擎有一个后台线程，每隔一秒，就会把redo log buffer中的内容写到文件系统缓存（page cache），然后调用刷盘操作。</p>
<p><img src="/images/20230628225931.png" alt="image"></p>
<p>也就是说，一个没有提交事务的redo log记录，也可能会刷盘。因为在事务执行过程redo log记录是会写入redo log buffer中，这些redo log记录会被后台线程刷盘。</p>
<p><img src="/images/20230628230054.png" alt="image"></p>
<p>除了后台线程每秒1次的轮询操作，还有一种情况，当redo log buffer占用的空间即将达到innodb_log_buffer_size（这个参数默认是16M）的一半的时候，后台线程会主动刷盘。</p>
<h4 id="6-不同刷盘演示"><a href="#6-不同刷盘演示" class="headerlink" title="6.不同刷盘演示"></a><strong>6.不同刷盘演示</strong></h4><h5 id="1-流程图"><a href="#1-流程图" class="headerlink" title="1.流程图"></a>1.流程图</h5><p><img src="/images/20230628230226.png" alt="image"></p>
<p><img src="/images/20230628230508.png" alt="image"></p>
<p><img src="/images/20230628230618.png" alt="image"></p>
<p><img src="/images/20230628230657.png" alt="image"></p>
<p><img src="/images/20230628231749.png" alt="image"></p>
<p><img src="/images/20230628231915.png" alt="image"></p>
<h4 id="7-写入redo-log-buffer过程"><a href="#7-写入redo-log-buffer过程" class="headerlink" title="7.写入redo log buffer过程"></a>7.写入redo log buffer过程</h4><p><strong>1.补充概念：Mini-Transaction</strong></p>
<p>MYSQL把底层页面中的一次原子访问的过程称之为一个Mini-Transaction，简称mtr，比如，向某个索引对应的B+树中插入一条记录的过程就是一个Mini-Transaction。一个所谓的mtr可以包含一组redo日志，在进行崩溃恢复时这一组redo日志作为一个不可分割的整体。</p>
<p>一个事务可以包含若干条语句，每一条语句其实是由若干个mtr组成，每一个mtr又可以包含若干条redo日志，图示关系：</p>
<p><img src="/images/20230628232040.png" alt="image"></p>
<p><strong>2.redo日志写入 log buffer</strong></p>
<p>向log buffer中写入redo日志的过程是顺序的，也就是先往前边的block中写，当该block的空闲空间用完之后再往下一个block中写。当我们想往log buffer中写入redo日志时，第一个遇到的问题就是应该写在哪个block的哪个偏移量处，所以InnoDB的设计者特意提供了一个称之为buf_free的全局变量，该变量指明后续写入的redo日志应该写入到log buffer中的哪个位置，如图所示：</p>
<p><img src="/images/20230628232134.png" alt="image"></p>
<p>一个mtr执行过程中可能产生若干条redo日志，这些redo日志是一个不可分割的组，所以不是每生成一条redo日志，就将其插入到log buffer中，而是每个mtr运行过程中产生的日志先暂时存放到一个地方，当该mtr结束的时候，将过程中产生的一组redo日志再全部复制到log buffer中。</p>
<p><img src="/images/20230628232604.png" alt="image"></p>
<p><img src="/images/20230628232740.png" alt="image"></p>
<p><strong>3.redo log block的结构图</strong></p>
<p>一个redo log block是由日志头、日志体、日志尾组成。日志头占用12字节，日志尾占用8字节，所以一个block真正能存储的数据就是512-12-8=492字节。</p>
<p>一个block设计成512字节，和磁盘的扇区有关，机械磁盘默认扇区就是512字节。</p>
<p><img src="/images/20230628233052.png" alt="image"></p>
<p><img src="/images/20230628233139.png" alt="image"></p>
<p><img src="/images/20230628233214.png" alt="image"></p>
<h4 id="8-redo-log-file"><a href="#8-redo-log-file" class="headerlink" title="8.redo log file"></a>8.redo log file</h4><h5 id="1-日志文件组"><a href="#1-日志文件组" class="headerlink" title="1.日志文件组"></a>1.日志文件组</h5><p>磁盘上的redo日志文件是以一个日志文件组的形式出现的，采用循环使用的方式向redo日志文件组里写数据。</p>
<p><img src="/images/20230629130444.png" alt="image"></p>
<h5 id="2-checkpoint"><a href="#2-checkpoint" class="headerlink" title="2.checkpoint"></a>2.checkpoint</h5><p>checkpoint来防止后写入的redo日志覆盖掉前边的redo日志。</p>
<p>在整个日志文件组中还有两个重要的属性，分别是write pos、checkpoint</p>
<p>write pos：是当前记录的位置，一边写一边后移</p>
<p>checkpoint：是当前要擦除的位置，也是往后推移</p>
<p>每次刷盘redo log记录到日志文件组中，write pos位置就会后移更新。每次MYSQL加载日志文件组恢复数据时，会清空加载过的redo log记录，并把checkpoint后移更新。write pos和checkpoint之间的还空着的部分可以用来写入新的redo log记录。</p>
<p><img src="/images/20230629130906.png" alt="image"></p>
<p>如果write pos追上checkpoint，表示日志文件组满了，这时候不能再写入新的redo log记录，MYSQL得停下来，清空一些记录，把checkpoint推进。</p>
<p><img src="/images/20230629130945.png" alt="image"><br>小结：</p>
<p><img src="/images/20230629131039.png" alt="image"></p>
<h3 id="2-Undo日志"><a href="#2-Undo日志" class="headerlink" title="2.Undo日志"></a>2.Undo日志</h3><p>redo log是事务持久性的保证，undo log是事务原子性的保证。在事务中更新数据的前置操作其实是要先写入一个undo log。</p>
<h4 id="1-如何理解Undo日志"><a href="#1-如何理解Undo日志" class="headerlink" title="1.如何理解Undo日志"></a>1.如何理解Undo日志</h4><p>事务需要原子性，也就是事务中的操作要么全部完成，要么什么也不做。但是有时候事务执行到一半会出现一些情况，比如：</p>
<p>1.事务执行过程中可能遇到各种错误，比如服务器本身的错误，操作系统错误，甚至是突然断电导致的错误。</p>
<p>2.程序员可以在事务执行过程中手动输入ROLLBACK语句结束当前事务的执行。</p>
<p>以上这种情况，我们需要把数据改回原来的样子，这个过程为回滚，这样就造成一个假象：这个事务看起来什么都没做，所以符合原子性要求。每当我们要对一条记录做改动时（INSERT、DELETE、UPDATE）</p>
<p>MYSQL把这些为了回滚而记录的这些内容称之为撤销日志或者回滚日志。注意，由于查询操作（SELECT）并不会修改任何用户记录，所以在查询操作执行前，并不记录相应的undo日志。</p>
<p>此外，undo log会产生redo log，也就是undo log的产生会伴随着redo log的产生，这是因为undo log也需要持久性的保护。</p>
<h4 id="2-Undo日志作用"><a href="#2-Undo日志作用" class="headerlink" title="2.Undo日志作用"></a>2.Undo日志作用</h4><p>1.回滚数据<br>用户对undo日志可能有误解:undo用于将数据库物理地恢复到执行语句或事务之前的样子。但事实并非如此。undo是逻辑日志，因此只是将数据库逻辑地恢复到原来的样子。所有修改都被逻辑地取消了，但是数据结构和页本身在回滚之后可能大不相同。</p>
<p>这是因为在多用户并发系统中，可能会有数十、数百甚至数千个并发事务。数据库的主要任务就是协调对数据记录的并发访问。比如，一个事务在修改当前一个页中某几条记录，同时还有别的事务在对同一个页中另几条记录进行修改。因此，不能将一个页回滚到事务开始的样子，因为这样会影响其他事务正在进行的工作。</p>
<p>undo是逻辑日志，只是将数据库逻辑恢复到原来的样子</p>
<p>2.MVCC</p>
<p>undo的另一个作用是MVCC，即在InnoDB存储引擎中MCc的实现是通过undo来完成。当用户读取一行记录时，若该记录已经被其他事务占用，当前事务可以通过undo读取之前的行版本信息，以此实现非锁定读取。</p>
<h4 id="3-undo的存储结构"><a href="#3-undo的存储结构" class="headerlink" title="3.undo的存储结构"></a>3.undo的存储结构</h4><p><strong>1.回滚段与undo页</strong></p>
<p>InnoDB对undo log的管理采用段的方式，也就是回滚段(rollback segment)。每个回滚段记录了1024个undo log segment，而在每个undo log segment段中进行undo页的申请。</p>
<p>undo页的重用</p>
<p>当我们开启一个事务需要写undo log的时候，就得先去undo log seg segment中去找到一个空闲的位置，当有空位的时候，就去申请undo页，在这个申请到的undo页中进行undo log的写入。</p>
<p>为每一个事务分配一个页，是非常浪费的（除非你的事务非常长)，假设你的应用的TPS(每秒处理的事务数目）为1000，那么1s就需要1000个页，大概需要16M的存储，1分钟大概需要1G的存储。如果照这样下去除非<br>MySQL清理的非常勤快，否则随着时间的推移，磁盘空间会增长的非常快，而且很多空间都是浪费的。</p>
<p>于是undo页就被设计的可以重用了，当事务提交时，并不会立刻删除undo页。因为重用，所以这个undo页可能混杂着其他事务的undo log。undo log在commit后，会被放到一个链表中，然后判断undo页的使用空间是否小于3/4，如果小于3/4的话，则表示当前的undo页可以被重用，那么它就不会被回收，其他事务的undo log可以记录在当前undo页的后面。由于undo log是离散的，所以清理对应的磁盘空间时，效率不高。</p>
<p><strong>2.回滚段与事务</strong></p>
<p>1.每个事务只会使用一个回滚段，一个回滚段在同一时刻可能会服务于多个事务。</p>
<p>2.当一个事务开始的时候，会制定一个回滚段，在事务进行的过程中，当数据被修改时，原始数据会被复制到回滚段。</p>
<p>3.在回滚段中，事务会不断填充盘区，直到事务结束或所有的空间被用完。如果当前的盘区不够用，事务会在段中请求扩展下一个盘区，如果所有已分配的盘区都被用完，事务会覆盖最初的盘区或者在回滚段允许的情况下扩展新的盘区来使用。</p>
<p>4.回滚段存在于undo表空间中，在数据库中可以存在多个undo表空间，但同一时刻只能使用一个undo表空间。</p>
<p>5.当事务提交时，InnoDB存储引擎会做以下两件事情：</p>
<p>1.将undo log放入列表中，以供之后的purge操作</p>
<p>2.判断undo log所在的页是否可以重用，若可以，分配给下个事务使用</p>
<p><strong>3.回滚段中的数据分类</strong></p>
<ol>
<li>未提交的回滚数据(uncommitted undo information)︰该数据所关联的事务并未提交，用于实现读一致性，所以该数据不能被其他事务的数据覆盖。</li>
<li>已经提交但未过期的回滚数据( committed undo information):该数据关联的事务已经提交，但是仍受到undo retention参数的保持时间的影响。</li>
<li>事务已经提交并过期的数据(expired undo information):事务已经提交，而且数据保存时间已经超过undo retention参数指定的时间，属于已经过期的数据。当回滚段满了之后，会优先覆盖”事务已经提交并过期的数据”。</li>
</ol>
<p>事务提交后并不能马上删除undo log及undo log所在的页。这是因为可能还有其他事务需要通过undo log来得到行记录之前的版本。故事务提交时将undo log放入一个链表中，是否可以最终删除undo log及undo log所在页由purge线程来判断。</p>
<h4 id="4-undo的类型"><a href="#4-undo的类型" class="headerlink" title="4.undo的类型"></a>4.undo的类型</h4><p>在lnnoDB存储引擎中,undo log分为:</p>
<ol>
<li>insert undo log<br>insert undo log是指在insert操作中产生的undo log。因为insert操作的记录，只对事务本身可见，对其他事务不可见(这是事务隔离性的要求)，故该undo log可以在事务提交后直接删除。不需要进行purge操作。</li>
<li>update undo log<br>update undo log记录的是对delete和update操作产生的undo log。该undo log可能需要提供MVCC机制，因此不能在事务提交时就进行删除。提交时放入undo log链表，等待purge线程进行最后的删除。</li>
</ol>
<h4 id="5-undo-log的生命周期"><a href="#5-undo-log的生命周期" class="headerlink" title="5.undo log的生命周期"></a>5.undo log的生命周期</h4><h5 id="1-简要生成过程"><a href="#1-简要生成过程" class="headerlink" title="1. 简要生成过程"></a>1. 简要生成过程</h5><p>以下是undo+redo事务的简化过程<br>假设有2个数值，分别为A=1和B=2，然后将A修改为3，B修改为4</p>
<ol>
<li>start transaction ;</li>
<li>记录A=1到undo log;</li>
<li>update A = 3;</li>
<li>记录A=3 到redo log;</li>
<li>记录B=2到undo log;</li>
<li>update B =4;</li>
<li>记录B = 4到redo log;</li>
<li>将redo log刷新到磁盘</li>
<li>commit</li>
</ol>
<p>1.在1-8步骤的任意一步系统宕机，事务未提交，该事务就不会对磁盘上的数据做任何影响。<br>2.如果在8-9之间宕机，恢复之后可以选择回滚，也可以选择继续完成事务提交，因为此时redo log已经持久化。<br>3.若在9之后系统宕机，内存映射中变更的数据还来不及刷回磁盘，那么系统恢复之后，可以根据redo log把数据刷回磁盘。</p>
<p><img src="/images/20230629133338.png"></p>
<p><img src="/images/20230629133426.png"></p>
<p>在更新Buffer Pool中的数据之前，我们需要先将该数据事务开始之前的状态写入Undo Log中。假设更新到一半出错了，我们就可以通过Undo Log来回滚到事务开始前。</p>
<h5 id="2-详细生成过程"><a href="#2-详细生成过程" class="headerlink" title="2. 详细生成过程"></a>2. 详细生成过程</h5><p>对于InnoDB引擎来说，每个行记录除了记录本身的数据之外，还有几个隐藏的列:</p>
<ol>
<li>DB_ROw_ID:如果没有为表显式的定义主键，并且表中也没有定义唯一索引，那么InnoDB会自动为表添加一个row_id的隐藏列作为主键。</li>
<li>DB_TRX_ID∶每个事务都会分配一个事务ID，当对某条记录发生变更时，就会将这个事务的事务ID写入trx_id中。</li>
<li>DB_ROLL_PTR:回滚指针，本质上就是指向undo log的指针。</li>
</ol>
<p><img src="/images/20230629133802.png"></p>
<p><img src="/images/20230629133910.png"></p>
<p><img src="/images/20230629133945.png"><br>这时会把老的记录写入新的undo log，让回滚指针指向新的undo log，它的undo no是1，并且新的undo log会指向老的undo log (undo no=0)。</p>
<p><img src="/images/20230629134108.png"></p>
<p>对于更新主键的操作，会先把原来的数据deletemark标识打开，这时并没有真正的删除数据，真正的删除会交给清理线程去判断，然后在后面插入一条新的数据，新的数据也会产生undo log，并且undo log的序号会递增。</p>
<p>可以发现每次对数据的变更都会产生一个undo log，当一条记录被变更多次时，那么就会产生多条undo log,undo log记录的是变更前的日志，并且每个undo log的序号是递增的，那么当要回滚的时候，按照序号依次向前推，就可以找到我们的原始数据了。</p>
<h5 id="3-undo-log是如何回滚的"><a href="#3-undo-log是如何回滚的" class="headerlink" title="3. undo log是如何回滚的"></a>3. undo log是如何回滚的</h5><p>以上面的例子来说，假设执行rollback，那么对应的流程应该是这样:</p>
<ol>
<li>通过undo no=3的日志把id=2的数据删除</li>
<li>通过undo no=2的日志把id=1的数据的deletemark还原成o</li>
<li>通过undo no=1的日志把id=1的数据的name还原成Tom</li>
<li>通过undo no=0的日志把id=1的数据删除</li>
</ol>
<h5 id="4-undo-log的删除"><a href="#4-undo-log的删除" class="headerlink" title="4. undo log的删除"></a>4. undo log的删除</h5><p>·针对于insert undo log<br>因为insert操作的记录，只对事务本身可见，对其他事务不可见。故该undo log可以在事务提交后直接删除，不需要进行purge操作。</p>
<p>·针对于update undo log<br>该undo log可能需要提供MVCc机制，因此不能在事务提交时就进行删除。提交时放入undo log链表等待purge线程进行最后的删除。<br><img src="/images/20230629134625.png"></p>
<h3 id="3-小结"><a href="#3-小结" class="headerlink" title="3.小结"></a>3.小结</h3><p><img src="/images/20230629134833.png"></p>
<h2 id="一、存储引擎"><a href="#一、存储引擎" class="headerlink" title="一、存储引擎"></a>一、存储引擎</h2><p>在建表时指定存储引擎CREATE TABLE 表名 () ENGINE = INNODB</p>
<p>查看当前数据库支持的存储引擎</p>
<p>SHOW ENGINES;</p>
<h2 id="二、索引"><a href="#二、索引" class="headerlink" title="二、索引"></a>二、索引</h2><h3 id="1、索引"><a href="#1、索引" class="headerlink" title="1、索引"></a>1、索引</h3><p>索引(index)是帮助MYSQL高效获取数据的数据结构(有序)。</p>
<p>优势：提高数据检索的效率，降低数据库的IO成本；创建唯一索引，保证数据的唯一性；加速表与表之间的连接；减少查询中分组和排序的时间，通过索引列对数据进行排序，降低数据排序的成本，降低CPU的消耗。</p>
<p>劣势：创建索引和维护索引要耗费时间；索引列也是要占用空间的，存在磁盘上；索引大大提高了查询效率，同时却也降低更新表的速度，如对表进行INSERT、UPDATE、DELETE时，效率降低。</p>
<h3 id="2、索引结构"><a href="#2、索引结构" class="headerlink" title="2、索引结构"></a>2、索引结构</h3><p>B+Tree索引                最常见的索引类型，大部分引擎都支持B+树索引</p>
<p>Hash索引                    底层数据结构是用哈希表实现的，只有精确匹配索引列的查询才有效，不支持范围查询</p>
<p>R-tree(空间索引)        空间索引是MyISAM引擎的一个特殊索引类型，主要用于地理空间数据类型，通常使用较少</p>
<p>Full-text(全文索引)    是一种通过建立倒排索引，快速匹配文档的方式、类似于Lucene,Solr,ES</p>
<p>B+Tree</p>
<p>MYSQL索引数据结构对经典的B+Tree进行了优化。在原B+Tree的基础上，增加一个指向相邻叶子节点的链表指针，就形成了带有顺序指针的B+Tree，提高区间访问的性能。</p>
<p>Hash</p>
<p>哈希索引就是采用一定的hash算法，将键值换算成新的hash值，映射到对应的槽位上，然后存储在hash表中。</p>
<h3 id="3、索引分类"><a href="#3、索引分类" class="headerlink" title="3、索引分类"></a>3、索引分类</h3><p>主键索引                针对于表中主键创建的索引                                                            默认自动创建，只能有一个            PRIMARY</p>
<p>唯一索引                避免同一个表中某数据列中的值重复                                            可以有多个                                        UNIQUE</p>
<p>常规索引                快速定位特定数据                                                                            可以有多个                                    </p>
<p>全文索引                全文索引查找的是文本中的关键词，而不是比较索引中的值        可以有多个                                        FULLTEXT</p>
<p>根据索引的存储形式分类：</p>
<p>聚集索引(Clustered Index)                将数据存储与索引放到了一块，索引结构的叶子节点保存了行数据                必须有，而且只有一个</p>
<p>二级索引(Secondary Index)(辅助索引)                将数据与索引分开存储，索引结构的叶子节点关联的是对应的主键                可以存在多个</p>
<p>聚集索引选取规则：</p>
<p>如果存在主键，主键索引就是聚集索引。</p>
<p>如果不存在主键，将使用第一个唯一索引作为聚集索引。</p>
<h3 id="4、索引语法"><a href="#4、索引语法" class="headerlink" title="4、索引语法"></a>4、索引语法</h3><h4 id="A-创建索引"><a href="#A-创建索引" class="headerlink" title="A.创建索引"></a>A.创建索引</h4><p>CREATE [UNIQUE|FULLTEXT] INDEX index_name ON table_name (index_col_name,…);</p>
<p>such as:</p>
<p>CREATE INDEX idx_user_name ON tb_user(name);</p>
<p>CREATE UNIQUE INDEX idx_user_phone ON tb_user(phone);</p>
<p>CREATE INDEX idx_user_pro_age_ata ON tb_user(profession,age,status);</p>
<h4 id="B-查看索引"><a href="#B-查看索引" class="headerlink" title="B.查看索引"></a>B.查看索引</h4><p>SHOW INDEX FROM table_name;</p>
<h4 id="C-删除索引"><a href="#C-删除索引" class="headerlink" title="C.删除索引"></a>C.删除索引</h4><p>DROP INDEX index_name ON table_name;</p>
<h3 id="5、SQL性能分析"><a href="#5、SQL性能分析" class="headerlink" title="5、SQL性能分析"></a>5、SQL性能分析</h3><p>SQL执行频率</p>
<p>SHOW GLOBAL STATUS LIKE ‘Com______’;</p>
<p>慢查询日志</p>
<p>/etc/my,cnf</p>
<p>#开启Mysql慢日志查询开关</p>
<p>slow_query_log = 1</p>
<p>#设置慢日志的时间为2秒，SQL语句执行时间超过2秒，就会视为慢查询，记录慢查询日志</p>
<p>long_query_time=2</p>
<p>profile详情</p>
<p>show profiles 能够在做SQL优化时帮助我们了解时间耗费。通过having_profiling参数，能够看到当前Mysql是否支持profile操作：</p>
<p>SELECT @@have_profiling;</p>
<p>通过set语句在session/global级别开启profiling:</p>
<p>SET profiling=1;</p>
<p>explain执行计划</p>
<p>EXPLAIN或者DESC命令获取Mysql如何执行SELECT语句的信息，包括在SELECT语句执行过程中表如何连接和连接的顺序。</p>
<p>explain select 字段列表 from 表名 where 条件;</p>
<p>EXPLAIN执行计划各字段含义：</p>
<p>id：select查询的序列号，表示查询中执行select子句或者是操作表的顺序(id相同，执行顺序从上到下；id不同，值越大，越先执行)。</p>
<p>select_type：表示SELECT的类型，常见的取值有SIMPLE(简单表，即不是用表连接或者子查询)、PRIMARY(主查询，即外层的查询)、UNION(UNION中的第二个或者后面的查询语句)、SUBQUERY(SELECT/WHERE之后包含了子查询)等</p>
<p>type：表示连接类型，性能由好到差的连接类型为NULL、system、const、eq_ref、ref、range、index、all。</p>
<p>possible_key</p>
<p>显示可能应用在这张表上的索引，一个或多个。</p>
<p>key：实际使用的索引，如果为NULL,则没有使用索引。</p>
<p>key_len：表示索引中使用的字节数，该值为索引字段最大可能长度，并非实际使用长度，在不损失精确性的前提下，长度越短越好。</p>
<p>rows：MySQL认为必须要执行查询的行数，在innodb引擎的表中，是一个估计值，可能并不总是精确的。</p>
<p>filtered：表示返回结果的行数占需读取行数的百分比，filtered的值越大越好。</p>
<h3 id="6-索引使用"><a href="#6-索引使用" class="headerlink" title="6.索引使用"></a>6.索引使用</h3><h4 id="验证索引效率"><a href="#验证索引效率" class="headerlink" title="验证索引效率"></a>验证索引效率</h4><p>先CREATE INDEX INDEX_ ON TABLENAME();</p>
<h4 id="最左前缀法则-最左匹配"><a href="#最左前缀法则-最左匹配" class="headerlink" title="最左前缀法则(最左匹配)"></a>最左前缀法则(最左匹配)</h4><p>如果索引了多列（<strong>联合索引</strong>），要遵守最左前缀法则。最左前缀法则指的是查询从索引的最左列开始，并且不跳过索引中的列。</p>
<p>如果跳跃某一列，索引将部分失效（后面的字段索引失效）。</p>
<h4 id="范围查询"><a href="#范围查询" class="headerlink" title="范围查询"></a>范围查询</h4><p>联合索引中，出现范围查询(&gt;,&lt;)，范围查询右侧的列索引失效，加上=可能有用。</p>
<h4 id="索引列运算"><a href="#索引列运算" class="headerlink" title="索引列运算"></a>索引列运算</h4><p>不要在索引列上进行运算操作，索引将失效。</p>
<h4 id="字符串不加引号"><a href="#字符串不加引号" class="headerlink" title="字符串不加引号"></a>字符串不加引号</h4><p>字符串类型字段使用时，不加引号，索引将失效。</p>
<h4 id="模糊查询"><a href="#模糊查询" class="headerlink" title="模糊查询"></a>模糊查询</h4><p>如果仅仅是尾部模糊匹配，索引不会失效。如果是头部模糊匹配，索引失效。</p>
<h4 id="or连接的条件"><a href="#or连接的条件" class="headerlink" title="or连接的条件"></a>or连接的条件</h4><p>用or分割开的条件，如果or前的条件中的列有索引，而后面的列中没有索引，那么涉及的索引都不会被用到。</p>
<h4 id="数据分布影响"><a href="#数据分布影响" class="headerlink" title="数据分布影响"></a>数据分布影响</h4><p>如果Mysql评估使用索引比全表更慢，则不使用索引。</p>
<h4 id="SQL提示"><a href="#SQL提示" class="headerlink" title="SQL提示"></a>SQL提示</h4><p>SQL提示，是优化数据库的一个重要手段，简单来说，就是在SQL语句中加入一些人为的提示来达到优化操作的目的。</p>
<p>use index、ignore index、force index</p>
<p>explain select * from tb_user use index(idx_user_pro) where profession=’sss’;</p>
<h4 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h4><p>尽量使用覆盖索引(查询使用了索引，并且需要返回的列，在该索引中已经全部能够找到)，减少select *。（联合索引中各列）</p>
<p>using index condition：查找使用了索引，但是需要回表查询数据；使用的是二级索引，二级索引叶子节点下方存的是聚集索引，根据聚集索引再次查找就是回表。select 后面的数据在查找树中没有，根据叶子对应的聚集索引回去查找（可以建立联合索引解决）</p>
<p>using where;using index：查找使用了索引，但是需要的数据都在索引列中能找到，所以不需要回表查询数据；</p>
<h4 id="前缀索引"><a href="#前缀索引" class="headerlink" title="前缀索引"></a>前缀索引</h4><p>当字段类型为字符串（varchar,text）时，有时候需要索引很长的字符串，这会让索引变得很大，查询时，浪费大量的磁盘IO,影响查询效率。此时可以只将字符串的一部分前缀，建立索引，这样可以大大节约索引空间，从而提高索引效率。</p>
<p>CREATE INDEX IDX_XXX ON TABLE_NAME(COLUMN(N));</p>
<p>前缀长度</p>
<p>可以根据索引的选择性来决定，而选择性是指不重复的索引值（基数）和数据表的记录总数的比值，索引选择性越高则查询效率越高，唯一索引的选择性是1，这是最好的索引选择性，性能也是最好的。</p>
<p>select count(distinct email) / count(*) from tb_user;</p>
<p>select count(distinct substring(email, 1, 5)) / count(*) from tb_user;</p>
<p>select * from tb_user where email=’ssss’;</p>
<h4 id="单列索引与联合索引"><a href="#单列索引与联合索引" class="headerlink" title="单列索引与联合索引"></a>单列索引与联合索引</h4><p>单列索引：即一个索引只包含单个列。</p>
<p>联合索引：即一个索引包含了多个列。</p>
<p>在业务场景中，如果存在多个查询条件，考虑针对于查询字段建立索引时，建议建立联合索引，而非单列索引。</p>
<h4 id="索引设计原则"><a href="#索引设计原则" class="headerlink" title="索引设计原则"></a>索引设计原则</h4><p>1.针对于数据量较大，且查询比较频繁的表建立索引。</p>
<p>2.针对于常作为查询条件（where)、排序(ORDER BY)、分组(GROUP BY)操作的字段建立索引。</p>
<p>3.尽量选择区分度高的列作为索引，尽量建立唯一索引，区分度越高，使用索引的效率越高。</p>
<p>4.如果是字符串类型的字段，字段的长度较长，可以针对于字段的特点，建立前缀索引。</p>
<p>5.尽量使用联合索引，减少单列索引，查询时，联合索引很多时候可以覆盖索引，节省存储空间，避免回表，提高查询效率。</p>
<p>6.要控制索引的数量，索引不是多多益善，索引越多，维护索引结构的代价也就越大，会影响增删改的效率。</p>
<p>7.如果索引列不能存储NULL值，请在创建表时使用NOT NULL约束它。当优化器知道每列是否包含NULL值时，它可以更好地确定哪个索引最有效地用于查询。</p>
<h1 id="SQL优化策略"><a href="#SQL优化策略" class="headerlink" title="SQL优化策略"></a>SQL优化策略</h1><h2 id="1-索引失效"><a href="#1-索引失效" class="headerlink" title="1.索引失效"></a>1.索引失效</h2><p>1.全值匹配</p>
<p>2.最左前缀法则</p>
<p>对于多列索引，过滤条件要使用索引必须按照索引建立时的顺序，依次满足，一旦跳过某个字段，索引后面的字段都无法被使用。如果查询条件中没有使用这些字段中第一个字段时，多列（或联合）索引不会被使用。</p>
<p>3.主键插入顺序</p>
<p>插入乱序的话数据页满后当前页面分裂成两个页面，把本页中的一些记录移动到新创建的这个页中，这会造成性能损耗，所以最好插入的记录的主键值依次递增</p>
<p>4.计算、函数、类型转换（自动或手动）导致索引失效</p>
<p>查询条件最好不要进行计算，函数、类型转换，这样会全部取出做运算，导致索引失效</p>
<p>5.类型转换导致索引失效</p>
<p>转换需要全部取出转换比对，索引失效</p>
<p>6.范围条件右边的列索引失效</p>
<p>范围查找根据是根据索引顺序来的，和查找条件顺序无关；范围右边的索引会导致失效，解决的话创建索引时顺序先按照确定值在前的顺序来创建。</p>
<p>7.不等于(!=或者&lt;&gt;)索引失效</p>
<p>需要全部查找，</p>
<p>8.is null可以使用索引，is not null无法使用索引</p>
<p>解决方法最好在设计数据表的时候就将字段设置为NOT NULL约束，比如将INT类型字段，默认设置为0.将字符类型的默认值设置为空字符串。</p>
<p>在查询中使用not like 也无法使用索引，导致全表扫描</p>
<p>9.like以通配符%开头索引失效</p>
<p>在使用like关键字进行查询的查询语句中，如果匹配字符串的第一个字符为”%”，索引不会起作用。只有”%”不在第一个位置，索引才会起作用。</p>
<p>页面搜索严禁左模糊或者全模糊。</p>
<p>10.OR前后存在非索引的列，索引失效</p>
<p>在WHERE子句中，如果在OR前的条件列进行了索引，而在OR后的条件列没有进行索引，那么索引会失效。</p>
<p>OR前后的两个条件中的列都是索引时，查询中才使用索引。</p>
<p>因为OR的含义就是两个只要满足一个即可，因此只有一个条件列进行了索引是没有意义的，只要有条件列没有进行索引，就会进行全表扫描，因此索引的条件列也会失效。</p>
<p>11.数据库和表的字符集统一使用utf8mb4</p>
<h3 id="一般性建议"><a href="#一般性建议" class="headerlink" title="一般性建议"></a>一般性建议</h3><p>1.对于单列索引，尽量选择针对当前query过滤性更好的索引</p>
<p>2.在选择组合索引的时候，当前query中过滤性最好的字段在索引字段顺序中，位置越靠前越好。</p>
<p>3.在选择组合索引的时候，尽量选择能够包含当前query中的where子句中更多字段的索引。</p>
<p>4.在选择组合索引的时候，如果某个字段可能出现范围查询时，尽量把这个字段放在索引次序的最后面。</p>
<h2 id="2-关联查询优化"><a href="#2-关联查询优化" class="headerlink" title="2.关联查询优化"></a>2.关联查询优化</h2><h5 id="1-内连接：相当于查询A、B交集部分数据-1"><a href="#1-内连接：相当于查询A、B交集部分数据-1" class="headerlink" title="(1)内连接：相当于查询A、B交集部分数据"></a>(1)内连接：相当于查询A、B交集部分数据</h5><p>​    隐式内连接</p>
<p>​    SELECT 字段列表 FROM 表1,表2 WHERE 条件 …;</p>
<p>​    显示内连接</p>
<p>​    SELECT 字段列表 FROM 表1 [INNER] JOIN 表2 ON 连接条件…;</p>
<p>对于内连接来说，查询优化器可以决定谁作为驱动表，谁作为被驱动表出现</p>
<p>对于内连接来说，如果表的连接条件中只有一个字段有索引，则有索引的字段所在的表会被作为被驱动表出现</p>
<p>对于内连接来说，在两个表的连接条件都存在索引的情况下，会选择小表作为驱动表。“小表驱动大表”。</p>
<h5 id="2-外连接：-1"><a href="#2-外连接：-1" class="headerlink" title="(2)外连接："></a>(2)外连接：</h5><h6 id="左外连接：查询左表所有数据，以及两张表交集部分的数据-1"><a href="#左外连接：查询左表所有数据，以及两张表交集部分的数据-1" class="headerlink" title="左外连接：查询左表所有数据，以及两张表交集部分的数据"></a>左外连接：查询左表所有数据，以及两张表交集部分的数据</h6><p>​    SELECT 字段列表 FROM 表1 LEFT [OUTER] JOIN 表2 ON 连接条件…;</p>
<h6 id="右外连接：查询右表所有数据，以及两张表交集部分数据-1"><a href="#右外连接：查询右表所有数据，以及两张表交集部分数据-1" class="headerlink" title="右外连接：查询右表所有数据，以及两张表交集部分数据"></a>右外连接：查询右表所有数据，以及两张表交集部分数据</h6><p>​    SELECT 字段列表 FROM 表1 RIGHT [OUTER] JOIN 表2 ON 连接条件…;</p>
<h5 id="3-自连接：当前表与自身的连接查询，自连接必须使用表别名-1"><a href="#3-自连接：当前表与自身的连接查询，自连接必须使用表别名-1" class="headerlink" title="(3)自连接：当前表与自身的连接查询，自连接必须使用表别名"></a>(3)自连接：当前表与自身的连接查询，自连接必须使用表别名</h5><p>​    SELECT 字段列表 FROM 表1 别名A,表2 别名B WHERE 条件 …;</p>
<p>​    SELECT 字段列表 FROM 表A 别名A JOIN 表A 别名B ON 条件 …;</p>
<p><strong>JOIN语句原理</strong></p>
<p>join方式连接多个表，本质就是各个表之间数据的循环匹配。mysql5.5之前，嵌套循环（Nested Loop Join)。mysql5.5之后，通过BNLJ算法来优化嵌套执行。</p>
<p>1.驱动表和被驱动表</p>
<p>驱动表就是主表，被驱动表就是从表、非驱动表。</p>
<p>对于内连接来说，优化器会根据查询语句做优化，决定先查哪张表，先查询的那张表就是驱动表，反之就是被驱动表。</p>
<p>对于外连接</p>
<p>select * from A LEFT JOIN B ON. ..</p>
<p>或select * from B RIGHT JOIN A ON…</p>
<p>通常会认为A是驱动表，B是被驱动表，但是也未必，可能优化器会优化为内连接，就变换了。</p>
<p>2.Simple Nested-Loop Join(简单嵌套循环连接)</p>
<p>算法相当简单，从表A中取出一条数据1，遍历表B，将匹配到的数据放到result。依次类推，驱动表A中的每一条记录与被驱动表B的记录进行判断，性能较差。</p>
<p>3.Index Nested-Loop Join(索引嵌套循环连接)</p>
<p>其优化的思路主要是为了减少内层表数据的匹配次数，所以要求被驱动表上必须有索引才行。通过外层表匹配条件直接与内层表索引进行匹配，避免和内层表的每条记录去进行比较，这样极大的减少了对内层表的匹配次数。</p>
<p>驱动表中的每条记录通过被驱动表的索引进行访问，因为索引查询的成本是比较固定的，故mysql优化器都倾向于使用记录数少的表作为驱动表（外表）。</p>
<p>如果被驱动表加索引，效果是非常高的，但如果索引不是主键索引，所以还得进行一次回表查询。相比，被驱动表的索引是主键索引，效率会更高。</p>
<p>4.Block Nested-Loop Join(块嵌套循环连接)</p>
<p>如果存在索引，那么会使用index的方式进行join，如果join的列没有索引，被驱动表要扫描的次数太多了。每次访问被驱动表，其表中的记录都会被加载到内存中，然后再从驱动表中取一条与其匹配，匹配结束后清除内存，然后再从驱动表中加载一条记录，然后把被驱动表的记录在加载到内存匹配，这样周而复始，大大增加了IO的次数。为了减少被驱动表的IO次数，就出现了Block Nested-Loop Join的方式。</p>
<p>不再是逐条获取驱动表的数据，而是一块一块的获取，引入了join buffer缓冲区，将驱动表join相关的部分数据列（大小受join buffer的限制）缓存到join buffer中，然后全表扫描被驱动表，被驱动表的每一条记录一次性和join buffer中的所有驱动表记录进行匹配（内存中操作），将简单嵌套循环中的多次比较合并成一次，降低了被驱动表的访问频率。</p>
<p>参数设置：</p>
<p>block_nested_loop</p>
<p>通过show variables like ‘%optimizer_switch%’ 查看block_nested_loop状态，默认是开启的。</p>
<p>join_buffer_size</p>
<p>默认情况下join_buffer_size = 256k。</p>
<p>5.Join小结</p>
<p>1.整体效率：INLJ&gt;BNLJ&gt;SNLJ</p>
<p>2.永远用小结果集驱动大结果集（其本质就是减少外层循环的数据数量）（小的度量单位指的是 表行数*每行大小）</p>
<p>select t1.b t2.* from t1 straight_join t2 on (t1.b=t2.b) where t2.id &lt;=100;  推荐</p>
<p>select t1.b t2.* from t2 straight_join t1 on (t1.b=t2.b) where t2.id &lt;=100;  不推荐</p>
<p>3.为被驱动表匹配的条件增加索引（较少内层表的循环匹配次数）</p>
<p>4.增大join buffer size的大小（一次缓存的数据越多，那么内层包的扫表次数就越少）</p>
<p>5.减少驱动表不必要的字段查询（字段越少，join buffer所缓存的数据就越多）</p>
<p>6.hash join</p>
<p>废弃BNLJ，加入hash join</p>
<p>Nested Loop:</p>
<p>对于被连接的数据子集较小的情况，Nested Loop是个较好的选择。</p>
<p>Hash Join是大数据集连接时的常用方式，优化器使用两个表中较小（相对较小）的表利用Join Key在内存中建立散列表，然后扫描较大的表并探测散列表，找出与Hash表匹配的行。</p>
<p>​    1.这种方式适用于较小的表完全可以放于内存中的情况，这样总成本就是访问两个表的成本之和。</p>
<p>​    2.在表很大的情况下并不能完全放入内存，这时优化器会将它分割成若干不同的分区，不能放入内存的部分就把该分区写入磁盘的临时段，此时要求有较大的临时段从而尽量提高I/O的性能。</p>
<p>​    3.它能够很好的工作于没有索引的大表和并行查询的环境中，并提供最好的性能。大多数人都说它是Join的重型升降机。Hash Join只能应用于等值连接，这是由Hash的特点决定的。</p>
<h2 id="3-子查询优化"><a href="#3-子查询优化" class="headerlink" title="3.子查询优化"></a>3.子查询优化</h2><p>子查询可以进行SELECT语句的嵌套查询，即一个SELECT查询的结果作为另一个SELECT语句的条件。子查询可以一次性完成很多逻辑上需要多个步骤才能完成的SQL操作。</p>
<p>子查询效率不高，原因：</p>
<p>1.执行子查询时，Mysql需要为内层查询语句的查询结果建立一个临时表，然后外层查询语句从临时表中查询记录。查询完毕后，再撤销这些临时表。这样会消耗过多的CPU和IO资源，产生大量的慢查询。</p>
<p>2.子查询的结果集存储的临时表，不论是内存临时表还是磁盘临时表都不会存在索引，所以查询性能会受到一定的影响。</p>
<p>3.对于返回结果集比较大的子查询，其对查询性能的影响也就越大。</p>
<p>在MYSQL中，可以使用连接（Join）查询来代替子查询。连接查询不需要建立临时表，其速度比子查询要快，如果查询中使用索引的话，性能就会更好。</p>
<p>尽量不要使用NOT IN 或者NOT EXISTS，用LEFT JOIN xxx ON xx WHERE xx IS NULL替代。</p>
<h2 id="4-排序优化"><a href="#4-排序优化" class="headerlink" title="4.排序优化"></a>4.排序优化</h2><h3 id="1-排序优化"><a href="#1-排序优化" class="headerlink" title="1.排序优化"></a>1.排序优化</h3><p>问题：在WHERE条件字段上加上索引，但是为什么在ORDER BY字段上还要加索引呢？</p>
<p>回答：</p>
<p>在MYSQL中，支持两种排序方式，分别是FileSort和Index排序。</p>
<p>​    1.Index排序中，索引可以保证数据的有序性，不需要再进行排序，效率更高。</p>
<p>​    2.FileSort排序则一般在内存中进行排序，占用CPU较多。如果待排结果较大，会产生临时文件I/O到磁盘进行排序的情况，效率较低。</p>
<p>优化建议：</p>
<p>1.SQL中，可以在WHERE子句和ORDER BY子句中使用索引，目的是在WHERE子句中避免全表扫描，在ORDER BY子句避免使用FileSort排序。当然，某些情况下全表扫描，或者FileSort排序不一定比索引慢。但总的来说，我们还是要避免，以提高查询效率。</p>
<p>2.尽量使用Index完成ORDER BY排序。如果WHERE和ORDER BY后面是相同的列就使用单索引列；如果不同就使用联合索引。</p>
<p>3.无法使用Index时，需要对FileSort方式进行调优。</p>
<h3 id="2-失效案例："><a href="#2-失效案例：" class="headerlink" title="2.失效案例："></a>2.失效案例：</h3><p>1.无索引</p>
<p>2.order by时不limit，索引失效</p>
<p>select * from student order by age, classid;    索引失效，数据量过大，*全部字段，因此会回表查找</p>
<p>select * from student order by age, classid limit 10;    数据量比较小，用索引</p>
<p>3.order by 时顺序错误，索引失效</p>
<p>要满足最左前缀法则</p>
<p>4.order by时规则不一致，索引失效（顺序错，不索引；方向反，不索引）</p>
<p>5.无过滤，不索引</p>
<h3 id="3-filesort算法：双路排序和单路排序"><a href="#3-filesort算法：双路排序和单路排序" class="headerlink" title="3.filesort算法：双路排序和单路排序"></a>3.filesort算法：双路排序和单路排序</h3><p>排序的字段若如果不在索引列上，则filesort会有两种算法：双路排序和单路排序</p>
<p><strong>双路排序（慢）</strong></p>
<p>​    1.两次扫描磁盘，最终得到数据，读取行指针和order by 列，对他们进行排序，然后扫描已经排序好的列表，按照列表中的值重新从列表中读取对应的数据输出。</p>
<p>​    2.从磁盘取排序字段，在buffer进行排序，再从磁盘取其他字段。</p>
<p>取一批数据，对磁盘进行两次扫描，I/O很耗时。改进为单路排序。</p>
<p><strong>单路排序（快）</strong></p>
<p>从磁盘读取查询需要的所有列，按照order by列在buffer对他们进行排序，然后扫描排序后的列表进行输出，它的效率更快一些，避免了第二次读取数据。并且把随机IO变成了顺序IO，但是它会使用更多的空间，因为它把每一行都保存在内存中了。</p>
<p><strong>结论及引申问题</strong></p>
<p>1.单路总体好过双路</p>
<p>2.单路也有问题：</p>
<p>​    1.在sort_buffer中，单路比多路要多占用很多空间，因为单路是把所有字段都取出，所以有可能取出的数据的总大小超出了sort_buffer的容量，导致每次只能取sort_buffer容量大小的数据，进行排序（创建tmp文件，多路合并），排完再取sort_buffer容量大小，再排…从而多次I/O。</p>
<p>​    2.单路本来想省一次I/O操作，反而导致了大量的I/O操作，反而得不偿失。</p>
<p>优化策略：提高sort_buffer大小、提高max_length_for_sort_data、select需要的字段</p>
<h2 id="5-GROUP-BY优化"><a href="#5-GROUP-BY优化" class="headerlink" title="5.GROUP BY优化"></a>5.GROUP BY优化</h2><p>1.group by使用索引的原则几乎根order by一致，group by即使没有过滤条件用到索引，也可以直接使用索引。</p>
<p>2.group by先排序再分组，遵照索引键的最左前缀法则</p>
<p>3.当无法使用索引列时，增大max_length_for_sort_data和sort_buffer_size参数的设置</p>
<p>4.where效率高于having，能写在where限定的条件就不要写在having中了</p>
<p>5.减少使用order by,和业务沟通能不排序就不排序，或将排序放到程序端去做。order by、group by、distinct这些语句较为耗费CPU，数据库的CPU资源是及其宝贵的。</p>
<p>6.包含了order by、group by、distinct这些查询的语句，where条件过滤出来的结果集请保持在1000行以内，否则SQL会很慢。</p>
<h2 id="6-优化分页查询"><a href="#6-优化分页查询" class="headerlink" title="6.优化分页查询"></a>6.优化分页查询</h2><p>一般分页查询时，通过创建覆盖索引能够比较好地提升性能。常见头疼的问题是limit 2000000， 10，此时需要mysql排序前2000010记录，仅仅返回2000000-2000010的记录，其他记录丢弃，查询排序的代价非常大。</p>
<p>优化思路：</p>
<p>1.在索引上完成排序分页操作，最后根据主键关联回原表查询所需要的其他列内容</p>
<p>select * from student t,(select id from student order by id limit 2000000,10) a where t.id = a.id;</p>
<p>2.该方案适用于主键自增的表，可以把limit查询转换成某个位置的查询。</p>
<p>select * from student where id &gt; 2000000 limit 10;</p>
<h2 id="7-优先考虑覆盖索引"><a href="#7-优先考虑覆盖索引" class="headerlink" title="7.优先考虑覆盖索引"></a>7.优先考虑覆盖索引</h2><p>1.一个索引包含了满足查询结果的数据就叫做覆盖索引。</p>
<p>索引列+主键包含select 到 from 之间查询的列。</p>
<p>2.覆盖索引利弊</p>
<p>好处：</p>
<p>1.避免Innodb表进行索引的二次查询（回表）</p>
<p>Innodb是以聚集索引的顺序来存储的，对于Innodb来说，二级索引在叶子节点中所保存的是行的主键信息，如果是用二级索引查询数据，在查找到相应的键后，还需通过主键进行二次查询才能获取我们真实所需要的数据。在覆盖索引中，二级索引的键值可以获取所要的数据，避免了对主键的二次查询，减少了IO操作，提升了查询效率。</p>
<p>2.可以把随机IO变成顺序IO加快查询效率。</p>
<p>由于覆盖索引是按键值的顺序存储的，对于IO密集型的范围查找来说，对比随机从磁盘读取每一行的数据IO要少的多，因此利用覆盖索引在访问时也可以把磁盘的随机读取的IO转变成索引查找的顺序IO。</p>
<p>弊端：</p>
<p>索引字段的维护总是有代价的。因此，在建立冗余索引来支持覆盖索引时就需要权衡考虑了。</p>
<h2 id="8-字符串添加索引，前缀索引"><a href="#8-字符串添加索引，前缀索引" class="headerlink" title="8.字符串添加索引，前缀索引"></a>8.字符串添加索引，前缀索引</h2><h2 id="9-索引条件下推（ICP）"><a href="#9-索引条件下推（ICP）" class="headerlink" title="9.索引条件下推（ICP）"></a>9.索引条件下推（ICP）</h2><p>Index Condition Pushdown(ICP)是mysql新特性，是一种在存储引擎层使用索引过滤数据的优化方式。</p>
<p>1.如果没有ICP，存储引擎会遍历索引以定位基表中的行，并将它们返回给mysql服务器，由mysql服务器评估WHERE后面的条件是否保留行。</p>
<p>2.启用ICP后，如果部分WHERE条件可以仅适用索引中的列进行筛选，则mysql服务器会把这部分WHERE条件放到存储引擎筛选。然后，存储引擎通过使用索引条目来筛选数据，并且只有在满足这一条件时才从表中读取行。</p>
<p>​    1.好处：ICP可以减少存储引擎必须访问基表的次数和mysql服务器必须访问存储引擎的次数。</p>
<p>​    但是，ICP的加速效果取决于在存储引擎内通过ICP筛选掉的数据的比例。</p>
<p>就是在联合索引中，where条件中前面满足可索引的条件，后面的条件不满足索引条件不能用索引（索引失效），前面条件查询完后先不要回表查询，是放到存储引擎中，再对后面条件进行筛选，然后回表。这样回表的次数减少了，随机IO次数也可能减少了。</p>
<h3 id="ICP的开启和关闭"><a href="#ICP的开启和关闭" class="headerlink" title="ICP的开启和关闭"></a>ICP的开启和关闭</h3><p>关闭索引下推</p>
<p>set optimizer_switch = ‘index_condition_pushdown = off’;</p>
<p>打开索引下推</p>
<p>set optimizer_switch = ‘index_condition_pushdown = on’;</p>
<p>ICP的使用条件</p>
<p>1.如果表访问的类型为range、ref、eq_ref和ref_or_null可以使用ICP</p>
<p>2.ICP可以用于InnoDB和myISAM表，包括分区表InnoDB和MyISAM表</p>
<p>3.对于InnoDB表，ICP仅用于二级索引。ICP的目标是减少全行读取次数，从而减少I/O操作。（聚集索引不需要回表）</p>
<p>4.当SQL使用覆盖索引时，不支持ICP。因为这种情况下使用ICP不会减少I/O。（覆盖索引也不需要回表）</p>
<p>5.相关子查询的条件不能使用ICP。</p>
<h2 id="10-其它查询优化策略"><a href="#10-其它查询优化策略" class="headerlink" title="10.其它查询优化策略"></a>10.其它查询优化策略</h2><h3 id="1-EXISTS和IN的区分"><a href="#1-EXISTS和IN的区分" class="headerlink" title="1.EXISTS和IN的区分"></a>1.EXISTS和IN的区分</h3><p>问题：</p>
<p>不太理解哪种情况应该使用呢EXISTS,哪种情况应该用IN。选择的标准是看能否使用表的索引吗？</p>
<p>回答：</p>
<p>索引是个前提，其实选择与否还是要看表的大小。你可以将选择的标准理解为小表驱动大表。在这种方式下效率是最高的。</p>
<h3 id="2-count-与count-具体字段-效率"><a href="#2-count-与count-具体字段-效率" class="headerlink" title="2.count(*)与count(具体字段)效率"></a>2.count(*)与count(具体字段)效率</h3><p>问：在mysql中统计数据表的行数，可以用三种方式：select count(*)、select count(1)、select count(具体字段)，使用这三者之间的查询效率怎样？</p>
<p>答：</p>
<p>前提：如果你要统计的是某个字段的非空数据行数，则另当别论，毕竟比较执行效率的前提是结果一样才可以。</p>
<p>环节1：count(*)和count(1)都是对所有结果进行count；count(**)和count(1)本质上并没有区别（二者执行时间可能略有差别，不过你还是可以把它两的执行效率看成是相等的）。如果有WHERE子句，则是对所有符合筛选条件的数据行进行统计；如果没有WHERE子句，则是对数据表的数据行数进行统计。</p>
<p>环节2：如果是MyISAM存储引擎，统计数据表的行数只需要O(1)的复杂度，这是因为每张MyISAM的数据表都有一个meta信息存储了row_count值，而一致性则由表级锁来保证。</p>
<p>如果是InnoDB存储引擎，因为InnoDB支持事务，采用行级锁和MVCC机制，所以无法像MyISAM一样，维护一个row_count变量，因此需要采用扫描全表，是O(n)的复杂度，进行循环+计数的方式来完成统计。</p>
<p>环节3：在InnoDB引擎中，如果采用COUNT(具体字段)来统计数据行数，要尽量采用二级索引。因为主键采用的索引是聚簇索引，聚簇索引包含的信息多，明显会大于二级索引（非聚簇索引）。对于count(*)和count(1)来说，它们不需要查找具体的行，只是统计行数，系统会自动采用占用空间更小的二级索引来进行统计。</p>
<p>如果有多个二级索引，会使用key_len小的二级索引进行扫描。当没有二级索引的时候，才会采用主键索引来进行统计。</p>
<h3 id="3-关于SELECT"><a href="#3-关于SELECT" class="headerlink" title="3.关于SELECT(*)"></a>3.关于SELECT(*)</h3><p>在表查询中，建议明确字段，不要使用*作为查询的字段列表，推荐使用SELECT&lt;字段列表&gt;查询。原因：</p>
<p>1.MYSQL在解析的过程中，会通过查询数据字典将”*”按序转换成所有列名，这会大大的耗费资源和时间。</p>
<p>2.无法使用覆盖索引</p>
<h3 id="4-LIMIT-1对优化的影响"><a href="#4-LIMIT-1对优化的影响" class="headerlink" title="4.LIMIT 1对优化的影响"></a>4.LIMIT 1对优化的影响</h3><p>针对的是会扫描全表的SQL语句，如果你可以确定结果集只有一条，那么加上LIMIT 1的时候，当找到一条结果的时候就不会继续扫描了，这样会加快查询速度。</p>
<p>如果数据表已经对字段建立了唯一索引，那么可以通过索引进行查询，不会全表扫描的话，就不需要加上LIMIT 1了。</p>
<h3 id="5-多使用COMMIT"><a href="#5-多使用COMMIT" class="headerlink" title="5.多使用COMMIT"></a>5.多使用COMMIT</h3><p>只要有可能，在程序中尽量多使用COMMIT，这样程序的性能得到提高，需求也会因为COMMIT所释放的资源而减少。</p>
<p>COMMIT所释放的资源：</p>
<p>​    1.回滚段上用于恢复数据的信息</p>
<p>​    2.被程序语句获得的锁</p>
<p>​    3.redo/undo log buffer中的空间</p>
<p>​    4.管理上述3种资源中的内部花费</p>
<h1 id="淘宝数据库主键设计"><a href="#淘宝数据库主键设计" class="headerlink" title="淘宝数据库主键设计"></a>淘宝数据库主键设计</h1><h2 id="1-自增ID问题"><a href="#1-自增ID问题" class="headerlink" title="1.自增ID问题"></a>1.自增ID问题</h2><p>自增ID做主键，简单易懂，几乎所有数据库都支持自增类型，只是实现上各有所不同而已。自增ID除了简单，其它都是缺点，总体来说存在以下几方面问题：</p>
<p>1.可靠性不高</p>
<p>存在自增ID回溯的问题，8.0修复</p>
<p>2.安全性不高</p>
<p>对外暴露的接口可以非常容易猜测对应的信息。不如：/user/1/这样的接口，可以非常容易猜测用户ID的值为多少，总数量有多少，也可以非常容易地通过接口进行数据的爬取。</p>
<p>3.性能差</p>
<p>自增ID的性能较差，需要在数据库服务器端生成。</p>
<p>4.交互多</p>
<p>业务还需要额外执行一次类似last_insert_id()的函数才能知道刚才插入的自增值，这需要多一次的网络交互。在海量并发的系统中，多一条SQL，就多一次性能上的开销。</p>
<p>5.局部唯一性</p>
<p>最重要的一点，自增ID是局部唯一，只在当前数据库实例中唯一，而不是全局唯一，在任意服务器间都是唯一的。对于目前分布式系统来说，这简直就是噩梦。</p>
<h2 id="2-业务字段做主键"><a href="#2-业务字段做主键" class="headerlink" title="2.业务字段做主键"></a>2.业务字段做主键</h2><p>为了能够唯一地标识一个会员的信息，需要为会员信息表设置一个主键。那么，怎么为这个表设置主键，才能达到我们理想的目标呢？这里我们考虑业务字段做主键。</p>
<p>会员号、电话号、重新收回分配会出问题；身份证号隐私，设计表时允许身份证号和电话都为空。</p>
<p>所以，建议尽量不要用跟业务有关的字段做主键。</p>
<h2 id="3-淘宝主键设计"><a href="#3-淘宝主键设计" class="headerlink" title="3.淘宝主键设计"></a>3.淘宝主键设计</h2><p>订单ID = 时间 + 去重字段 +用户ID后6位尾号</p>
<h2 id="4-推荐主键设计"><a href="#4-推荐主键设计" class="headerlink" title="4.推荐主键设计"></a>4.推荐主键设计</h2><p>非核心业务：对应表的主键自增ID，如告警、日志、监控等信息。</p>
<p>核心业务：主键设计至少应该是全局唯一且是单调递增。全局唯一保证在各系统之间都是唯一的，单调递增是希望插入时不影响数据库性能。</p>
<p>最简单的一种主键设计：UUID（<strong>U</strong>niversally <strong>U</strong>nique <strong>Id</strong>entifier 通用唯一识别码）</p>
<p><strong>UUID特点</strong>：全局唯一，占用36字节，数据无序，插入性能差。</p>
<p><strong>认识UUID:</strong></p>
<p>MYSQL数据库UUID组成：</p>
<p>UUID = 时间 + UUID版本（16字节）- 时钟序列（4字节）- MAC地址（12字节）</p>
<p>时间低位32位+时间中位16位+时间高位12位+UUID版本4位</p>
<p>为什么UUID是全局唯一的？</p>
<p>在UUID中时间部分占用60位，存储的类似TIMESTAMP的时间戳，但表示的是从1582-10-15 00：00：00.00到现在的100ns的计数。可以看到UUID存储的时间精度比TIMESTAMPE更高，时间维度发生重复的概率降低到1/100ns。</p>
<p>时钟序列是为了避免时钟被回拨导致产生时间重复的可能性。MAC地址用于全局唯一。</p>
<p>为什么UUID占用36字节？</p>
<p>UUID根据字符串进行存储，设计时还带有无用”-“字符串，因此总共需要36字节。</p>
<p>为什么UUID是随机无序的呢?</p>
<p>因为UUID的设计中，将时间低位放在最前面，而这部分的数据是一直在变化的，并且是无序。</p>
<p><strong>改造UUID:</strong></p>
<p>若将时间高低位互换，则时间就是单调递增的了，也就变得单调递增了。MYSQL8.0可以更换时间低位和时间高位的存储方式，这样UUID就是有序的UUID了。</p>
<p>MYSQL8.0还解决了UUID存在的空间占用的问题，除去了UUID字符串中无意义的”-“字符串，并且将字符串用二进制类型保存，这样存储空间降低为了16字节。</p>
<p>可以通过MYSQL8.0提供的uuid_to_bin函数实现上述功能，同样的，MYSQL也提供了bin_to_uuid函数进行转化：</p>
<p>set @uuid = UUID();</p>
<p>SELECT @uuid,uuid_to_bin(@uuid),uuid_to_bin(@uuid,TRUE);</p>
<h2 id="三、SQL优化"><a href="#三、SQL优化" class="headerlink" title="三、SQL优化"></a>三、SQL优化</h2><p>SQL查询优化</p>
<p><strong>物理查询优化</strong></p>
<p>通过索引和表连接方式等技术来进行优化</p>
<p><strong>逻辑查询优化</strong></p>
<p>通过SQL等价变换提升查询效率</p>
<h3 id="1、插入数据"><a href="#1、插入数据" class="headerlink" title="1、插入数据"></a>1、插入数据</h3><h4 id="A-INSERT-优化"><a href="#A-INSERT-优化" class="headerlink" title="A.INSERT 优化"></a>A.INSERT 优化</h4><p>1.批量插入</p>
<p>insert into tb_test values(),(),()</p>
<p>2.手动提交事务</p>
<p>start transaction;</p>
<p>insert …</p>
<p>commit;</p>
<p>3.主键顺序插入</p>
<h4 id="B-大批量插入数据"><a href="#B-大批量插入数据" class="headerlink" title="B.大批量插入数据"></a>B.大批量插入数据</h4><p>如果一次性需要插入大批量数据，使用insert语句插入性能较低，此时可以使用Mysql数据库提供的load指令进行插入。操作如下：</p>
<p>#客户端连接服务器时，加上参数 –local-infile</p>
<p>mysql –local-infile -u root -p</p>
<p>#设置全局参数local_infile为1，开启从本地加载文件导入数据的开关</p>
<p>set global local_infile = 1;</p>
<p>#执行load指令将准备好的数据，加载到表结构中</p>
<p>load data local infile ‘/root/sql.log’ into table ‘tb_user’ fields terminated by ‘,’ lines teminated by ‘\n’;</p>
<p>主键顺序插入性能高于乱序插入</p>
<h3 id="2、主键优化"><a href="#2、主键优化" class="headerlink" title="2、主键优化"></a>2、主键优化</h3><h4 id="数据组织方式"><a href="#数据组织方式" class="headerlink" title="数据组织方式"></a>数据组织方式</h4><p>在InnoDB存储引擎中，表数据都是根据主键顺序组织存放的，这种存储方式的表称为索引组织表(index organized table IOT)。</p>
<p>InnoDB逻辑存储结构</p>
<p>TableSpace：表空间</p>
<p>Segment：段</p>
<p>Extent：区（1M）64页</p>
<p>Page：页（16K）</p>
<p>Row：行</p>
<h4 id="页分裂"><a href="#页分裂" class="headerlink" title="页分裂"></a>页分裂</h4><p>页可以为空，也可以填充一半，也可以填充100%。每个页包含了2-N行数据(如果一行数据过大，会行溢出)，根据主键排列。</p>
<p>某一个页填满之后，继续插入叶子节点，会新开一个页，将满的页从中间分开填充到新开的页，再插入叶子节点，而且还需要调整页指针指向。</p>
<h4 id="页合并"><a href="#页合并" class="headerlink" title="页合并"></a>页合并</h4><p>当删除一行记录时，实际上记录并没有被物理删除，只是记录被标记(flaged)为删除并且它的空间变得允许被其他记录声明使用。</p>
<p>当页中删除的记录达到MERGE_THRESHOLD(默认为页的50%)，InnoDB会开始寻找最近的页（前或后）看看是否可以将两个页合并以优化空间使用。</p>
<h4 id="主键设计原则"><a href="#主键设计原则" class="headerlink" title="主键设计原则"></a>主键设计原则</h4><p>满足业务需求的情况下，尽量降低主键的长度。</p>
<p>插入数据时，尽量选择顺序插入，选择使用AUTO_INCREMENT自增主键。</p>
<p>尽量不要使用UUID做主键或者是其他自然主键，如身份证号。</p>
<p>业务操作时，避免对主键的修改。</p>
<h3 id="3-order-by优化"><a href="#3-order-by优化" class="headerlink" title="3.order by优化"></a>3.order by优化</h3><p>Using filesort：通过表的索引或全表扫描，读取满足条件的数据行，然后在排序缓冲区sort buffer中完成排序操作，所有不是通过索引直接返回排序结果的排序都叫FileSort排序。</p>
<p>Using index：通过有序索引顺序扫描直接返回有序数据，这种情况即为using index,不需要额外排序，操作效率高。</p>
<p>#没有创建索引时，根据age,phone进行排序</p>
<p>explain select id,age,phone from tb_user order by age,phone;</p>
<p>#创建索引</p>
<p>create index idx_user_age_phone_aa on tb_user(age,phone);</p>
<p>#创建索引后，根据age,phone进行升序排序</p>
<p>explain select id,age,phone from tb_user order by age, phone;</p>
<p>#创建索引后，根据age,phone进行降序排序</p>
<p>explain select id,age phone from tb_user order by age desc,phone desc;</p>
<p>#根据age,phone进行降序一个升序，一个降序</p>
<p>explain select id,age,phone from tb_user order by age asc,phone desc;</p>
<p>#创建索引</p>
<p>create index idx_user_age_phone_ad on tb_user(age asc,phone desc);</p>
<p>#根据age,phone进行降序一个升序，一个降序</p>
<p>explain select id,age,phone from tb_user order by age asc,phone desc;</p>
<p>1.根据排序字段建立合适的索引，多字段排序时，也遵循最左前缀法则。</p>
<p>2.尽量使用覆盖索引。</p>
<p>3.多字段排序，一个升序一个降序，此时需要注意联合索引在创建时的规则。(ASC/DESC)。</p>
<p>4.如果不可避免的出现filesort，大数据量排序时，可以适当增大排序缓冲区大小sort_buffer_size(默认256K)。</p>
<h3 id="4-group-by优化"><a href="#4-group-by优化" class="headerlink" title="4.group by优化"></a>4.group by优化</h3><p>#创建索引</p>
<p>create index idx_user_pro_age_sta on tb_user(profession,age,status);</p>
<p>#执行分组操作，根据profession字段分组</p>
<p>explain select profession,count(*) from tb_user group by profession;</p>
<p>#执行分组操作，根据profession字段分组</p>
<p>explain select profession,count(*) from tb_user group by profession,age;  (Using index)</p>
<p>explain select age,count(*) from tb_user group by age;   (Using index;Using temporary)</p>
<p>explain select age,count(*) from tb_user where profession = ‘ss’ group by age;   (Using index)</p>
<p>1.在分组操作时，可以通过索引来提高效率。</p>
<p>2.分组操作时，索引的使用也是满足最左前缀法则的。</p>
<h3 id="5-limit优化"><a href="#5-limit优化" class="headerlink" title="5.limit优化"></a>5.limit优化</h3><p>limit 起始索引 长度，此时需要Mysql排序前 起始索引+length记录，仅仅返回length个记录，其他记录丢弃，查询排序的代价非常大。</p>
<p>优化思路：一般分页查询时，通过创建覆盖索引能够比较好地提高性能，可以通过覆盖索引加子查询形式进行优化。</p>
<p>explain select * from tb_sku t,(select id from tb_sku order by id limit 起始索引, length) a where t.id = a.id;</p>
<h3 id="6-count优化"><a href="#6-count优化" class="headerlink" title="6.count优化"></a>6.count优化</h3><p>count的几种用法</p>
<p>count()是一个聚合函数，对于返回的结果集，一行行地判断，如果count函数的参数不是NULL,累计值就加1，否则不加，最后返回累计值。</p>
<p>用法：count(*),count(主键),count(字段)，count(1);</p>
<p>count(主键)</p>
<p>InnoDB引擎会遍历整张表，把每一行的主键id值都取出来，返回给服务层。服务层拿到主键后，直接按行进行累加（主键不可能为null）。</p>
<p>count(字段)</p>
<p>没有not null 约束：InnoDB引擎会遍历整张表把每一行的字段值都取出来，返回给服务层，服务层判断是否为null，不为null，计数累加。</p>
<p>有not null约束：InnoDB引擎会遍历整张表把每一行的字段值都取出来，返回给服务层，直接按行进行累加。</p>
<p>count(1)</p>
<p>InnoDB引擎遍历整张表，但不取值。服务层对于返回的每一行，放一个数字“1“进去，直接按行进行累加。</p>
<p>count(*)</p>
<p>InnoDB引擎并不会把全部字段取出来，而是专门做了优化，不取值，服务层直接按行进行累加。</p>
<p>按照效率排序的话，count(字段)&lt;count(主键id)&lt;count(1)  ≈  count(*)，所以尽量使用count(星);</p>
<h3 id="7-update优化"><a href="#7-update优化" class="headerlink" title="7.update优化"></a>7.update优化</h3><p>InnoDB的行锁是针对索引加的锁，不是针对记录加的锁，并且该索引不能失效，否则会从行锁升级为表锁。</p>
<p>尽量根据主键/索引字段进行数据更新。</p>
<h2 id="四、视图-存储过程-触发器"><a href="#四、视图-存储过程-触发器" class="headerlink" title="四、视图/存储过程/触发器"></a>四、视图/存储过程/触发器</h2><h3 id="1-视图"><a href="#1-视图" class="headerlink" title="1.视图"></a>1.视图</h3><p>视图是一种虚拟存在的表。视图中的数据并不在数据库中实际存在，行和列来自定义视图的查询中使用的表，并且是在使用视图时动态生成的。</p>
<p>视图只保存了查询的SQL逻辑，不保存查询结果。所以我们在创建视图的时候，主要的工作就落在创建这条SQL查询语句上。</p>
<p><strong>创建</strong></p>
<p>CREATE [OR REPLACE] VIEW 视图名称 [(列名列表)] AS SELECT语句 [WITH [CASCADED | LOCAL] CHECK OPTION]</p>
<p><strong>查询</strong></p>
<p>查看创建视图语句：SHOW CREATE VIEW 视图名称；</p>
<p>查看视图数据：SELECT * FROM 视图名称 …;</p>
<p><strong>修改</strong></p>
<p>方式一：CREATE [OR REPLACE] VIEW 视图名称 [(列名列表)] AS SELECT语句 [WITH [CASCADED | LOCAL] CHECK OPTION]</p>
<p>方式二：ALTER VIEW 视图名称 [(列名列表)] AS SELECT语句 [WITH [CASCADED | LOCAL] CHECK OPTION]</p>
<p><strong>删除</strong></p>
<p>DROP VIEW [IF EXISTS] 视图名称 [视图名称] …</p>
<p><strong>视图的检查选项</strong></p>
<p>当使用WITH CHECK OPTION子句创建视图时，MySQL会通过视图检查正在更改的每个行，例如插入、更新。删除，以使其符合视图的定义。MySQL允许基于另一个视图创建视图，它还会检查依赖视图中的规则以保持一致性。为了确定检查的范围，mysql提供了两个选项：</p>
<p>CASCADED和LOCAL,默认值为CASCADED。</p>
<p>CASCADED：当前视图和所依赖的视图都要求满足各自条件。</p>
<p>LOCAL：递归查找当前视图所依赖视图是否定义了检查选项LOCAL CHECK ,若有则进行条件的检查，若没有检查选项，则不进行条件的检查。</p>
<p><strong>视图的更新</strong></p>
<p>要使视图可更新，视图中的行与基础表中的行之间必须存在一对一的关系。如果视图包含以下任何一项，则该视图不可更新：</p>
<p>1.聚合函数或窗口函数（SUM()、MIN()、MAX()、COUNT()等）</p>
<p>2.DISTINCT</p>
<p>3.GROUP BY</p>
<p>4.HAVING</p>
<p>5.UNION 或者UNION ALL</p>
<p>作用</p>
<p>1.简单</p>
<p>视图不仅可以简化用户对数据的理解，也可以简化他们的操作。那些被经常使用的查询可以被定义为视图，从而使得用户不必为以后的操作每次指定全部的条件。</p>
<p>2.安全</p>
<p>数据库可以授权，但不能授权到数据库特定行和特定的列上。通过视图用户只能查询和修改他们所能见到的数据</p>
<p>3.数据独立</p>
<p>视图可帮助用户屏蔽真实表结构变化带来的影响。</p>
<h3 id="2-存储过程"><a href="#2-存储过程" class="headerlink" title="2.存储过程"></a>2.存储过程</h3><p>介绍</p>
<p>存储过程是事先经过编译并存储在数据库中的一段SQL语句的集合，调用存储过程可以简化应用开发人员的很多工作，减少数据在数据库和应用服务器之间的传输，对于提高数据处理的效率是有好处的。</p>
<p>存储过程思想上很简单，就是数据库SQL语言层面的代码封装与重用。</p>
<p>特点</p>
<p>封装，复用</p>
<p>可以接收参数，也可以返回数据</p>
<p>减少网络交互，效率提升</p>
<p><strong>创建</strong></p>
<p><strong>CREATE PROCEDURE 存储过程名称 ([参数列表])</strong></p>
<p><strong>BEGIN</strong></p>
<p>​    <strong>–SQL语句</strong></p>
<p><strong>END;</strong></p>
<p><strong>调用</strong></p>
<p>CALL 名称([参数]);</p>
<p><strong>查看</strong></p>
<p>SELECT * FROM INFORMATION_SCHEMA.ROUTINES WHERE ROUTINE_SCHEMA=’xxx’;  –查询指定数据库的存储过程及状态信息</p>
<p>SHOW CREATE PROCEDURE 存储过程名称;  –查询某个存储过程的定义</p>
<p><strong>删除</strong></p>
<p>DROP PROCEDURE [IF EXISTS] 存储过程名称;</p>
<p>注意：在命令行中，执行创建存储过程的SQL时，需要通过关键字delimiter指定SQL语句的结束符。</p>
<p><strong>变量</strong></p>
<p>系统变量是Mysql服务器提供，不是用户定义的，属于服务器层面。分为全局变量(GLOBAL)、会话变量(SESSION)。</p>
<p>查看系统变量</p>
<p>SHOW [SESSION | GLOBAL] VARIABLES;  –查看所有系统变量</p>
<p>SHOW [SESSION | GLOBAL] VAILABLRS LIKE ‘….’;  –可以通过LIKE模糊匹配方式查找变量</p>
<p>SELECT @@[SESSION | GLOBAL] 系统变量名;  –查看指定变量的值</p>
<p><strong>设置系统变量</strong></p>
<p>SET [SESSION | GLOBAL] 系统变量名= 值;</p>
<p>SET @@[SESSION | GLOBAL] 系统变量名 = 值;</p>
<p>用户定义变量是用户根据需要自己定义的变量，用户变量不用提前声明，在用的时候直接用”@变量名”使用就可以。其作用域为当前连接。</p>
<p><strong>赋值</strong></p>
<p>SET @var_name = expr [, @var_name = expr] …;</p>
<p>SET @var_name := expr [, @var_name :=expr] …;</p>
<p>SELECT @var_name := expr [, @var_name :=expr] …;</p>
<p>SELECT字段名 INTO @var_name FROM 表名;</p>
<p><strong>使用</strong></p>
<p>SELECT @var_name;</p>
<p>局部变量是根据需要定义的在局部生效的变量，访问之前，需要DECLARE声明。可用作存储过程内的局部变量和输入参数，局部变量的范围是在其声明的BEGIN…END块。</p>
<p><strong>声明</strong></p>
<p>DECLARE 变量名 变量类型 [DEFAULT…];</p>
<p>变量类型就是数据库字段类型：INT、BIGINT、CHAR、VARCHAR、DATE、TIME等。</p>
<p><strong>赋值</strong></p>
<p>SET 变量名 = 值；</p>
<p>SET 变量名 := 值；</p>
<p>SELECT 字段名 INTO 变量名 FROM 表名 …;</p>
<p>IF判断</p>
<p>语法：</p>
<p>IF 条件1 THEN</p>
<p>​    …</p>
<p>ELSEIF 条件2 THEN   –可选</p>
<p>​    …</p>
<p>ELSE</p>
<p>​    …</p>
<p>END IF;</p>
<p><strong>参数</strong></p>
<p>IN        作为输入，也就是需要调用时传入值</p>
<p>OUT    作为输出，也就是该参数可以作为返回值</p>
<p>INOUT即可以作为输入参数，也可以作为输出参数</p>
<p><strong>CREATE PROCEDURE 存储过程名称 ([IN/OUT/INOUT 参数名 参数类型])</strong></p>
<p><strong>BEGIN</strong></p>
<p>​    <strong>–SQL语句</strong></p>
<p><strong>END;</strong></p>
<p><strong>case</strong></p>
<p>语法一</p>
<pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">CASE case value

​    WHEN when_value1 THEN statement_list1 [WHEN when_value2 THEN statement_list2] ...

​    [ELSE statement_list]

END CASE;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>语法二</p>
<pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">CASE

​    WHEN search_condition1 THEN statement_list1 

​    [WHEN search_condition2 THEN statement_list2] ...

​    [ELSE statement_list]

END CASE;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>while</strong></p>
<p>WHILE 条件 DO</p>
<p>​    SQL逻辑</p>
<p>END WHILE;</p>
<p><strong>repeat</strong></p>
<p>repeat是有条件的循环控制语句，当满足条件的时候退出循环。</p>
<pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">REPEAT

​    SQL逻辑

​    UNTIL 条件

END REPEAT;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>loop</strong></p>
<p>loop实现简单的循环，如果不在SQL逻辑中增加退出循环的条件，可以用其来实现简单的死循环。LOOP可以配合一下两个语句使用：</p>
<p>LEAVE：配合循环使用，退出循环。</p>
<p>ITERATE：必须用在循环中，作用是跳过当前循环剩下的语句，直接进入下一次循环。</p>
<pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">[begin_label:]    LOOP

​    SQL逻辑...

END LOOP [end_label];

LEAVE label;    --退出指定标记的循环体

ITERATE label;    --直接进入下一次循环<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>游标</strong></p>
<p>游标(CURSOR)是用来存储查询结果集的数据类型，在存储过程和函数中可以使用游标对结果集进行循环的处理。游标的使用包括游标的声明、OPEN、FETCH和CLOSE，其语法分别如下。</p>
<p><strong>声明游标</strong></p>
<pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">DECLARE 游标名称 CURSOR FOR 查询语句<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p><strong>打开游标</strong></p>
<pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">OPEN 游标名称<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p><strong>获取游标记录</strong></p>
<pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">FETCH 游标名称 INTO 变量[,变量];<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p><strong>关闭游标</strong></p>
<pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">CLOSE 游标名称<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p><strong>条件处理程序</strong></p>
<p>条件处理程序(Handler)可以用来定义在流程控制结构执行过程中遇到问题时相应的处理步骤。具体语法：</p>
<pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">DECLARE handler_action HANDLER FOR condition_value [,condition_value] ... statement;

handler_action

​    CONTINUE：继续执行当前程序

​    EXIT：终止执行当前程序

condition_value

​    SQLSTATE sqlstate_value：状态码，如 02000

​    SQLWARNING：所有以01开头的SQLSTATE代码的简写

​    NOT FOUND：所有以02开头的SQLSTATE代码的简写

​    SQLEXCEPTION：所有没有被SQLWARNING 或NOT FOUND捕获的SQLSTATE代码的简写<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="3-存储函数"><a href="#3-存储函数" class="headerlink" title="3.存储函数"></a>3.存储函数</h3><p>存储函数是有返回值的存储过程，存储函数的参数只能是IN类型的。具体语法如下：</p>
<pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">
CREATE FUNCTION 存储函数名称([参数列表])

RETURNS type [characteristic ...]

BEGIN

​    ---SQL语句

​    RETURN ...;

END;

characteristic说明：

DETERMINISTIC：相同的输入参数总是产生相同的结果

NO SQL：不包含SQL语句。

READS SQL DATA：包含读取数据的语句，但不包含写入数据的语句。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="4-触发器"><a href="#4-触发器" class="headerlink" title="4.触发器"></a>4.触发器</h3><p>触发器是与表有关的数据库对象，指在insert/update/delete之前或之后，触发并执行触发器中定义的SQL语句集合。触发器的这种特性可以协助应用在数据库端确保数据的完整性，日志记录，数据校验等操作。</p>
<p>使用别名OLD和NEW来引用触发器中发生变化的记录内容，这与其他的数据库是相似的。现在触发器还只支持行级触发，不支持语句级触发。</p>
<p>INSERT型触发器                NEW表示将要或者已经新增的数据</p>
<p>UPDATE型触发器                OLD表示修改之前的数据，NEW表示将要或已经修改后的数据</p>
<p>DELETE型触发器                OLD表示将要或者已经删除的数据</p>
<p>语法</p>
<pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">**创建**

CREATE TRIGGER trigger_name

BEFORE/AFTER INSERT/UPDATE/DELETE

ON tbl_name FOR EACH ROW --行级触发器

BEGIN

​    trigger_stmt;

END;

查看

SHOW TRIGGERS;

删除

DROP TRIGGER [schema_name.]trigger_name;  --如果没有指定schema_name,默认为当前数据库

for example:

​    create trigger tb_user_insert_trigger after insert on tb_user for each row

begin

​    insert into user_logs(id,...) values (null,'..', ...);

end;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="五、锁"><a href="#五、锁" class="headerlink" title="五、锁"></a>五、锁</h2><h3 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h3><p>锁是计算机协调多个进程或线程并发访问某一资源的机制。在程序开发中会存在多线程同步的问题，当多个线程并发访问某个数据的时候，尤其是针对一些敏感的数据（比如订单、金额等），我们就需要保证这个数据在任何时刻最多只有一个线程在访问，保证数据的完整性和一致性。在开发过程中加锁是为了保证数据的一致性，这个思想在数据库领域中同样很重要。</p>
<p>在数据库中，除传统的计算资源（如CPU、RAM、I/o等）的争用以外，数据也是一种供许多用户共享的资源。为保证数据的一致性，需要对并发操作进行控制，因此产生了锁。同时锁机制也为实现MysQL的各个隔离级别提供了保证。锁冲突也是影响数据库并发访问性能的一个重要因素。所以锁对数据库而言显得尤其重要，也更加复杂</p>
<h3 id="2-MySQL并发事务访问相同记录"><a href="#2-MySQL并发事务访问相同记录" class="headerlink" title="2. MySQL并发事务访问相同记录"></a>2. MySQL并发事务访问相同记录</h3><p>并发事务访问相同记录的情况大致可以划分为3种：</p>
<h4 id="2-1-读-读情况"><a href="#2-1-读-读情况" class="headerlink" title="2.1 读-读情况"></a>2.1 读-读情况</h4><p>读-读情况，即并发事务相继读取相同的记录。读取操作本身不会对记录有任何影响，并不会引起什么问题，所以允许这种情况的发生。</p>
<h4 id="2-2-写-写情况"><a href="#2-2-写-写情况" class="headerlink" title="2.2 写-写情况"></a>2.2 写-写情况</h4><p>写-写情况，即并发事务相继对相同的记录做出改动。<br>在这种情况下会发生脏写的问题，任何一种隔离级别都不允许这种问题的发生。所以在多个未提交事务相继对一条记录做改动时，需要让它们排队执行，这个排队的过程其实是通过锁来实现的。这个所谓的锁其实是一个内存中的结构，在事务执行前本来是没有锁的，也就是说一开始是没有锁结构和记录进行关联的，如图所示:<br><img src="/images/20230629185855.png"></p>
<p>当一个事务想对这条记录做改动时，首先会看看内存中有没有与这条记录关联的锁结构，当没有的时候就会在内存中生成一个锁结构与之关联。比如，事务T1要对这条记录做改动，就需要生成一个锁结构与之关联:</p>
<p><img src="/images/20230629190240.png"></p>
<p>在锁结构里有很多信息，为了简化理解，只把两个比较重要的属性拿了出来:</p>
<ol>
<li>trx信息:代表这个锁结构是哪个事务生成的。</li>
<li>is_waiting :代表当前事务是否在等待。</li>
</ol>
<p>当事务T1改动了这条记录后，就生成了一个锁结构与该记录关联，因为之前没有别的事务为这条记录加锁，所以is_waiting属性就是false，我们把这个场景就称之为获取锁成功，或者加锁成功，然后就可以继续执行操<br>作了。</p>
<p>在事务T1提交之前，另一个事务T2也想对该记录做改动，那么先看看有没有锁结构与这条记录关联，发现有一个锁结构与之关联后，然后也生成了一个锁结构与这条记录关联，不过锁结构的is_waiting属性值为true ,<br>表示当前事务需要等待，我们把这个场景就称之为获取锁失败，或者加锁失败，图示:<br><img src="/images/20230629191908.png"></p>
<p>在事务T1提交之后，就会把该事务生成的锁结构释放掉，然后看看还有没有别的事务在等待获取锁，发现了事务T2还在等待获取锁，所以把事务T2对应的锁结构的is_waiting属性设置为false，然后把该事务对应的线程<br>唤醒，让它继续执行，此时事务T2就算获取到锁了。效果图就是这样:<br><img src="/images/20230629192932.png"></p>
<p>小结几种说法:</p>
<ol>
<li>不加锁<br>意思就是不需要在内存中生成对应的锁结构，可以直接执行操作。</li>
<li>获取锁成功，或者加锁成功<br>意思就是在内存中生成了对应的锁结构，而且锁结构的is_waiting属性为false，也就是事务可以继续执行操作。</li>
<li>获取锁失败，或者加锁失败，或者没有获取到锁<br>意思就是在内存中生成了对应的锁结构，不过锁结构的is_waiting属性为true，也就是事务需要等待，不可以继续执行操作。</li>
</ol>
<h4 id="2-3-读-写或写-读情况"><a href="#2-3-读-写或写-读情况" class="headerlink" title="2.3 读-写或写-读情况"></a>2.3 读-写或写-读情况</h4><p>读-写或写-读，即一个事务进行读取操作，另一个进行改动操作。这种情况下可能发生脏读、不可重复读、幻读的问题。</p>
<p>各个数据库厂商对SQL标准的支持都可能不一样。比如MysQL在REPEATABLE READ隔离级别上就已经解决了幻读问题。</p>
<h4 id="2-4-并发问题的解决方案"><a href="#2-4-并发问题的解决方案" class="headerlink" title="2.4 并发问题的解决方案"></a>2.4 并发问题的解决方案</h4><p>怎么解决脏读、不可重复读、幻读这些问题呢?其实有两种可选的解决方案:<br>·方案一:读操作利用多版本并发控制（MVCC，下章讲解），写操作进行加锁。<br>所谓的MVCC，就是生成一个ReadView，通过ReadView找到符合条件的记录版本(历史版本由undo日志构建)。查询语句只能读到在生成ReadView之前已提交事务所做的更改，在生成ReadView之前未提交的事务或者之<br>后才开启的事务所做的更改是看不到的。而写操作肯定针对的是最新版本的记录，读记录的历史版本和改动记录的最新版本本身并不冲突，也就是采用MVCC时，读-写操作并不冲突。</p>
<p>普通的SELECT语句在READ COMMITTED和REPEATABLE READ隔离级别下会使用到MVCc读取记录。</p>
<ol>
<li>在READ COMMITTED隔离级别下，一个事务在执行过程中每次执行SELECT操作时都会生成一个ReadView，ReadView的存在本身就保证了事务不可以读取到未提交的事务所做的更改，也就是避免了脏读现象；</li>
<li>在REPEATABLE READ隔离级别下，一个事务在执行过程中只有第一次执行SELECT操作才会生成一个ReadView，之后的SELECT操作都复用这个ReadView，这样也就避免了不可重复读和幻读的问题。</li>
</ol>
<p>·方案二:读、写操作都采用加锁的方式。<br>如果我们的一些业务场景不允许读取记录的旧版本，而是每次都必须去读取记录的最新版本。比如，在银行存款的事务中，你需要先把账户的余额读出来，然后将其加上本次存款的数额，最后再写到数据库中。在将账户余额读取出来后，就不想让别的事务再访问该余额，直到本次存款事务执行完成，其他事务才可以访问账户的余额。这样在读取记录的时候就需要对其进行加锁操作，这样也就意味着读操作和写操作也像写-写操作那样排队执行。</p>
<p>脏读的产生是因为当前事务读取了另一个未提交事务写的一条记录，如果另一个事务在写记录的时候就给这条记录加锁，那么当前事务就无法继续读取该记录了，所以也就不会有脏读问题的产生了。</p>
<p>不可重复读的产生是因为当前事务先读取一条记录，另外一个事务对该记录做了改动之后并提交之后，当前事务再次读取时会获得不同的值，如果在当前事务读取记录时就给该记录加锁，那么另一个事务就无法修改该记录，自然也不会发生不可重复读了。</p>
<p>幻读问题的产生是因为当前事务读取了一个范围的记录，然后另外的事务向该范围内插入了新记录，当前事务再次读取该范围的记录时发现了新插入的新记录。采用加锁的方式解决幻读问题就有一些麻烦，因为当前事务在第-次读取记录时幻影记录并不存在，所以读取的时候加锁就有点尴尬（因为你并不知道给谁加锁）。</p>
<p>·小结对比发现</p>
<ol>
<li>采用MVCC方式的话，读-写操作彼此并不冲突，性能更高。</li>
<li>采用加锁方式的话，读-写操作彼此需要排队执行，影响性能。<br>一般情况下我们当然愿意采用MCC来解决读-写操作并发执行的问题，但是业务在某些特殊情况下，要求必须采用加锁的方式执行。下面就讲解下MysQL中不同类别的锁。</li>
</ol>
<h3 id="3-锁的不同角度分类"><a href="#3-锁的不同角度分类" class="headerlink" title="3.锁的不同角度分类"></a>3.锁的不同角度分类</h3><p>锁的分类图，如下：<br><img src="/images/20230629203552.png" alt="image"></p>
<h4 id="3-1-从数据操作的类型划分：读锁、写锁"><a href="#3-1-从数据操作的类型划分：读锁、写锁" class="headerlink" title="3.1 从数据操作的类型划分：读锁、写锁"></a>3.1 从数据操作的类型划分：读锁、写锁</h4><p>对于数据库中并发事务的读-读情况并不会引起什么问题。对于写-写、读-写或写-读这些情况可能会引起一些问题，需要使用WCC或者加锁的方式来解决它们。在使用加锁的方式解决问题时，由于既要允许读-读情况不<br>受影响，又要使写-写、读-写或写-读情况中的操作相互阻塞，所以MysQL实现一个由两种类型的锁组成的锁系统来解决。这两种类型的锁通常被称为共享锁(Shared Lock,S Lock)和排他锁(Exclusive Lock,X Lock)也叫读锁(readlock)和写锁(write lock) 。<br>·读锁∶也称为共享锁、英文用S表示。针对同一份数据，多个事务的读操作可以同时进行而不会互相影响，相互不阻塞的。<br>·写锁∶也称为排他锁、英文用X表示。当前写操作没有完成前，它会阻断其他写锁和读锁。这样就能确保在给定的时间里，只有一个事务能执行写入，并防止其他用户读取正在写入的同一资源。</p>
<p>需要注意的是对于InnoDB引擎来说，读锁和写锁可以加在表上，也可以加在行上。<br>举例(行级读写锁)︰如果一个事务T1已经获得了某个行r的读锁，那么此时另外的一个事务T2是可以去获得这个行r的读锁的，因为读取操作并没有改变行r的数据;但是，如果某个事务T3想获得行r的写锁，则它必须等待事务T1、T2释放掉行r上的读锁才行。</p>
<p>总结:这里的兼容是指对同一张表或记录的锁的兼容性情况。<br><img src="/images/20230629204835.png"></p>
<h5 id="1-锁定读"><a href="#1-锁定读" class="headerlink" title="1.锁定读"></a>1.锁定读</h5><p>在采用加锁方式解决脏读、不可重复读、幻读这些问题时，读取一条记录时需要获取该记录的S锁，其实是不严谨的，有时候需要在读取记录时就获取记录的x锁，来禁止别的事务读写该记录，为此MySQL提出了两种比较特殊的SELECT语句格式:<br>·对读取的记录加S锁:</p>
<pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">SELECT ... LOCK IN SHARE MODE;
#或
SELECT ... FOR SHARE; #(8.0新增语法)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>在普通的SELECT语句后边加LOCK IN SHARE MODE，如果当前事务执行了该语句,那么它会为读取到的记录加S锁，这样允许别的事务继续获取这些记录的S锁(比方说别的事务也使用SELECT … LOCK IN SHARE MODE语句来读取这些记录)，但是不能获取这些记录的x锁(比如使用SELECT … FOR UPDATE语句来读取这些记录，或者直接修改这些记录)。如果别的事务想要获取这些记录的X锁，那么它们会阻塞，直到当前事务提交之后将这些记录上的S锁释放掉。</p>
<p>·对读取的记录加X锁:</p>
<pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">SELECT ... FOR UPDATE;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>在普通的SELECT语句后边加FOR UPDATE，如果当前事务执行了该语句，那么它会为读取到的记录加X锁，这样既不允许别的事务获取这些记录的S锁(比方说别的事务使用SELECT …LOCK IN SHARE MODE语句来读取这些记录)，也不允许获取这些记录的X锁(比如使用SELECT … FOR UPDATE语句来读取这些记录，或者直接修改这些记录)。如果别的事务想要获取这些记录的S锁或者X锁，那么它们会阻塞，直到当前事务提交之后将这些记录上的X锁释放掉。</p>
<p><strong>MySQL8.0新特性:</strong><br>在5.7及之前的版本，SELECT …FOR UPDATE，如果获取不到锁，会一直等待，直到innodb_lock_wait_timeout超时。在8.0版本中，SELECT …FOR UPDATE，SELECT …FOR SHARE添加NOWAIT、SKIP LOCKED语法，跳过锁等待，或者跳过锁定。</p>
<p>·通过添加NOWAIT、SKIP LOCKED语法，能够立即返回。如果查询的行已经加锁:</p>
<ol>
<li>那么NowAIT会立即报错返回</li>
<li>而SKIP LOCKED也会立即返回，只是返回的结果中不包含被锁定的行。</li>
</ol>
<h5 id="2-写操作"><a href="#2-写操作" class="headerlink" title="2.写操作"></a>2.写操作</h5><p>平常所用到的写操作无非是DELETE、UPDATE、INSERT这三种:</p>
<ol>
<li><p>DELETE:<br>对一条记录做DELETE操作的过程其实是先在B+树中定位到这条记录的位置，然后获取这条记录的X锁，再执行delete mark操作。我们也可以把这个定位待删除记录在B+树中位置的过程看成是一个获取X锁的锁定读。</p>
</li>
<li><p>UPDATE:在对一条记录做UPDATE操作时分为三种情况:<br>情况1. 未修改该记录的键值，并且被更新的列占用的存储空间在修改前后未发生变化。则先在B+树中定位到这条记录的位置，然后再获取一下记录的X锁，最后在原记录的位置进行修改操作。我们也可以把这个定位待修改记录在B+树中位置的过程看成是一个获取X锁的锁定读。<br>情况2：未修改该记录的键值，并且至少有一个被更新的列占用的存储空间在修改前后发生变化。则先在B+树中定位到这条记录的位置，然后获取一下记录的X锁，将该记录彻底删除掉（就是把记录彻底移入垃圾链表），最后再插入一条新记录。这个定位待修改记录在B+树中位置的过程看成是一个获取X锁的锁定读，新插入的记录由INSERT操作提供的隐式锁进行保护。<br>情况3∶修改了该记录的键值，则相当于在原记录上做DELETE操作之后再来一次INSERT操作，加锁操作就需要按照 DELETE和INSERT的规则进行了。</p>
</li>
<li><p>INSERT:<br>一般情况下，新插入一条记录的操作并不加锁，通过一种称之为隐式锁的结构来保护这条新插入的记录在本事务提交前不被别的事务访问。</p>
</li>
</ol>
<h4 id="3-2-从数据操作的粒度划分：表级锁、页级锁、行所"><a href="#3-2-从数据操作的粒度划分：表级锁、页级锁、行所" class="headerlink" title="3.2 从数据操作的粒度划分：表级锁、页级锁、行所"></a>3.2 从数据操作的粒度划分：表级锁、页级锁、行所</h4><p>为了尽可能提高数据库的并发度，每次锁定的数据范围越小越好，理论上每次只锁定当前操作的数据的方案会得到最大的并发度，但是管理锁是很耗资源的事情（涉及获取、检查、释放锁等动作）。因此数据库系统需要在高并发响应和系统性能两方面进行平衡，这样就产生了“锁粒度（Lock granularity<br>”的概念。</p>
<p>对一条记录加锁影响的也只是这条记录而已，我们就说这个锁的粒度比较细;其实一个事务也可以在表级别进行加锁，自然就被称之为表级锁或者表锁，对一个表加锁影响整个表中的记录，我们就说这个锁的粒度比较粗。锁的粒度主要分为表级锁、页级锁和行锁。</p>
<h5 id="1-表锁（Table-Lock）"><a href="#1-表锁（Table-Lock）" class="headerlink" title="1.表锁（Table Lock）"></a><strong>1.表锁（Table Lock）</strong></h5><p>该锁会锁定整张表，它是MySQL中最基本的锁策略，并不依赖于存储引擎（不管你是MySQL的什么存储引擎，对于表锁的策略都是一样的），并且表锁是开销最小的策略（因为粒度比较大）。由于表级锁一次会将整个表锁定，所以可以很好的避免死锁问题。当然，锁的粒度大所带来最大的负面影响就是出现锁资源争用的概率也会最高，导致并发率大打折扣。</p>
<ol>
<li>表级别的S锁、X锁<br>在对某个表执行SELECT、INSERT、DELETE、UPDATE语句时，InnoDB存储引擎是不会为这个表添加表级别的S锁或者X锁的。在对某个表执行一些诸如ALTER TABLE、DROP TABLE这类的DDL语句时，其他事务对这个表并发执行诸如SELECT、INSERT、DELETE、UPDATE的语句会发生阻塞。同理，某个事务中对某个表执行SELECT、INSERT、DELETE、UPDATE语句时，在其他会话中对这个表执行DDL语句也会发生阻塞。这个过程其实是通过在server层使用一种称之为元数据锁(英文名: Metadata Locks，简称MDL）结构来实现的。<br>一般情况下，不会使用InnoDB存储引擎提供的表级别的s锁和X锁。只会在一些特殊情况下，比方说崩溃恢复过程中用到。比如，在系统变量autocommit=0，innodb_table_locks = 1时，手动获取InnoDB存储引擎提供的表t的S锁或者x锁可以这么写:    </li>
</ol>
<p>1). LOCK TABLES t READ : InnoDB存储引擎会对表t加表级别的S锁。<br>2). LOCK TABLES t WRITE : InnoDB存储引擎会对表t加表级别的x锁。<br>不过尽量避免在使用InnoDB存储引擎的表上使用LOCK TABLES这样的手动锁表语句，它们并不会提供什么额外的保护，只是会降低并发能力而已。InnoDB的厉害之处还是实现了更细粒度的行锁，关于InnoDB表级别的S锁和X锁大家了解一下就可以了。</p>
<ol start="2">
<li>意向锁（intention lock）<br>InnoDB支持多粒度锁(multiple granularity locking)，它允许行级锁与表级锁共存，而意向锁就是其中的一种表锁。<br>1、意向锁的存在是为了协调行锁和表锁的关系，支持多粒度（表锁与行锁)的锁并存。<br>2、意向锁是一种不与行级锁冲突表级锁，这一点非常重要。<br>3、表明“某个事务正在某些行持有了锁或该事务准备去持有锁”。   </li>
</ol>
<p><strong>意向锁分为两种:</strong><br>    <strong>意向共享锁</strong>(intention shared lock,IS)：事务有意向对表中的某些行加共享锁（S锁）<br>        –事务要获取某些行的S锁，必须先获得表的IS 锁。<br>        SELECT column FROM table … LOCK IN SHARE MODE;<br>    <strong>意向排他锁</strong>( intention exclusive lock,lX)︰事务有意向对表中的某些行加排他锁（X锁）<br>    –事务要获取某些行的X锁，必须先获得表的IX 锁。<br>    SELECT column FROM table … FOR UPDATE;<br>即:意向锁是由存储引擎自己维护的，用户无法手动操作意向锁，在为数据行加共享/排他锁之前，InooDB会先获取该数据行所在数据表的对应意向锁。</p>
<p><img src="/images/20230629214832.png"><br><img src="/images/20230629215121.png"><br><img src="/images/20230629215931.png"><br><img src="/images/20230629220036.png"><br><img src="/images/20230629220159.png"><br><img src="/images/20230629220252.png"><br><img src="/images/20230629220331.png"><br><img src="/images/20230629220458.png"></p>
<ol start="3">
<li>自增锁（AUTO-INC锁）     </li>
</ol>
<p>分类</p>
<p>Mysql中的锁，按照锁的粒度分，分为三类：</p>
<p>1.全局锁：锁定数据库中的所有表。</p>
<p>2.表级锁：每次操作锁住整张表。</p>
<p>3.行级锁：每次操作锁住对应的行数据。</p>
<p>1.互斥条件：进程要求对所分配的资源进行排他性控制，即在一段时间内某资源仅为一个进程所占有。此时若有其他进程请求该资源，则请求进程只能等待。</p>
<p>2.不可剥夺条件：进程所获得的资源在未使用完毕之前，不能被其他进程强行夺走，即只能由获得该资源的进程自己来释放（只能是主动释放)。</p>
<p>3.请求与保持条件：进程已经保持了至少一个资源，但又提出了新的资源请求，而该资源已被其他进程占有，此时请求进程被阻塞，但对自己已获得的资源保持不放。</p>
<p>4.循环等待条件：存在一种进程资源的循环等待链，链中每一个进程已获得的资源同时被 链中下一个进程所请求。</p>
<h3 id="1-全局锁"><a href="#1-全局锁" class="headerlink" title="1.全局锁"></a><strong>1.全局锁</strong></h3><p>全局锁就是对整个数据库实例加锁，加锁后整个实例就处于只读状态，后续的DML的写语句，DDL语句，已经更新操作的事务提交语句都将被阻塞。</p>
<p>其典型的使用场景是做全库的逻辑备份，对所有的表进行锁定，从而获取一致性视图，保证数据的完整性。</p>
<p>加全局锁</p>
<p>flush tables with read lock;</p>
<p>数据备份</p>
<p>mysqldump -h 192.168.0.0.1 -uroot -proot db1 &gt; xxx.sql</p>
<p>解锁</p>
<p>unlock tables;</p>
<p>特点</p>
<p>数据库中加全局锁，是一个比较重的操作，存在一下问题：</p>
<p>1.如果在主库上备份，那么在备份期间都不能执行更新，业务基本上就得停摆。</p>
<p>2.如果在从库上备份，那么在备份期间从库不能执行从库同步过来的二进制日志(binlog)，会导致主从延迟。</p>
<p>在InnoDB引擎中，我们可以在备份时加上参数 –single-transaction参数来完成不加锁的一致性数据备份。</p>
<h3 id="2-表级锁"><a href="#2-表级锁" class="headerlink" title="2.表级锁"></a><strong>2.表级锁</strong></h3><p>表级锁，每次操作锁住整张表。锁定粒度大，发生锁冲突的概率最高，并发度最低。应用在MyISAM、InnoDB、BDB等存储引擎中。</p>
<p>表级锁分为：</p>
<p>1.表锁</p>
<p>2.元数据锁(meta data lock,MDL)</p>
<p>3.意向锁</p>
<p><strong>1.表锁：</strong></p>
<p>1.表共享锁(read lock)</p>
<p>2.表独占写锁(write lock)</p>
<p>语法：</p>
<p>1.加锁：lock tables 表名.. read/write。</p>
<p>read 当前客户端和其他客户端能读，但是不能写。</p>
<p>write 当前客户端可读可写，其他客户端不可读写。</p>
<p>2.释放锁：unlock tables/客户端断开连接。</p>
<p><strong>2.元数据锁</strong></p>
<p>MDL加锁过程是系统自动控制，无需显式使用，在访问一张表的时候会自动加上。MDL锁主要作用是维护表元数据的数据一致性，在表上有活动事务的时候，不可以对元数据进行写入操作。为了避免DML与DDL冲突，保证读写的正确性。</p>
<p>当对一张表进行增删改查的时候，加MDL读锁(共享)；当对表结构进行变更操作的时候，加MDL写锁(排他)。</p>
<p>对应SQL                                                                   锁类型                                                                                            说明</p>
<p>lock tables xxx read/write                                SHARED_READ_ONLY/SHARED_NO_READ_WRITE</p>
<p>select、select … lock in share mode                SHARED_READ                                       与SHARED_READ、SHARES_WRITE兼容、与EXCLUSIVE互斥</p>
<p>insert、update、delete、select…for update  SHARED_WRITE                                    与SHARED_READ、SHARED_WRITE兼容，与EXCLUSIVE互斥</p>
<p>alter table…                                                            EXCLUSIVE                                            与其他的MDL都互斥</p>
<p>查看元数据锁</p>
<p>select object_type,object_schema,object_name,lock_type,lock_duration from performance_schema.metadata_locks;</p>
<p><strong>3.意向锁</strong></p>
<p>为了避免DML在执行时，加的行锁与表锁的冲突，在InnoDB中引入意向锁，使得表锁不用检查每行数据是否加锁，使用意向锁来减少表锁的检查。</p>
<p>1.意向共享锁(IS)：由语句select…lock in share mode添加。</p>
<p>与表锁共享锁(read)兼容，与表锁排它锁(write)互斥。</p>
<p>2.意向排他锁(IX)：由insert、update、delete、select…for update添加。</p>
<p>与表锁共享锁(read)及排它锁(write)都互斥。意向锁之间不会互斥。</p>
<p>查看意向锁及行锁的加锁情况：</p>
<p>select object_schema,object_name,index_name,lock_type,lock_mode,lock_data from performance_schema.data_locks;</p>
<h3 id="3-行级锁"><a href="#3-行级锁" class="headerlink" title="3.行级锁"></a>3.行级锁</h3><p>行级锁，每次操作锁住对应的行数据。锁定粒度最小，发生锁冲突的概率最低，并发度最高。应用在InnoDB存储引擎中。</p>
<p>InnoDB的数据是基于索引组织的，行锁是通过对索引上的索引项加锁来实现的，而不是对记录加的锁。对于行级锁，主要分为一下三类：</p>
<p>1.行锁(Record Lock)：锁定单个行记录的锁，防止其他事务对此行进行update和delete。在RC、RR隔离级别下都支持。</p>
<p>2.间隙锁(Gap Lock)：锁定索引记录间隙(不含该记录)，确保索引记录间隙不变，防止其他事务在这个间隙进行insert,产生幻读。在RR隔离级别下都支持。</p>
<p>3.临键锁(Next-Key Lock)：行锁和间隙锁组合，同时锁住数据，并锁住数据前面的间隙Gap。在RR隔离级别下支持。</p>
<p>1.行锁</p>
<p>InnoDB实现了以下两种类型的行锁：</p>
<p>1.共享锁(S)：允许一个事务去读一行，阻止其他事务获得相同数据集的排它锁。</p>
<p>2.排它锁(X)：允许获取排它锁的事务更新数据，阻止其他事务获得相同数据集的共享锁和排它锁。</p>
<p>INSERT …                                                                        排它锁                                                            自动加锁</p>
<p>UPDATE…                                                                        排它锁                                                            自动加锁</p>
<p>DELETE…                                                                        排它锁                                                            自动加锁</p>
<p>SELECT(正常)                                                                    不加任何锁</p>
<p>SELECT…LOCK IN SHARE MODE                                    共享锁                                                        需要手动在SELECT之后加LOCK IN SHARE MODE</p>
<p>SELECT… FOR UPDATE                                                    排它锁                                                        需要手动在SELECT之后加FOR UPDATE</p>
<p>默认情况下，InnoDB在REPEATABLE READ事务隔离级别运行，InnoDB使用next-key锁进行搜索和索引扫描，以防止幻读。</p>
<p>1.针对唯一索引进行检索时，对已存在的记录进行等值匹配时，将会自动优化为行锁。</p>
<p>2.InnoDB的行锁是针对于索引加的锁，不通过索引条件检索数据，那么InnoDB将对表中的所有记录加锁，此时就会<strong>升级为表锁</strong>。</p>
<p>2.间隙锁/临键锁</p>
<p>默认情况下，InnoDB在REPEATABLE READ事务隔离级别运行，InnoDB使用next-key锁进行搜索和索引扫描，以防止幻读。</p>
<p>1.索引上的等值查询(唯一索引)，给不存在的记录加锁时，优化为间隙锁。</p>
<p>2.索引上的等值查询(普通索引)，向右遍历时最后一个值不满足查询需求时，next-key lock退化为间隙锁。</p>
<p>3.索引上的范围查询(唯一索引)–会访问到不满足条件的第一个值为止。</p>
<p>注意：间隙锁唯一目的是防止其他事务插入间隙。间隙锁可以共存，一个事务采用的间隙锁不会阻止另一个事务在同一间隙上采用间隙锁。</p>
<h2 id="六、InnoDB引擎"><a href="#六、InnoDB引擎" class="headerlink" title="六、InnoDB引擎"></a>六、InnoDB引擎</h2><p>InnoDB主要包括了内存池、后台线程以及存储文件。</p>
<p>INNODB的三大特性：插入缓存，两次写，自适应hash。</p>
<h4 id="内存池"><a href="#内存池" class="headerlink" title="内存池"></a><strong>内存池</strong></h4><p>数据库读写数据如果直接操作磁盘进行读写的话，会带来一定的性能瓶颈，缓冲池就是为了提高数据库的读写性能，客户端读取数据时，如果数据存在于缓冲池中，客户端就会直接读取缓冲池中的数据，否则再去磁盘中读取，对于数据库中的修改数据，首先是修改在缓冲池中的数据，然后再通过Master Thread线程刷新到磁盘上。</p>
<p><strong>缓冲池中缓存的数据页类型</strong></p>
<p>索引页、数据页、 undo 页、插入缓冲(insert buffer)、自适应哈希索引(adaptive hash index)、锁信息(lock info)、数据字典信息(data dictionary)等。索引页和数据页占缓冲池的很大一部分。InnoDB中，缓冲池中的页大小默认为16KB。</p>
<p><strong>LUR算法</strong></p>
<p>缓冲池是通过LRU(Latest Recent Used，最近最少使用)算法来进行管理的，即最频繁使用的页在LRU列表的最前段，而最少使用的页在LRU列表的尾端，当缓冲池不能存放新读取到的页时，首先释放LRU列表尾端的页。</p>
<p><strong>缓冲池</strong>(buffer pool)</p>
<p>参数innodb_buffer_pool_size配置其大小，是占内存最大的一部分，用来存放各种数据的缓存，innodb将数据库文件按页(16K)读取到缓冲池，然后使用(LRU)算法来保留缓存数据。数据修改时，先修改缓存池中的页（即脏页），然后按一定频率将脏页刷新到磁盘文件里面。</p>
<p>查看buffer pool的使用情况：show engine innodb status</p>
<p><strong>重做日志缓冲池</strong>(redo log buffer)</p>
<p>其大小在参数innodb_log_buffer_size 配置，将重做日志先放入这个区，然后按一定频率将其刷新至重做日志文件，一般情况下每1秒就会刷新一次。</p>
<p><strong>额外内存池</strong>(additional memory pool)</p>
<p>其大小在参数innodb_additional_mem_pool_size 配置，innodb申请缓冲池(buffer pool)时，每个缓冲池中的页缓冲有对应的缓冲控制对象(buffer control block)，会记录LRU、锁、等待等信息，相对的占用内存空间大小。因此当buffer pool较大时，额外内存池参数页要相应的变大。</p>
<h4 id="后台线程"><a href="#后台线程" class="headerlink" title="后台线程"></a>后台线程</h4><p>InnoDB后台有多个不同的线程，用来负责不同的任务</p>
<p><strong>Master Thread</strong>：是最核心的一个线程,主要负责将缓冲池中的数据异步刷新到磁盘,保证数据的一致性,包括赃页的刷新、合并插入缓冲、UNDO页的回收等。具有最高的线程优先级别，内部由多个循环组成：主循环（loop）、后台循环（background loop）、刷新循环（flush loop）、暂停循环（suspend loop），Master Thread会根据数据库运行的状态进行循环之间的切换</p>
<pre class="line-numbers language-markdown" data-language="markdown"><code class="language-markdown">1.主循环 loop
该循环中完成的有两种操作，每秒一次的操作和每10秒一次的操作
每秒一次的操作:
a)日志缓冲刷新到磁盘(总是)：即使事务没有提交，InnoDB也会每秒将重做日志缓冲刷新到重做日志文件中，因此可以理解为什么再大的事务提交，时间也是很短的。
b)合并插入缓冲（可能）:并不是每秒刷新的，如果前一秒的IO次数小于5，则认为IO压力小，可以执行合并插入缓冲的操作。
c)最多刷新100个InnoDB的缓冲池脏页到磁盘（可能）：判断当前缓冲池中脏页的比例(buf_get_modifyed_ratio_pct)是否超过了配置文件中innodb_max_dirty_pages_pct这个参数（默认为90）如               果超过了这个阈值，InnoDB存储引擎认为需要做同步操作，将100个脏页写入磁盘中。
d)如果当前没有用户活动，切换到background loop（可能）。
每10秒一次的操作:
a)刷新100个脏页到磁盘（可能），如果过去10秒磁盘io操作小于200次，则执行本操作
b)合并最多5个插入缓冲（总是）
c)将日志缓冲刷新到磁盘（总是）
d)删除无用的undo页（总是）
e)刷新100个或10个脏页到磁盘（总是），判断缓冲池脏页比例，超过70%则刷新100个脏页，比例小于10%则刷新10个脏页；
f)产生一个检查点checkpoint（总是），此时并不是把所有脏页都刷新到了磁盘，只是将最老日志序列号的页写入磁盘；

2 后台循环 background loop
当没有用户活动或数据库关闭时，会切换到这个循环
a)删除无用的undo页（总是）；
b)合并20个插入缓冲（总是）；
c)跳回到主循环（总是）；
d)不断刷新100个页,直到符合条件(可能,跳转到flush loop中完成),如果fulsh loop页没有事情可以做了，InnoDB存储引擎会切换到suspend loop，将Master Thread挂起。

3 flush loop
由background loop跳转到此loop中完成刷新脏页的工作
当flush loop中无事可做时会切换到suspend loop

4 suspend loop
该loop将master thread挂起，等待事件发生，在启用了innodb引擎，但未使用innodb表时，master thread总是处于挂起状态；

5 查看示例
show engine innodb status

<span class="token hr punctuation">-----------------</span>
<span class="token title important">BACKGROUND THREAD
<span class="token punctuation">-----------------</span></span>
srv_master_thread loops: 4 1_second, 4 sleeps, 0 10_second, 6 background, 6 flush
srv_master_thread log flush and writes: 4

说明
(1)主循环，每秒一次的操作有4次，每10秒一次的操作有0次；一般这两个比例在1:10时较合理。
(2)background loop，执行了6次，flush loop执行了6次。
(3)其中的sleeps指循环中的每秒sleep的操作，一般压力较小情况下此值和每秒一次的操作数相同，压力大时会小于每秒一次的操作数。
6 新版本优化了上边的判断配置值
innodb_io_capacity=200
合并插入缓冲时，合并插入缓冲的数量为innodb_io_capacity数值的5%。
缓冲区刷新到磁盘时，刷新脏页数量为innodb_io_capacity。
使用情况：在使用了ssd磁盘，或做了raid后，可将此值设置较大，直到符合磁盘io的吞吐量

7 其它配置值
innodb_max_dirty_pages_pct=90
每秒的主loop和flush loop中，会判断此值，如果大于才刷新100个脏页，在数据库压力很大时，这时刷新速度反而会降低，google的测试表明75是个合理值。

innodb_adaptive_flushing=on
该值影响每秒刷新脏页的操作，开启此配置后，刷新脏页会通过判断产生重做日志的速度来判断最合适的刷新脏页的数量。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>IO Thread</strong>：在InnoDB存储引擎中大量使用了异步IO来处理写的请求, IO Thread 的工作主要是负责这些IO请求的回调处理。包括以下几种：read thread、write thread、insert buffer thread、log thread。</p>
<pre class="line-numbers language-markdown" data-language="markdown"><code class="language-markdown">配置设置:
read thread、write thread分别由innodb_read_io_threads、innodb_write_io_threads配置，
log thread和insert buffer thread一般是1。
查看命令：
show variables like '%threads%';
show engine innodb status;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>Purge Thread</strong>：事务被提交之后, undo log可能不再需要,因此需要Purge Thread 来回收已经使用并分配的undo页。InnoDB支持多个Purge Thread, 这样做可以加快undo页的回收。</p>
<p><strong>Page Cleaner Thread</strong>：在InnoDB 1.2.x版本新引入的,其作用是将之前版本中脏页的刷新操作都放入单独的线程中来完成,这样减轻了Master Thread的工作及对于用户查询线程的阻塞。</p>
<h4 id="存储文件"><a href="#存储文件" class="headerlink" title="存储文件"></a>存储文件</h4><p>由InnoDB存储引擎实现的表的存储结构文件一般包括表结构文件（.frm）、共享表空间文件（ibdata1）、独占表空间文件（ibd）以及日志文件（redo文件等）等。</p>
<p><strong>表空间</strong>(Tablespaces):表空间是由各个段组成。</p>
<p><strong>段</strong>(segment):一个段由若干个簇构成。</p>
<p><strong>簇/区</strong>(Extents):簇是构成段的基本元素,包含64个页。</p>
<p><strong>页</strong>(Page):在向表中插入数据时，如果一个页面已经被写完，系统会从当前簇中分配一个新的空闲页面处理使用，如果当前簇中的64个页面都被分配完，系统会从当前页面所在段中分配一个新的簇，然后再从这个簇中分配一个新的页面来使用。每个页大小为16KB，簇是由64个连续的页组成，即每个簇的大小为1MB。</p>
<h3 id="InnoDB原理"><a href="#InnoDB原理" class="headerlink" title="InnoDB原理"></a>InnoDB原理</h3><p>InnoDB存储引擎基于磁盘存储，数据存储在磁盘上，由于CPU速度和磁盘速度之间的鸿沟，使用缓冲池技术来提高数据库的整体性能。缓冲池简单来说就是一块内存区域，在数据库中进行读取页的操作时,首先从磁盘读到的页存放在缓冲池中,下一次读取相同的页时,先判断该页是不是在缓冲池中，若在则该页在缓冲池中被命中，直接读取该页，否则就读取磁盘上的页然后再放到缓冲池中。对于数据库中页的修改操作，首先修改在缓冲池中页，然后以一定的频率刷新到磁盘，并不是每次页发生改变就刷新回磁盘。</p>
<h3 id="InnoDB关键特性"><a href="#InnoDB关键特性" class="headerlink" title="InnoDB关键特性"></a>InnoDB关键特性</h3><p><strong>插入缓冲</strong>(insert buffer)：是innodb引擎的关键特性之一，是从缓冲池中分配的，用来对插入的性能进行优化和提升，即对有非唯一的非聚集索引的索引页的插入进行了缓冲，之后合并再插入。<br>工作原理：当表只有一个聚集索引时，插入顺序是按照该主键的顺序进行插入的，不需要磁盘的随机读取，当表有一个或多个非聚集索引且该索引不是表的唯一索引时，插入时数据按主键顺序存放，但叶子节点需要离散地访问非聚集索引页，插入性能会降低。这时插入缓冲生效，先判断非聚集索引页是否在缓冲池中，如果在就直接插入，如果不在则先放入一个插入缓冲区，然后再以一定的频率执行插入缓冲和非聚集索引页子节点的合并操作。</p>
<pre class="line-numbers language-markdown" data-language="markdown"><code class="language-markdown">插入缓冲生效的条件
存在非聚集索引，且索引不是表的唯一索引；

插入缓冲的分析
<span class="token title important">show engine innodb status
<span class="token punctuation">-------------------------------------</span></span>
<span class="token title important">INSERT BUFFER AND ADAPTIVE HASH INDEX
<span class="token punctuation">-------------------------------------</span></span>
Ibuf: size 1, free list len 2366, seg size 2368, 0 merges
merged operations:
 insert 0, delete mark 0, delete 0
discarded operations:
 insert 0, delete mark 0, delete 0
Hash table size 103867, node heap has 1 buffer(s)
0.00 hash searches/s, 0.20 non-hash searches/s
说明
(1)seg size：当前插入缓冲的大小 2368*16K，free list len表示空闲列表的长度，size表示已经合并记录页的数量，merges表示合并的数量。
(2)merged operations：合并的情况,inserts表示插入的记录数。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>两次写缓存</strong>（doublewrite buffer）：innodb引擎的关键特性之一，两次写保证的是innodb的可靠性，插入缓冲保证的是性能。数据文件的结构： 页 page 16K, 区 extent 1M, 段 seg 2M。</p>
<pre class="line-numbers language-markdown" data-language="markdown"><code class="language-markdown">部分写失效情况：当数据库正在从内存向磁盘写一个数据页时，数据库宕机，导致这个页只写了部分数据，就造成了部分写失效，导致数据丢失。这个是无法通过重做日志恢复                                    的，因为重做日志记录的是对页的物理修改，如果页本身已经损坏，重做日志也无能为力，两次写需要额外添加两个部分：
doublewrite由两部分组成：一部分是内存中的doublewrite buffer，大小为2MB；另一部分是物理磁盘上共享表空间中连续的128个页，即两个区（extent），大小同样为2MB(页的副本)。当缓冲                  池的脏页刷新时，并不直接写磁盘，而是会通过memcpy函数将脏页先拷贝到内存中的doublewrite buffer，之后通过doublewrite buffer再分两次，每次写入1MB到共享表空间的物理磁盘上，然后                  马上调用fsync函数，同步磁盘，避免缓冲写带来的问题。在这个过程中，因为doublewrite页是连续的，因此这个过程是顺序写的，开销并不是很大。在完成doublewrite页的写入后，再将                        doublewrite buffer中的页写入各个表空间文件中，此时的写入则是离散的。<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>br</span><span class="token punctuation">&gt;</span></span>

 刷新脏页时，先后做三步工作：
 一先将脏页拷贝到内存的doublewrite buffer，
 二是通过该buffer两次写入（每次写入1M）到共享表空间，然后马上调用fsync函数同步磁盘；这个过程是顺序写的，开销不大；
 三是再将该buffer中的页写入各个表空间文件中，此过程中的写入是离散的；

 查看doublewrite的运行情况
 show global status like 'innodb_dblwr%'\G
 +----------------------------+-------+
 | Variable_name             | Value |
 +----------------------------+-------+
 | Innodb_dblwr_pages_written | 4    |
 | Innodb_dblwr_writes       | 2    |
 +----------------------------+-------+
 结果分析
 pages_written为写的页数，writes为写的次数，一般两者的比例小于64：1；
 如果比例较高，说明写入压力较大；
 写入磁盘失效时的恢复原理
 从共享表空间中的doublewrite中找到该页的一个副本，拷贝到表空间文件，再应用重做日志进行恢复；
 配置
 innodb_doublewrite=ON
 <span class="token title important"><span class="token punctuation">#</span>skip_innodb_doublewrite 或 innodb_doublewrite=OFF</span>
 需要提供较快的性能时，可禁用双写；但在主服务器上，任何时间都应确保开启双写功能；
 有些文件系统本身提供了部分写失效的机制，如zfs文件系统，此时可以关闭双写；<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>自适应哈希索引</strong>：哈希是一种非常快的查找方法，在一般情况时间复杂度为O(1)。而B+树的查找次数，取决于B+树的高度。InnoDB存储引擎会监控对表上索引的查找，如果观察到建立哈希索引可以带来速度的提升，则建立哈希索引，称之为自适应哈希索引(Adaptive Hash Index, AHI)。自适应哈希索引通过缓冲池的B+树构造而来，因此建立的速度很快。而且不需要将整个表都建哈希索引。InnoDB存储引擎会自动根据访问的频率和模式来自动的为某些热点页建立哈希索引。AHI有一个要求，对这个页的连续访问模式(查询条件)必须一样的。例如联合索引(a,b)其访问模式可以有以下情况:WHERE a=XXX;WHERE a=xxx AND b=xxx。若交替进行上述两张查询，InnoDB存储引擎不会对该页构造AHI。此外AHI还有如下要求：以该模式访问了100次；页通过该模式访问了N次，其中N=页中记录/16。根据官方文档显示，启用AHI后，读取和写入的速度可以提高2倍，负责索引的链接操作性能可以提高5倍。其设计思想是数据库自由化的，无需DBA对数据库进行人为调整。</p>
<pre class="line-numbers language-markdown" data-language="markdown"><code class="language-markdown">工作机制
innodb会自动监控表上索引的查找，如果发现建立哈希索引可以带来速度的提升，则建立哈希索引；
建立的依据是根据访问的频率和模式自动进行的；据官方文档说明，对读取和写入可以提高2倍，对辅助索引的连接操作性能可提高5倍；
适用条件
只能用来搜索等值的查询，如select * from table where index_col='xxx'；
对其他类型是不会被使用的；
查看运行情况
<span class="token title important">show engine innodb status
<span class="token punctuation">-------------------------------------</span></span>
<span class="token title important">INSERT BUFFER AND ADAPTIVE HASH INDEX
<span class="token punctuation">-------------------------------------</span></span>
Ibuf: size 1, free list len 2366, seg size 2368, 0 merges
merged operations:
 insert 0, delete mark 0, delete 0
discarded operations:
 insert 0, delete mark 0, delete 0
Hash table size 103867, node heap has 1 buffer(s)
0.00 hash searches/s, 0.00 non-hash searches/s
结果说明
hash searches显示了hash查找的次数
non-hash searches显示了不能利用hash查找的次数；
配置：
innodb_adaptive_hash_index=ON<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>异步IO</strong>(AIO)：为了提高磁盘操作性能，当前的数据库系统都采用异步IO的方式来处理磁盘操作。InnoDB也是如此。与AIO对应的是Sync IO，即每进行一次IO操作，需要等待此次操作结束才能继续接下来的操作。但是如果用户发出的是一条索引扫描的查询，那么这条SQL语句可能需要扫描多个索引页，也就是需要进行多次IO操作。在每扫描一个页并等待其完成再进行下一次扫描。用户可以在发出一个IO请求后立即再发出另外一个IO请求，当全部IO请求发送完毕后，等待所有IO操作完成，这就是AIO。AIO的另外一个优势是进行IO Merge操作，也就是将多个IO合并为一个IO操作，这样可以提高IOPS的性能。在InnoDB 1.1.x之前，AIO的实现是通过InnoDB存储引擎中的代码来模拟的。但是从这之后，提供了内核级别的AIO的支持，称为Native AIO。Native AIO需要操作系统提供支持。Windows和Linux都支持，而Mac则未提供。在选择MySQL数据库服务器的操作系统时，需要考虑这方面的因素。MySQL可以通过参数innodb_use_native_aio来决定是否启用Native AIO。在InnoDB存储引擎中，read ahead方式的读取都是通过AIO完成，脏页的刷新，也是通过AIO完成。</p>
<p><strong>刷新邻接页</strong>：InnoDB存储引擎在刷新一个脏页时，会检测该页所在区(extent)的所有页，如果是脏页，那么一起刷新。这样做的好处是通过AIO可以将多个IO写操作合并为一个IO操作。InnoDB存储引擎1.2.x版本开始提供参数innodb_flush_neighbors决定是否启用。</p>
<h3 id="CheckPoint"><a href="#CheckPoint" class="headerlink" title="CheckPoint"></a>CheckPoint</h3><p>数据库在执行增删查改操作的时候，为了提高事物操作的效率，都是先在buffer pool中完成的，buffer pool中修改之后的数据，并没有立即写入到磁盘，这有可能会导致内存中数据与磁盘中的数据产生不一致的情况。 事物要求之一是持久性（Durability），buffer pool与磁盘数据的不一致性的情况下发生故障，可能会导致数据无法持久化。为了防止在内存中修改但尚未写入到磁盘的数据，在发生故障重启数据之后产生事物未持久化的情况，是通过日志(redo log)先行的方式来保证的。redo log可以在故障重启之后实现重做，保证了事物的持久化的特性，但是redo log空间不可能无限制扩大，对于内存中已修改但尚未提交到磁盘的数据(脏页)，要写入磁盘的情况，用checkpoint技术来解决。内存中的脏页，什么时候，什么情况下，将多少脏页写入磁盘，是由多方面因素决定的，checkpoint的工作之一，就是对于内存中的脏页，在一定条件下刷新到磁盘。checkpoint技术主要的作用：</p>
<p><strong>缩短数据库恢复时间</strong></p>
<p><strong>缓冲池不够用时</strong>，将脏页刷新到磁盘 每次刷新多少页到磁盘？每次从哪里取脏页？什么时间触发checkpoint？</p>
<pre class="line-numbers language-markdown" data-language="markdown"><code class="language-markdown">InnoDB存储引擎内部，两种checkpoint:
1.Sharp Checkpoint：
发生在数据库关闭时，将所有的脏页都刷新回磁盘，这是默认的工作方式，即参数：innodb_fast_shutdown=1。
不适用于数据库运行时的刷新。
2.Fuzzy Checkpoint：
在数据库运行时，InnoDB存储引擎内部采用Fuzzy Checkpoint，只刷新一部分脏页。
几种发生Fuzzy Checkpoint的情况：
1.MasterThread Checkpoint
异步刷新，每秒或每10秒从缓冲池脏页列表刷新一定比例的页回磁盘。异步刷新，即此时InnoDB存储引擎可以进行其他操作，用户查询线程不会受阻。--&gt;参考master Thread的介绍
2.FLUSH_LRU_LIST Checkpoint
InnoDB存储引擎需要保证LRU列表中差不多有100个空闲页可供使用。在InnoDB 1.1.x版本之前，用户查询线程会检查LRU列表是否有足够的空间操作。如果没有，根据LRU算法，溢出LRU列表尾端的页，如             果这些页有脏页，需要进行checkpoint。因此叫：flush_lru_list checkpoint.
mysql5.6之后，也就是Innodb1.2.x开始，这个检查放在了单独的进程（Page Cleaner）中进行。好处：1.减少master Thread的压力 2.减轻用户线程阻塞。--&gt;参考page cleaner线程。
设置参数：innodb_lru_scan_dept：控制LRU列表中可用页的数量，该值默认1024 
3.Async/Sync Flush Checkpoint
指重做日志不可用的情况，需要强制刷新页回磁盘，此时的页是脏页列表选取的。
保证重做日志的可用性。
写入日志的LSN:redo_lsn
刷新回磁盘的最新页LSN:checkpoint_lsn
定义:
          checkpoint_age = redo_lsn - checkpoint_lsn
          async_water_mark = 75% <span class="token italic"><span class="token punctuation">*</span><span class="token content"> total_redo_file_size
          sync_water_mark = 90% </span><span class="token punctuation">*</span></span> total_redo_file_size
4.Dirty Page too much Checkpoint
即脏页太多，强制checkpoint.保证缓冲池有足够可用的页。
参数设置：innodb_max_dirty_pages_pct = 75 表示：当缓冲池中脏页的数量占75%时，强制checkpoint。1.0.x之后默认75<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>&nbsp;<strong>重做日志不可用时，刷新脏页</strong></p>
<h3 id="1-逻辑存储结构"><a href="#1-逻辑存储结构" class="headerlink" title="1.逻辑存储结构"></a>1.逻辑存储结构</h3><p><strong>表空间</strong>(Tablespace)-&gt;Segment<strong>段</strong>-&gt;Extent(<strong>区</strong>)-&gt;Page(<strong>页</strong>)-&gt;Row(<strong>行</strong>)</p>
<p>表空间(ibd文件)，一个mysql实例可以对应多个表空间，用于存储记录、索引等数据。</p>
<p>段，分为数据段，索引段，回滚段，InnoDB是索引组织表，数据段就是B+树的叶子节点，索引段即为B+树的非叶子节点。段用来管理多个Extent(区)。</p>
<p>区，表空间的单元结构，每个区的大小为1M。默认情况下，InnoDB存储引擎页大小为16K，即一个区中一共有64个连续的页。</p>
<p>页，是InnoDB存储引擎磁盘管理的最小单元，每个页的大小默认为16KB。为了保证页的连续性，InnoDB存储引擎每次从磁盘申请4-5个区。</p>
<p>行，InnoDB存储引擎数据是按行进行存放的。</p>
<h3 id="2-架构"><a href="#2-架构" class="headerlink" title="2.架构"></a>2.架构</h3><p><strong>内存架构</strong></p>
<p>Buffer Pool：缓冲池是主内存中的一个区域，里面可以缓存磁盘上经常操作的真实数据，在执行增删改查操作时，先操作缓冲池中的数据（若缓冲池没有数据，则从磁盘加载并缓存），然后再以一定频率刷新到磁盘，从而减少磁盘IO，加快处理速度。</p>
<p>缓冲池以Page页为单位，底层采用链表数据结构管理Page。根据状态，将Page分为三种类型：</p>
<p>free page：空闲page,未被使用。</p>
<p>clean page：被使用page,数据没有被修改过。</p>
<p>dirty page：脏页，被使用page，数据被修改过，页中数据与磁盘的数据产生了不一致。</p>
<p>Change Buffer：更改缓冲区(针对于非唯一二级索引页)，在执行DML语句时，如果这些数据Page没有在Buffer Pool中，不会直接操作磁盘，而会将数据变更存在更改缓冲区Change Buffer中，在未来数据被读取时，再将数据合并恢复到Buffer Pool中，再将合并后的数据刷新到磁盘中。</p>
<p>Change Buffer的意义：</p>
<p>与聚集索引不同，二级索引通常是非唯一的，并且以相对随机的顺序插入二级索引。同样，删除和更新可能会影响索引树中不相邻的二级索引页，如果每一次都操作磁盘，会造成大量的磁盘IO。有了ChangeBuffer之后，我们可以在缓冲池中进行合并处理，减少磁盘IO。</p>
<p>Adaptive Hash Index：自适应hash索引，用于优化对Buffer Pool数据的查询。InnoDB存储引擎会监控对表上个索引页的查询，如果观察到hash索引可以提升速度，则建立hash索引，称之为自适应hash索引。</p>
<p>自适应哈希索引，无需人工干预，是系统根据情况自动生成。</p>
<p>参数：adaptive_hash_index</p>
<p>Log Buffer：日志缓冲区，用来保存要写入到磁盘中的log日志数据(redo log, undo log)，默认大小为16MB，日志缓冲区的日志会定期刷新到磁盘中。如果需要更新。插入或删除许多行的事务，增加日志缓冲器的大小可以节省磁盘IO。</p>
<p><strong>磁盘结构</strong></p>
<p>System Tablespace：系统表空间是更改缓冲区的存储区域。</p>
<p>File-Per-Table Tablespaces：每个表的文件表空间包含单个InnoDB表的数据和索引，并存储在文件系统上的单个数据文件中。</p>
<p>General Tablespaces：通用表空间，需要通过CREATE TABLESPACE语法创建通用表空间，在创建表时，可以指定该表空间。</p>
<p>CREATE TABLESPACE XXX ADD DATAFILE ‘file_name’ ENGINE = engine_name;</p>
<p>Create table xxx… TABLESPACE ts_name;</p>
<p>Undo Tablespaces：撤销表空间，Mysql实例在初始化时会自动创建两个默认的undo表空间（初始大小16M），用于存储undo log日志。</p>
<p>Temporary Tablespaces：InnoDB使用会话临时表空间和全局临时表空间。存储用户创建的临时表等数据。</p>
<p>Doublewrite Buffer Files：双写缓冲区，innoDB引擎将数据页从Buffer Pool刷新到磁盘前，先将数据页写入双写缓冲区文件中，便于系统异常时恢复数据。</p>
<p>Redo Log：重做日志，是用来实现事务的持久性。该日志文件由两部分组成；重做日志缓冲区(redo log buffer) 以及重做日志文件(redo log)，前者是在内存中，后者在磁盘中。当事务提交之后会把所有修改信息都会存到该日志中，用于在刷新脏页到磁盘时，发生错误时，进行数据恢复使用。</p>
<p>以循环方式写入重做日志文件。</p>
<h3 id="3-事务原理"><a href="#3-事务原理" class="headerlink" title="3.事务原理"></a>3.事务原理</h3><p>原子性    通过undo log实现</p>
<p>持久性    通过redo log实现</p>
<p>一致性    通过redo log，undo log实现</p>
<p>隔离性    通过锁，MVCC实现</p>
<p>redo log：重做日志，记录的是事务提交时数据页的物理修改，是用来实现事务的持久性。该日志文件由两部分组成；重做日志缓冲区(redo log buffer) 以及重做日志文件(redo log)，前者是在内存中，后者在磁盘中。当事务提交之后会把所有修改信息都会存到该日志中，用于在刷新脏页到磁盘时，发生错误时，进行数据恢复使用。</p>
<p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220301114520277.png" alt="image-20220301114520277"></p>
<p>undo log：回滚日志，用于记录数据被修改前的信息，作用包含两个：提前回滚和MVCC（多版本并发控制）。</p>
<p>undo log和redo log 记录物理日志不一样，它是逻辑日志。可以认为当delete一条记录时，undo log中会记录一条对应的insert记录，反之亦然，当update一条记录时，它记录一条对应相反的update记录。当执行rollback时，就可以从undo log中的逻辑记录读取到相应的内容并进行回滚。</p>
<p>Undo log 销毁：undo log 在事务执行时产生，事务提交时，并不会立即删除undo log,因为这些日志可能还用于MVCC。</p>
<p>undo log存储：undo log采用段的方式进行管理和记录，存放在前面介绍的rollback segment回滚段中，内部包含1024个undo log segment。</p>
<h3 id="4-MVCC"><a href="#4-MVCC" class="headerlink" title="4.MVCC"></a>4.MVCC</h3><p>1.当前读</p>
<p>读取的是记录的最新版本，读取时还要保证其他并发事务不能修改当前记录，会对读取的记录进行加锁。对于我们日常的操作，如：</p>
<p>select .. lock in share mode(共享锁)，select … for update、update、insert、delete(排它锁)都是一种当前读。</p>
<p>2.快照读</p>
<p>简单的select(不加锁)就是快照读，快照读，读取的是记录数据的可见版本，有可能是历史数据，不加锁，是非阻塞读。</p>
<p>优点是可以不用加锁就可以读取到数据，缺点是读取到的数据可能不是最新的版本。 </p>
<p>Read committed：每次select，都生成一个快照读。</p>
<p>Repeatable Read：开启事务后第一个select语句才是快照读的地方。</p>
<p>Serializable：快照读会退化为当前读。</p>
<p>3.MVCC</p>
<p>全称Multi-Version Concurrency Control，多版本并发控制。指维护一个数据的多个版本，使得读写操作没有冲突，快照读为Mysql实现MVCC提供了一个非阻塞读功能。MVCC的具体实现，还需要依赖于数据库记录中的三个隐藏字段、undo log日志、readView。</p>
<p>1.记录中的隐藏字段</p>
<p>DB_TRX_ID                            最近修改事务ID，记录插入这条记录或最后一次修改该记录的事务ID。</p>
<p>DB_ROLL_PTR                        回滚指针，指向这条记录的上一个版本，用于配合undo log，指向上一个版本。</p>
<p>DB_ROW_ID                            隐藏主键，如果表结构没有指定主键，将会生成该隐藏字段。</p>
<p>2.undo log</p>
<p>回滚日志，在insert、update、delete的时候产生的便于数据回滚的日志。</p>
<p>当insert的时候，产生的undo log日志只在回滚时需要，在事务提交后，可被立即删除。</p>
<p>而update、delete的时候，产生的undo log 日志不仅在回滚时需要，在快照读时也需要，不会立即删除。</p>
<p>undo log版本链</p>
<p>不同事务或相同事务对同一条记录进行修改，会导致该记录的undo log生成一条记录版本链表，链表的头部是最新的旧记录，链表尾部是最早的旧记录。</p>
<p>3.readView</p>
<p>ReadView(读视图)是快照读SQL执行时MVCC提取数据的依据，记录并维护系统当前活跃的事务(未提交)id。</p>
<p>ReadView中包含了四个核心字段：</p>
<p>m_ids                                                当前活跃的事务ID集合</p>
<p>min_trx_id                                        最小活跃事务ID</p>
<p>max_trx_id                                        预分配事务ID，当前最大事务ID+1（因为事务ID是自增的）</p>
<p>creator_trx_id                                    ReadView创建者的事务ID</p>
<p>readview</p>
<p>trx_id：代表是当前事务ID。</p>
<p><strong>版本链</strong>数据访问规则</p>
<ol>
<li>trx_id == creator_trx_id ? 可以访问该版本        成立，说明数据是当前这个事务更改的。</li>
<li>trx_id &lt; min_trx_id ? 可以访问该版本                成立，说明数据已经提交了。</li>
<li>trx_id &gt; max_trx_id ? 不可以访问该版本           成立，说明该事物是在ReadView生成后才开启。</li>
<li>min_trx_id &lt;= trx_id &lt;=max_trx_id ? 如果trx_id<strong>不在</strong>m_ids中是可以访问该版本的        成立，说明数据已经提交。</li>
</ol>
<p>不同的隔离级别，生成ReadView的时机不同：</p>
<p>READ COMMITTED：在事务中每一次执行快照读时生成ReadView。</p>
<p>REPEATABLE READ：仅在事务中第一次执行快照读时生成ReadView，后续复用该ReadView。</p>
<p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220309213056494.png" alt="image-20220309213056494"></p>
<p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220309214332164.png" alt="image-20220309214332164"></p>
<p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220309214431451.png" alt="image-20220309214431451"></p>
<h3 id="3-复习"><a href="#3-复习" class="headerlink" title="3.复习"></a>3.复习</h3><h4 id="3-1隔离级别"><a href="#3-1隔离级别" class="headerlink" title="3.1隔离级别"></a>3.1隔离级别</h4><p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220309214635388.png" alt="image-20220309214635388"></p>
<p>MVCC只是在“快照读”的情况下是可以解决“幻读”的问题的。</p>
<p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220309214841371.png" alt="image-20220309214841371"></p>
<p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220309214925034.png" alt="image-20220309214925034"></p>
<p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220309215007029.png" alt="image-20220309215007029"></p>
<p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220309215031586.png" alt="image-20220309215031586"></p>
<p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220309215109287.png" alt="image-20220309215109287"></p>
<p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220309215441717.png" alt="image-20220309215441717"></p>
<p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220309215708115.png" alt="image-20220309215708115"></p>
<p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220309220042372.png" alt="image-20220309220042372"></p>
<p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220309220149908.png" alt="image-20220309220149908"></p>
<p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220309220507524.png" alt="image-20220309220507524"></p>
<p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220309220656132.png" alt="image-20220309220656132"></p>
<p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220309220812677.png" alt="image-20220309220812677"></p>
<p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220309220839359.png" alt="image-20220309220839359"></p>
<p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220309220916591.png" alt="image-20220309220916591"></p>
<p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220309221158758.png" alt="image-20220309221158758"></p>
<p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220309221253029.png" alt="image-20220309221253029"></p>
<p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220309221342922.png" alt="image-20220309221342922"></p>
<p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220309221524999.png" alt="image-20220309221524999"></p>
<p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220309221553606.png" alt="image-20220309221553606"></p>
<p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220309221629942.png" alt="image-20220309221629942"></p>
<p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220309221653672.png" alt="image-20220309221653672"></p>
<p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220309221756868.png" alt="image-20220309221756868"></p>
<p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220309221834460.png" alt="image-20220309221834460"></p>
<p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220309221923243.png" alt="image-20220309221923243"></p>
<p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220309222010239.png" alt="image-20220309222010239"></p>
<p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220309222051998.png" alt="image-20220309222051998"></p>
<p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220309222139494.png" alt="image-20220309222139494"></p>
<p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220309222203628.png" alt="image-20220309222203628"></p>
<p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220309222228823.png" alt="image-20220309222228823"></p>
<p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220309222307330.png" alt="image-20220309222307330"></p>
<p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220309222326492.png" alt="image-20220309222326492"></p>
<p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220309222402125.png" alt="image-20220309222402125"></p>
<p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220309222526350.png" alt="image-20220309222526350"></p>
<p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220309222655909.png" alt="image-20220309222655909"></p>
<p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220309222844918.png" alt="image-20220309222844918"></p>
<p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220309222949019.png" alt="image-20220309222949019"></p>
<p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220309223003556.png" alt="image-20220309223003556"></p>
<p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220309223059420.png" alt="image-20220309223059420"></p>
<p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220309223133507.png" alt="image-20220309223133507"></p>
<h1 id="后记："><a href="#后记：" class="headerlink" title="后记："></a>后记：</h1><p>MySQL实现的MVCC，主要是用于在并发读写的情况下，保证 “读” 数据时无需加锁也可以读取到数据的某一个版本的快照，好处是可以避免加锁，降低开销，解决了读写冲突，增大了数据库的并发性能。 </p>
<p>在修改数据的时候，会向 redo log 中记录修改的页内容（为了在数据库宕机重启后恢复对数据库的操作），也会向 undo log 记录数据原来的快照（用于回滚事务）。undo log有两个作用，除了用于回滚事务，还用于实现MVCC。 </p>
<p><strong>MVCC</strong>主要是用来<strong>解决RU隔离级别下的脏读和RC隔离级别下的不可重复读的问题</strong>，所以<strong>MVCC只在RC（解决脏读）和RR（解决不可重复读）隔离级别下生效</strong>，也就是MySQL只会在RC和RR隔离级别下的快照读时才会生成ReadView。区别就是，在RC隔离级别下，每一次快照读都会生成一个最新的ReadView；在RR隔离级别下，只有事务中第一次快照读会生成ReadView，之后的快照读都使用第一次生成的ReadView。</p>
<h2 id="快照读–只针对Select操作"><a href="#快照读–只针对Select操作" class="headerlink" title="快照读–只针对Select操作"></a>快照读–只针对Select操作</h2><p>MVCC的机制。快照读不会产生幻读。因为ReadView生成后就不会发生变化</p>
<h2 id="当前读–针对数据修改操作"><a href="#当前读–针对数据修改操作" class="headerlink" title="当前读–针对数据修改操作"></a>当前读–针对数据修改操作</h2><p>每次执行都会读取最新的记录。（假设要update一条记录，但是在另一个事务中已经delete掉这条数据并且commit了，如果update就会产生冲突，所以在update的时候需要知道最新的数据。）</p>
<p>结论：<strong>MVCC的机制会使Select语句的快照读避免幻读，但是对于当前读的操作依然会出现幻读。</strong> </p>
<p>例子：假如A事务正在查询id&lt;10的所有数据，只存在id为1~7的数据，8、9并不存在，此时B事务向数据库插入id为8的数据，那么事务A就会出现幻读现象，本来是不存在id为8的数据的，但是像出现幻觉一样读取到了，这就是幻读。</p>
<p>解决办法：加上next-key锁（也就是行锁+gap锁）， 阻止事务A读取数据的时候，事务B向数据库插入数据，这样就避免幻读了。</p>
<p>结论：</p>
<ul>
<li>在快照读情况下，MySQL通过mvcc来避免幻读。</li>
<li>在当前读情况下，MySQL通过next-key来避免幻读</li>
</ul>
<h2 id="七、其他数据库日志"><a href="#七、其他数据库日志" class="headerlink" title="七、其他数据库日志"></a>七、其他数据库日志</h2><p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220310102215837.png" alt="image-20220310102215837"></p>
<p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220310102306361.png" alt="image-20220310102306361"></p>
<p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220310102419315.png" alt="image-20220310102419315"></p>
<p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220310102536683.png" alt="image-20220310102536683"></p>
<p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220310102703657.png" alt="image-20220310102703657"></p>
<p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220310102728587.png" alt="image-20220310102728587"></p>
<p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220310102925082.png" alt="image-20220310102925082"></p>
<p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220310102948906.png" alt="image-20220310102948906"></p>
<p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220310103009337.png" alt="image-20220310103009337"></p>
<p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220310103149506.png" alt="image-20220310103149506"></p>
<p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220310103212921.png" alt="image-20220310103212921"></p>
<p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220310103316794.png" alt="image-20220310103316794"></p>
<p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220310103432433.png" alt="image-20220310103432433"></p>
<p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220310103552939.png" alt="image-20220310103552939"></p>
<p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220310103705194.png" alt="image-20220310103705194"></p>
<p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220310103722010.png" alt="image-20220310103722010"></p>
<p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220310103920616.png" alt="image-20220310103920616"></p>
<p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220310105229287.png" alt="image-20220310105229287"></p>
<p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220310105453323.png" alt="image-20220310105453323"></p>
<p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220310105525884.png" alt="image-20220310105525884"></p>
<p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220310113738709.png" alt="image-20220310113738709"></p>
<p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220310113811435.png" alt="image-20220310113811435"></p>
<p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220310113932828.png" alt="image-20220310113932828"></p>
<p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220310114059444.png" alt="image-20220310114059444"></p>
<p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220310114232461.png" alt="image-20220310114232461"></p>
<p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220310114254582.png" alt="image-20220310114254582"></p>
<p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220310114345689.png" alt="image-20220310114345689"></p>
<p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220310114434806.png" alt="image-20220310114434806"></p>
<p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220310114645241.png" alt="image-20220310114645241"></p>
<p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220310114702706.png" alt="image-20220310114702706"></p>
<p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220310114757526.png" alt="image-20220310114757526"></p>
<p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220310114834825.png" alt="image-20220310114834825"></p>
<p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220310122435133.png" alt="image-20220310122435133"></p>
<p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220310122511422.png" alt="image-20220310122511422"></p>
<p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220310122641423.png" alt="image-20220310122641423"></p>
<p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220310122821774.png" alt="image-20220310122821774"></p>
<p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220310122901486.png" alt="image-20220310122901486"></p>
<p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220310123031374.png" alt="image-20220310123031374"></p>
<p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220310123147974.png" alt="image-20220310123147974"></p>
<p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220310123343953.png" alt="image-20220310123343953"></p>
<p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220310123517787.png" alt="image-20220310123517787"></p>
<p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220310123641580.png" alt="image-20220310123641580"></p>
<p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220310123722396.png" alt="image-20220310123722396"></p>
<p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220310123749112.png" alt="image-20220310123749112"></p>
<p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220310123823182.png" alt="image-20220310123823182"></p>
<p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220310124015603.png" alt="image-20220310124015603"></p>
<p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220310124036206.png" alt="image-20220310124036206"></p>
<p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220310124118133.png" alt="image-20220310124118133"></p>
<p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220310124216779.png" alt="image-20220310124216779"></p>
<p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220310124237194.png" alt="image-20220310124237194"></p>
<p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220310124300804.png" alt="image-20220310124300804"></p>
<p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220310124353744.png" alt="image-20220310124353744"></p>
<p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220310124503838.png" alt="image-20220310124503838"></p>
<p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220310124542493.png" alt="image-20220310124542493"></p>
<p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220310124838359.png" alt="image-20220310124838359"></p>
<p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220310125920672.png" alt="image-20220310125920672"></p>
<p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220310130111454.png" alt="image-20220310130111454"></p>
<h2 id="八、主从复制"><a href="#八、主从复制" class="headerlink" title="八、主从复制"></a>八、主从复制</h2><p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220310130524512.png" alt="image-20220310130524512"></p>
<p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220310131109367.png" alt="image-20220310131109367"></p>
<p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220310131647743.png" alt="image-20220310131647743"></p>
<p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220310131835593.png" alt="image-20220310131835593"></p>
<p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220310132409968.png" alt="image-20220310132409968"></p>
<p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220310132429660.png" alt="image-20220310132429660"></p>
<p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220310132504779.png" alt="image-20220310132504779"></p>
<p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220310132702320.png" alt="image-20220310132702320"></p>
<p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220310133022753.png" alt="image-20220310133022753"></p>
<h3 id="4-3如何减少主从延迟"><a href="#4-3如何减少主从延迟" class="headerlink" title="4.3如何减少主从延迟"></a>4.3如何减少主从延迟</h3><p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220310134014522.png" alt="image-20220310134014522"></p>
<p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220310134052880.png" alt="image-20220310134052880"></p>
<p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220310134157208.png" alt="image-20220310134157208"></p>
<p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220310134417926.png" alt="image-20220310134417926"></p>
<p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220310134549566.png" alt="image-20220310134549566"></p>
<p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220310134610253.png" alt="image-20220310134610253"></p>
<p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220310134642756.png" alt="image-20220310134642756"></p>
<h2 id="九、数据库备份"><a href="#九、数据库备份" class="headerlink" title="九、数据库备份"></a>九、数据库备份</h2><p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220310135055662.png" alt="image-20220310135055662"></p>
<p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220310135152003.png" alt="image-20220310135152003"></p>
<p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220310135325157.png" alt="image-20220310135325157"></p>
<p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220310135422641.png" alt="image-20220310135422641"></p>
<p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220310135451972.png" alt="image-20220310135451972"></p>
<p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220310135553045.png" alt="image-20220310135553045"></p>
<p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220310135655265.png" alt="image-20220310135655265"></p>
<p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220310135716727.png" alt="image-20220310135716727"></p>
<p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220310135819226.png" alt="image-20220310135819226"></p>
<p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220310135849437.png" alt="image-20220310135849437"></p>
<p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220310135952794.png" alt="image-20220310135952794"></p>
<p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220310140011041.png" alt="image-20220310140011041"></p>
<p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220310140058379.png" alt="image-20220310140058379"></p>
<p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220310140144108.png" alt="image-20220310140144108"></p>
<p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220310140311457.png" alt="image-20220310140311457"></p>
<p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220310140338451.png" alt="image-20220310140338451"></p>
<p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220310140410974.png" alt="image-20220310140410974"></p>
<p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220310140508008.png" alt="image-20220310140508008"></p>
<p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220310140545447.png" alt="image-20220310140545447"></p>
<p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220310140631579.png" alt="image-20220310140631579"></p>
<p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220310140707212.png" alt="image-20220310140707212"></p>
<p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220310140808086.png" alt="image-20220310140808086"></p>
<p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220310140825331.png" alt="image-20220310140825331"></p>
<p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220310140859356.png" alt="image-20220310140859356"></p>
<p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220310140956111.png" alt="image-20220310140956111"></p>
<p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220310141023978.png" alt="image-20220310141023978"></p>
<p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220310141157866.png" alt="image-20220310141157866"></p>
<p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220310141247257.png" alt="image-20220310141247257"></p>
<p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220310141435999.png" alt="image-20220310141435999"></p>
<p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220310141555735.png" alt="image-20220310141555735"></p>
<p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220310141745031.png" alt="image-20220310141745031"></p>
<p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220310141833972.png" alt="image-20220310141833972"></p>
<p><img src="C:\Users\PengY\AppData\Roaming\Typora\typora-user-images\image-20220310141923355.png" alt="image-20220310141923355"></p>

                
            </div>
            <hr/>

            

    <div class="reprint" id="reprint-statement">
        
            <div class="reprint__author">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-user">
                        文章作者:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="/about" rel="external nofollow noreferrer">Peng</a>
                </span>
            </div>
            <div class="reprint__type">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-link">
                        文章链接:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="https://yappedyen.top/2023/06/27/mysql/">https://yappedyen.top/2023/06/27/mysql/</a>
                </span>
            </div>
            <div class="reprint__notice">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-copyright">
                        版权声明:
                    </i>
                </span>
                <span class="reprint-info">
                    本博客所有文章除特別声明外，均采用
                    <a href="https://creativecommons.org/licenses/by/4.0/deed.zh" rel="external nofollow noreferrer" target="_blank">CC BY 4.0</a>
                    许可协议。转载请注明来源
                    <a href="/about" target="_blank">Peng</a>
                    !
                </span>
            </div>
        
    </div>

    <script async defer>
      document.addEventListener("copy", function (e) {
        let toastHTML = '<span>复制成功，请遵循本文的转载规则</span><button class="btn-flat toast-action" onclick="navToReprintStatement()" style="font-size: smaller">查看</a>';
        M.toast({html: toastHTML})
      });

      function navToReprintStatement() {
        $("html, body").animate({scrollTop: $("#reprint-statement").offset().top - 80}, 800);
      }
    </script>



            <div class="tag_share" style="display: block;">
                <div class="post-meta__tag-list" style="display: inline-block;">
                    
                        <div class="article-tag">
                            <span class="chip bg-color">无标签</span>
                        </div>
                    
                </div>
                <div class="post_share" style="zoom: 80%; width: fit-content; display: inline-block; float: right; margin: -0.15rem 0;">
                    <link rel="stylesheet" type="text/css" href="/libs/share/css/share.min.css">
<div id="article-share">

    
    <div class="social-share" data-sites="twitter,facebook,google,qq,qzone,wechat,weibo,douban,linkedin" data-wechat-qrcode-helper="<p>微信扫一扫即可分享！</p>"></div>
    <script src="/libs/share/js/social-share.min.js"></script>
    

    

</div>

                </div>
            </div>
            
        </div>
    </div>

    

    

    

    

    

    

    

    

    

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge left-badge text-color">
                <i class="fas fa-chevron-left"></i>&nbsp;上一篇</div>
            <div class="card">
                <a href="/2023/06/27/tcp-udp/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/5.jpg" class="responsive-img" alt="TCP_UDP">
                        
                        <span class="card-title">TCP_UDP</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            
                        
                    </div>
                    <div class="publish-info">
                        <span class="publish-date">
                            <i class="far fa-clock fa-fw icon-date"></i>2023-06-27
                        </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-user fa-fw"></i>
                            Peng
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/Network/">
                        <span class="chip bg-color">Network</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge right-badge text-color">
                下一篇&nbsp;<i class="fas fa-chevron-right"></i>
            </div>
            <div class="card">
                <a href="/2023/06/27/linuxlock/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/15.jpg" class="responsive-img" alt="Linuxlock">
                        
                        <span class="card-title">Linuxlock</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="far fa-clock fa-fw icon-date"></i>2023-06-27
                            </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-user fa-fw"></i>
                            Peng
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/C/">
                        <span class="chip bg-color">C++</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
    </div>
</article>

</div>



<!-- 代码块功能依赖 -->
<script type="text/javascript" src="/libs/codeBlock/codeBlockFuction.js"></script>


  <!-- 是否加载使用自带的 prismjs. -->
  <script type="text/javascript" src="/libs/prism/prism.min.js"></script>


<!-- 代码语言 -->

<script type="text/javascript" src="/libs/codeBlock/codeLang.js"></script>


<!-- 代码块复制 -->

<script type="text/javascript" src="/libs/codeBlock/codeCopy.js"></script>


<!-- 代码块收缩 -->

<script type="text/javascript" src="/libs/codeBlock/codeShrink.js"></script>



    </div>
    <div id="toc-aside" class="expanded col l3 hide-on-med-and-down">
        <div class="toc-widget card" style="background-color: white;">
            <div class="toc-title"><i class="far fa-list-alt"></i>&nbsp;&nbsp;目录</div>
            <div id="toc-content"></div>
        </div>
    </div>
</div>

<!-- TOC 悬浮按钮. -->

<div id="floating-toc-btn" class="hide-on-med-and-down">
    <a class="btn-floating btn-large bg-color">
        <i class="fas fa-list-ul"></i>
    </a>
</div>


<script src="/libs/tocbot/tocbot.min.js"></script>
<script>
    $(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingsOffset: -($(window).height() * 0.4 - 45),
            collapseDepth: Number('0'),
            headingSelector: 'h2, h3, h4'
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });

        
        /* 修复文章卡片 div 的宽度. */
        let fixPostCardWidth = function (srcId, targetId) {
            let srcDiv = $('#' + srcId);
            if (srcDiv.length === 0) {
                return;
            }

            let w = srcDiv.width();
            if (w >= 450) {
                w = w + 21;
            } else if (w >= 350 && w < 450) {
                w = w + 18;
            } else if (w >= 300 && w < 350) {
                w = w + 16;
            } else {
                w = w + 14;
            }
            $('#' + targetId).width(w);
        };

        // 切换TOC目录展开收缩的相关操作.
        const expandedClass = 'expanded';
        let $tocAside = $('#toc-aside');
        let $mainContent = $('#main-content');
        $('#floating-toc-btn .btn-floating').click(function () {
            if ($tocAside.hasClass(expandedClass)) {
                $tocAside.removeClass(expandedClass).hide();
                $mainContent.removeClass('l9');
            } else {
                $tocAside.addClass(expandedClass).show();
                $mainContent.addClass('l9');
            }
            fixPostCardWidth('artDetail', 'prenext-posts');
        });
        
    });
</script>

    

</main>




    <footer class="page-footer bg-color">
    
        <link rel="stylesheet" href="/libs/aplayer/APlayer.min.css">
<style>
    .aplayer .aplayer-lrc p {
        
        display: none;
        
        font-size: 12px;
        font-weight: 700;
        line-height: 16px !important;
    }

    .aplayer .aplayer-lrc p.aplayer-lrc-current {
        
        display: none;
        
        font-size: 15px;
        color: #42b983;
    }

    
    .aplayer.aplayer-fixed.aplayer-narrow .aplayer-body {
        left: -66px !important;
    }

    .aplayer.aplayer-fixed.aplayer-narrow .aplayer-body:hover {
        left: 0px !important;
    }

    
</style>
<div class="">
    
    <div class="row">
        <meting-js class="col l8 offset-l2 m10 offset-m1 s12"
                   server="netease"
                   type="playlist"
                   id="503838841"
                   fixed='true'
                   autoplay='false'
                   theme='#42b983'
                   loop='all'
                   order='random'
                   preload='auto'
                   volume='0.7'
                   list-folded='true'
        >
        </meting-js>
    </div>
</div>

<script src="/libs/aplayer/APlayer.min.js"></script>
<script src="/libs/aplayer/Meting.min.js"></script>

    

    <div class="container row center-align"
         style="margin-bottom: 0px !important;">
        <div class="col s12 m8 l8 copy-right">
            Copyright&nbsp;&copy;
            
                <span id="year">2019-2023</span>
            
            <a href="/about" target="_blank">Peng</a>
            |&nbsp;Powered by&nbsp;<a href="https://hexo.io/" target="_blank">Hexo</a>
            |&nbsp;Theme&nbsp;<a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank">Matery</a>
            
                <span id="translate">|&nbsp;繁/简：</span><a id="translateLink" href="javascript:translatePage();">繁</a>
            
            <br>
            
            
            
                
            
            
                <span id="busuanzi_container_site_pv">
                &nbsp;|&nbsp;<i class="far fa-eye"></i>&nbsp;总访问量:&nbsp;
                    <span id="busuanzi_value_site_pv" class="white-color"></span>
            </span>
            
            
                <span id="busuanzi_container_site_uv">
                &nbsp;|&nbsp;<i class="fas fa-users"></i>&nbsp;总访问人数:&nbsp;
                    <span id="busuanzi_value_site_uv" class="white-color"></span>
            </span>
            
            <br>

            <!-- 运行天数提醒. -->
            
            <br>
            
        </div>
        <div class="col s12 m4 l4 social-link social-statis">
    <a href="https://github.com/yappedyen" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50">
        <i class="fab fa-github"></i>
    </a>



    <a href="mailto:2696541439@qq.com" class="tooltipped" target="_blank" data-tooltip="邮件联系我" data-position="top" data-delay="50">
        <i class="fas fa-envelope-open"></i>
    </a>







    <a href="tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=2696541439" class="tooltipped" target="_blank" data-tooltip="QQ联系我: 2696541439" data-position="top" data-delay="50">
        <i class="fab fa-qq"></i>
    </a>







    <a href="/atom.xml" class="tooltipped" target="_blank" data-tooltip="RSS 订阅" data-position="top" data-delay="50">
        <i class="fas fa-rss"></i>
    </a>

</div>
    </div>
</footer>

<div class="progress-bar"></div>


    <!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title"><i class="fas fa-search"></i>&nbsp;&nbsp;搜索</span>
            <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字"
                   class="search-input">
        </div>
        <div id="searchResult"></div>
    </div>
</div>

<script type="text/javascript">
$(function () {
    var searchFunc = function (path, search_id, content_id) {
        'use strict';
        $.ajax({
            url: path,
            dataType: "xml",
            success: function (xmlResponse) {
                // get the contents from search data
                var datas = $("entry", xmlResponse).map(function () {
                    return {
                        title: $("title", this).text(),
                        content: $("content", this).text(),
                        url: $("url", this).text()
                    };
                }).get();
                var $input = document.getElementById(search_id);
                var $resultContent = document.getElementById(content_id);
                $input.addEventListener('input', function () {
                    var str = '<ul class=\"search-result-list\">';
                    var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
                    $resultContent.innerHTML = "";
                    if (this.value.trim().length <= 0) {
                        return;
                    }
                    // perform local searching
                    datas.forEach(function (data) {
                        var isMatch = true;
                        var data_title = data.title.trim().toLowerCase();
                        var data_content = data.content.trim().replace(/<[^>]+>/g, "").toLowerCase();
                        var data_url = data.url;
                        data_url = data_url.indexOf('/') === 0 ? data.url : '/' + data_url;
                        var index_title = -1;
                        var index_content = -1;
                        var first_occur = -1;
                        // only match artiles with not empty titles and contents
                        if (data_title !== '' && data_content !== '') {
                            keywords.forEach(function (keyword, i) {
                                index_title = data_title.indexOf(keyword);
                                index_content = data_content.indexOf(keyword);
                                if (index_title < 0 && index_content < 0) {
                                    isMatch = false;
                                } else {
                                    if (index_content < 0) {
                                        index_content = 0;
                                    }
                                    if (i === 0) {
                                        first_occur = index_content;
                                    }
                                }
                            });
                        }
                        // show search results
                        if (isMatch) {
                            str += "<li><a href='" + data_url + "' class='search-result-title'>" + data_title + "</a>";
                            var content = data.content.trim().replace(/<[^>]+>/g, "");
                            if (first_occur >= 0) {
                                // cut out 100 characters
                                var start = first_occur - 20;
                                var end = first_occur + 80;
                                if (start < 0) {
                                    start = 0;
                                }
                                if (start === 0) {
                                    end = 100;
                                }
                                if (end > content.length) {
                                    end = content.length;
                                }
                                var match_content = content.substr(start, end);
                                // highlight all keywords
                                keywords.forEach(function (keyword) {
                                    var regS = new RegExp(keyword, "gi");
                                    match_content = match_content.replace(regS, "<em class=\"search-keyword\">" + keyword + "</em>");
                                });

                                str += "<p class=\"search-result\">" + match_content + "...</p>"
                            }
                            str += "</li>";
                        }
                    });
                    str += "</ul>";
                    $resultContent.innerHTML = str;
                });
            }
        });
    };

    searchFunc('/search.xml', 'searchInput', 'searchResult');
});
</script>

    <!-- 白天和黑夜主题 -->
<div class="stars-con">
    <div id="stars"></div>
    <div id="stars2"></div>
    <div id="stars3"></div>  
</div>

<script>
    function switchNightMode() {
        $('<div class="Cuteen_DarkSky"><div class="Cuteen_DarkPlanet"></div></div>').appendTo($('body')),
        setTimeout(function () {
            $('body').hasClass('DarkMode') 
            ? ($('body').removeClass('DarkMode'), localStorage.setItem('isDark', '0'), $('#sum-moon-icon').removeClass("fa-sun").addClass('fa-moon')) 
            : ($('body').addClass('DarkMode'), localStorage.setItem('isDark', '1'), $('#sum-moon-icon').addClass("fa-sun").removeClass('fa-moon')),
            
            setTimeout(function () {
            $('.Cuteen_DarkSky').fadeOut(1e3, function () {
                $(this).remove()
            })
            }, 2e3)
        })
    }
</script>

    <!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fas fa-arrow-up"></i>
    </a>
</div>


    <script src="/libs/materialize/materialize.min.js"></script>
    <script src="/libs/masonry/masonry.pkgd.min.js"></script>
    <script src="/libs/aos/aos.js"></script>
    <script src="/libs/scrollprogress/scrollProgress.min.js"></script>
    <script src="/libs/lightGallery/js/lightgallery-all.min.js"></script>
    <script src="/js/matery.js"></script>

    

    
        <script type="text/javascript" src="/js/tw_cn.js"></script>
        <script type="text/javascript">
          var defaultEncoding = 2; //网站编写字体是否繁体，1-繁体，2-简体
          var translateDelay = 0; //延迟时间,若不在前, 要设定延迟翻译时间, 如100表示100ms,默认为0
          var cookieDomain = "https://yappedyen.top"; //Cookie地址, 一定要设定, 通常为你的网址
          var msgToTraditionalChinese = "繁"; //此处可以更改为你想要显示的文字
          var msgToSimplifiedChinese = "简"; //同上，但两处均不建议更改
          var translateButtonId = "translateLink"; //默认互换id
          translateInitilization();
        </script>
    
    
    
        
        <script type="text/javascript">
            // 只在桌面版网页启用特效
            var windowWidth = $(window).width();
            if (windowWidth > 768) {
                document.write('<script type="text/javascript" src="/libs/others/sakura.js"><\/script>');
            }
        </script>
    

    <!-- 雪花特效 -->
    

    <!-- 鼠标星星特效 -->
    

     
        <script src="https://ssl.captcha.qq.com/TCaptcha.js"></script>
        <script src="/libs/others/TencentCaptcha.js"></script>
        <button id="TencentCaptcha" data-appid="xxxxxxxxxx" data-cbfn="callback" type="button" hidden></button>
    

    <!-- Baidu Analytics -->

    <!-- Baidu Push -->

<script>
    (function () {
        var bp = document.createElement('script');
        var curProtocol = window.location.protocol.split(':')[0];
        if (curProtocol === 'https') {
            bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
        } else {
            bp.src = 'http://push.zhanzhang.baidu.com/push.js';
        }
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(bp, s);
    })();
</script>

    
    <script src="/libs/others/clicklove.js" async="async"></script>
    
    
    <script async src="/libs/others/busuanzi.pure.mini.js"></script>
    

    

    

    <!--腾讯兔小巢-->
    
    

    

    

    
    <script src="/libs/instantpage/instantpage.js" type="module"></script>
    

</body>

</html>
